Тема #13 (React): Обработка Ошибок (Error Boundaries)

1. Проблема: Ошибки JS в Компонентах Рушат Всё Приложение

Представь, что в одном из твоих компонентов во время рендеринга (или в его конструкторе, или в методах жизненного цикла классового компонента) происходит неперехваченная ошибка JavaScript (например, доступ к свойству null, вызов несуществующего метода).

Поведение React по умолчанию (до Error Boundaries): Такая ошибка приводила к размонтированию всего дерева React-компонентов. Пользователь видел просто белый экран или сломанное приложение. Это очень плохой UX.

2. Решение: Предохранители Ошибок (Error Boundaries)

Что это? Специальные React-компоненты, которые ловят JavaScript ошибки, происходящие в любом месте их дочернего дерева компонентов во время рендеринга, в методах жизненного цикла и в конструкторах.
Задачи:
Поймать ошибку: Не дать ей "всплыть" выше и разрушить все приложение.
Отобразить запасной UI (Fallback UI): Вместо сломанного дерева показать пользователю сообщение об ошибке или какой-то альтернативный интерфейс.
Залогировать ошибку: Отправить информацию об ошибке (сообщение, стек вызовов компонента) в систему мониторинга (Sentry, LogRocket и т.д.), чтобы разработчики могли ее исправить.
3. Как Реализовать Error Boundary? – Только Классовые Компоненты!

Важное Ограничение: На данный момент (и это вряд ли изменится в ближайшем будущем) Error Boundary можно создать только с помощью классового компонента. Хуков для этой функциональности не существует.

Необходимые Методы Жизненного Цикла: Класс должен реализовать хотя бы один (или оба) из этих методов:

static getDerivedStateFromError(error: Error):
Когда вызывается: Сразу после того, как потомок выбросил ошибку, до фазы коммита (т.е. до обновления DOM).
Назначение: Обновить состояние Error Boundary (обычно установить флаг hasError: true), чтобы при следующем рендере показать запасной UI.
Ограничение: Должен быть чистой функцией, не должен содержать побочных эффектов. Просто возвращает объект для обновления state или null.
componentDidCatch(error: Error, errorInfo: ErrorInfo):
Когда вызывается: После того, как ошибка была выброшена и getDerivedStateFromError отработал, уже в фазе коммита.
Назначение: Выполнить любые побочные эффекты, например, залогировать ошибку и errorInfo (который содержит componentStack — трассировку стека именно React-компонентов!).
Ограничение: Вызывается только для ошибок от дочерних компонентов. Не может поймать ошибку в самом себе.
Пример Реализации:

TypeScript

import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode; // Можно передать кастомный fallback
}
interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  // Статический метод для обновления state при ошибке
  static getDerivedStateFromError(error: Error): State {
    console.log("ErrorBoundary: getDerivedStateFromError");
    // Обновляем state, чтобы следующий рендер показал fallback UI
    return { hasError: true, error: error };
  }

  // Метод для логирования ошибки
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("ErrorBoundary поймал ошибку:", error, errorInfo.componentStack);
    // Отправка ошибки в систему мониторинга:
    // logErrorToService(error, errorInfo.componentStack);
  }

  render() {
    if (this.state.hasError) {
      // Если произошла ошибка, рендерим fallback UI
      return this.props.fallback || <h1>Что-то пошло не так.</h1>;
    }
    // Иначе рендерим дочерние компоненты как обычно
    return this.props.children;
  }
}
export default ErrorBoundary;
Как Использовать: Просто оберните часть вашего дерева компонентов в <ErrorBoundary>.

JavaScript

<App>
  <Navbar />
  <ErrorBoundary fallback={<p>Не удалось загрузить ленту новостей.</p>}>
    <NewsFeed />
  </ErrorBoundary>
  <ErrorBoundary fallback={<p>Ошибка в виджете погоды.</p>}>
    <WeatherWidget />
  </ErrorBoundary>
  <Footer />
</App>
4. Что Error Boundaries НЕ Ловят (Критически Важно!)

Они не являются универсальным try...catch для всего приложения. Они НЕ ловят ошибки в:

Обработчиках событий: Ошибки в onClick, onSubmit и т.д. нужно ловить с помощью обычного try...catch внутри самого обработчика.
Асинхронном коде: Ошибки в setTimeout, setInterval, колбэках промисов (.then, .catch вне рендера), async/await (если await не происходит прямо во время рендера). Для них используйте .catch() для промисов или try...catch внутри async функций.
Серверном рендеринге (SSR): Там свои механизмы обработки ошибок.
Самом Error Boundary: Ошибка в коде render, getDerivedStateFromError или componentDidCatch самого Error Boundary не будет поймана им же, а "всплывет" до следующего Error Boundary выше по дереву.
5. Стратегия Размещения

Гранулярность: Можно обернуть всё приложение в один глобальный Error Boundary (чтобы показать общее сообщение "Все сломалось"). А можно размещать их более гранулярно — вокруг отдельных виджетов, секций страницы или роутов, чтобы при ошибке в одной части интерфейса остальная часть приложения продолжала работать и показывался более релевантный fallback.
Критический взгляд: Выбор гранулярности — это компромисс между отказоустойчивостью отдельных частей и простотой. Часто имеет смысл оборачивать независимые друг от друга крупные блоки UI.
Итог по Теме #13:

Error Boundaries — это специализированный механизм React для повышения отказоустойчивости приложения. Они позволяют перехватывать ошибки рендеринга в дочерних компонентах, отображать запасной интерфейс вместо "белого экрана" и логировать информацию об ошибке для разработчиков. Важно помнить об их ограничениях (не ловят ошибки в событиях и асинхронном коде) и о том, что они требуют использования классовых компонентов. Это необходимый инструмент для создания стабильных React-приложений для продакшена.
