Вот разбор Темы #11 (React): Мемоизация (React.memo, useMemo, useCallback) и Преждевременная Оптимизация:

1. Что такое Мемоизация и Зачем она в React?

Мемоизация: Общая техника оптимизации, при которой результаты выполнения "дорогих" функций кешируются. При повторном вызове с теми же аргументами возвращается результат из кеша, а не выполняется повторное вычисление.
Контекст React: Компоненты ре-рендерятся при изменении state или props. Рендеринг может быть "дорогим" (сложные вычисления, большое дерево JSX). Дочерние компоненты по умолчанию ре-рендерятся при ре-рендере родителя, даже если их пропсы не изменились.
Цель мемоизации в React: Пропустить ненужные ре-рендеры или избежать повторных дорогостоящих вычислений внутри компонента.
2. Инструменты Мемоизации в React:

React.memo(Component, arePropsEqual?) – Мемоизация Компонентов:

Что делает: Это Компонент Высшего Порядка (HOC), который "оборачивает" ваш функциональный компонент. React будет пропускать ре-рендер обернутого компонента, если его пропсы не изменились.
Сравнение пропсов: По умолчанию React делает поверхностное сравнение (shallow comparison) пропсов. Для примитивов сравниваются значения, для объектов и массивов — ссылки.
arePropsEqual: Опциональная функция (prevProps, nextProps) => boolean для кастомной логики сравнения, если поверхностного недостаточно (используется редко).
Пример:
TypeScript

interface UserProps { user: { id: number; name: string }; }

// Компонент, который мы хотим мемоизировать
const UserDisplay: React.FC<UserProps> = ({ user }) => {
  console.log(`Rendering UserDisplay for ${user.name}`);
  return <div>{user.name}</div>;
}

// Создаем мемоизированную версию
const MemoizedUserDisplay = React.memo(UserDisplay);

function App() {
  const [user, setUser] = useState({ id: 1, name: "Alice" });
  const [counter, setCounter] = useState(0); // Другое состояние

  useEffect(() => {
    // Имитация обновления пользователя (создаем НОВЫЙ объект!)
    const timer = setTimeout(() => setUser({ id: 1, name: "Alice V2" }), 2000);
    return () => clearTimeout(timer);
  }, []);

  return (
    <div>
      <button onClick={() => setCounter(c => c + 1)}>Increment unrelated ({counter})</button>
      {/* MemoizedUserDisplay НЕ будет ре-рендериться при изменении 'counter',
          т.к. его проп 'user' (по ссылке) не менялся, пока не сработает setTimeout */}
      <MemoizedUserDisplay user={user} />
      {/* Обычный UserDisplay ре-рендерился бы при каждом клике на кнопку */}
      {/* <UserDisplay user={user} /> */}
    </div>
  );
}
useMemo(calculateValue, dependencies) – Мемоизация Значений:

Что делает: Мемоизирует результат выполнения функции calculateValue.
Как работает: Выполняет calculateValue только при первом рендере и при изменении хотя бы одной зависимости из массива dependencies. В остальных случаях возвращает закешированное значение из предыдущего рендера.
Применение:
Оптимизация действительно дорогих синхронных вычислений внутри компонента.
Создание стабильных ссылок на объекты или массивы, которые передаются как пропсы в мемоизированные дочерние компоненты (чтобы React.memo у дочернего компонента не срабатывал ложно).
Пример:
TypeScript

function ComponentWithExpensiveCalc({ data }) {
  // Представим, что computeSomething(data) - очень долгая операция
  const computedValue = useMemo(() => {
    console.log("Running expensive calculation...");
    return computeSomething(data);
  }, [data]); // Пересчет только если 'data' изменилась

  // Создание стабильного объекта для пропсов
  const styleOptions = useMemo(() => ({
     color: 'blue',
     padding: 10
  }), []); // Пустой массив - объект создастся 1 раз

  return (
    <div>
      Computed: {computedValue}
      {/* <MemoizedChild options={styleOptions} /> */}
    </div>
  );
}
useCallback(callbackFunction, dependencies) – Мемоизация Функций:

Что делает: Мемоизирует саму функцию callbackFunction.
Как работает: Возвращает ту же самую ссылку на функцию между рендерами, пока не изменится хотя бы одна зависимость из массива dependencies.
Основное Применение: Передача стабильных колбэков в дочерние компоненты, обернутые в React.memo, или в качестве зависимостей для других хуков (useEffect, useMemo).
Почему нужно? Функции, объявленные внутри компонента, создаются заново при каждом рендере, получая новую ссылку. Если передать такую "новую" функцию в React.memo-компонент, он будет ре-рендериться каждый раз, т.к. проп-функция изменилась (по ссылке).
Пример:
TypeScript

const MemoizedButton = React.memo(({ onClick, children }) => {
  console.log(`Rendering button: ${children}`);
  return <button onClick={onClick}>{children}</button>;
});

function Parent() {
  const [count1, setCount1] = useState(0);
  const [count2, setCount2] = useState(0);

  // НЕСТАБИЛЬНАЯ функция - создается заново при каждом рендере Parent
  // const handleIncrement1 = () => setCount1(c => c + 1);

  // СТАБИЛЬНАЯ функция с useCallback
  const handleIncrement1 = useCallback(() => {
    setCount1(c => c + 1);
  }, []); // Зависимостей нет, функция всегда будет одинаковой

  // Стабильная функция с useCallback и зависимостью
  const handleIncrement2 = useCallback(() => {
    // Представим, что она зависит от count1
    setCount2(c => c + count1);
  }, [count1]); // Зависит от count1! Будет создана заново при изменении count1.

  return (
    <div>
       {/* MemoizedButton с handleIncrement1 будет ре-рендериться только 1 раз */}
       <MemoizedButton onClick={handleIncrement1}>Increment 1 ({count1})</MemoizedButton>
       {/* MemoizedButton с handleIncrement2 будет ре-рендериться при изменении count1 или count2 */}
       <MemoizedButton onClick={handleIncrement2}>Increment 2 ({count2})</MemoizedButton>
    </div>
  );
}
4. Критический Взгляд: Преждевременная Оптимизация? (Противоречие #7)

Не Оптимизируйте Слепо! Мемоизация — это инструмент оптимизации, а не стандартная практика для каждого компонента или вычисления.
Цена Мемоизации: Сами вызовы React.memo, useMemo, useCallback тоже имеют небольшую стоимость (создание оберток, сравнение зависимостей, хранение кеша). Чрезмерное, необоснованное использование может усложнить код и не дать реального выигрыша в производительности, а иногда даже немного замедлить его.
Профилируйте Сначала! Золотое правило: Используйте React DevTools Profiler, чтобы найти реальные узкие места в производительности — компоненты, которые ре-рендерятся слишком часто и/или сам рендеринг которых занимает много времени. Только после обнаружения проблемы применяйте мемоизацию точечно.
Когда мемоизация оправдана:
React.memo: Для компонентов, которые часто ре-рендерятся с теми же пропсами и чей собственный рендер достаточно дорог. Особенно для элементов в длинных списках.
useMemo: Для действительно дорогих вычислений или для сохранения стабильности ссылок на объекты/массивы, передаваемые как пропсы в React.memo-компоненты.
useCallback: В основном для передачи стабильных колбэков в React.memo-компоненты или в массивы зависимостей useEffect/useMemo, чтобы избежать лишних перезапусков эффектов/пересчетов.
5. Массив Зависимостей и Иммутабельность (снова!)

Хуки useMemo и useCallback так же зависят от массива зависимостей, как и useEffect. Все те же правила и проблемы применимы:
Пропуск зависимости приведет к возврату устаревшего/неактуального кешированного значения или колбэка.
Включение нестабильных ссылок (объекты/массивы/функции, создаваемые при каждом рендере) сделает мемоизацию бесполезной.
Иммутабельность и стабильные ссылки — ключ к тому, чтобы массивы зависимостей работали корректно. Используйте useMemo для стабилизации объектов/массивов и useCallback для стабилизации функций, если они используются в зависимостях других хуков мемоизации или useEffect.
Итог по Теме #11:

Мемоизация (React.memo, useMemo, useCallback) — важный инструмент для оптимизации производительности React-приложений путем пропуска ненужных ре-рендеров и вычислений. Однако это не серебряная пуля и не должна применяться бездумно. Профилирование — ваш главный гид. Эффективность мемоизации сильно зависит от правильного управления массивами зависимостей и соблюдения принципов иммутабельности и стабильности ссылок.
