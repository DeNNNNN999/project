Тема #3 (React): Компоненты: Функции (+ Жизненный цикл?) vs Классы

Компоненты — это независимые, переиспользуемые части UI. В React есть два основных способа их определения: через классы (исторически первый способ для stateful-компонентов) и через функции (современный стандарт, особенно с появлением хуков).

1. Классовые Компоненты (Class Components) – Наследие Прошлого

Синтаксис: Используют синтаксис ES6 классов, наследуясь от React.Component или React.PureComponent.
JavaScript

import React from 'react';

interface CounterProps { initialCount?: number; }
interface CounterState { count: number; }

class CounterClass extends React.Component<CounterProps, CounterState> {
  constructor(props: CounterProps) {
    super(props);
    this.state = { count: props.initialCount || 0 };
    // Ручное привязывание 'this' (или использовать стрелочные функции для методов)
    // this.increment = this.increment.bind(this);
  }

  // Пример метода жизненного цикла
  componentDidMount() {
    console.log("CounterClass mounted");
  }

  // Обязательный метод render
  render() {
    return (
      <div>
        <p>Class Count: {this.state.count}</p>
        {/* Нужен bind или стрелочная функция для сохранения this */}
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }

  // Метод класса (нуждается в bind или должен быть стрелочной функцией)
  increment = () => { // Используем стрелочную функцию как свойство класса
    // Обновление state через this.setState (асинхронное!)
    this.setState(prevState => ({ count: prevState.count + 1 }));
  }
}
Ключевые особенности:
Состояние: Хранится в this.state, обновляется через this.setState() (асинхронно, обычно сливает state).
Жизненный цикл: Имеют набор явных методов жизненного цикла (componentDidMount, componentDidUpdate, componentWillUnmount, shouldComponentUpdate и др.), которые вызываются React в определенные моменты.
this: Вся логика сильно завязана на контекст this для доступа к props, state и методам. Требует внимательного управления this, особенно в обработчиках событий (через .bind() в конструкторе или стрелочные функции как свойства класса).
Критический взгляд: Классы были необходимы до хуков для создания stateful-компонентов. Но они многословны, проблемы с this постоянно вызывали ошибки, а логику, относящуюся к одной фиче, часто приходилось размазывать по разным методам жизненного цикла (componentDidMount, componentDidUpdate, componentWillUnmount для одной подписки, например). Переиспользование stateful-логики было сложным (требовало HOCs или Render Props).
2. Функциональные Компоненты (FC) + Хуки (Hooks) – Современный Стандарт

Синтаксис: Обычные JavaScript функции (или стрелочные функции), принимающие props и возвращающие JSX.
JavaScript

import React, { useState, useEffect } from 'react';

interface CounterProps { initialCount?: number; }

// React.FC<Props> - один из способов типизации (дает 'children' неявно)
// Или просто (props: CounterProps) => JSX.Element
const CounterFunc: React.FC<CounterProps> = ({ initialCount = 0 }) => {
  // Состояние через хук useState (использует замыкание!)
  const [count, setCount] = useState<number>(initialCount);

  // Эффекты (аналог lifecycle) через хук useEffect
  useEffect(() => {
    console.log("CounterFunc mounted or count changed");
    // Функция очистки (аналог componentWillUnmount)
    return () => {
      console.log("CounterFunc unmounted or count changed before next effect");
    };
  }, [count]); // Массив зависимостей!

  const increment = () => {
    // Обновление состояния через функцию, возвращенную useState
    setCount(prevCount => prevCount + 1); // Функциональное обновление - безопасно
  };

  return (
    <div>
      <p>Function Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};
Ключевые особенности:
Состояние и Логика через Хуки: useState, useEffect, useContext, useReducer, useCallback, useMemo, useRef и пользовательские хуки позволяют добавить всю необходимую функциональность.
Нет this (в контексте компонента): Доступ к props и state прямой. Не нужно беспокоиться о привязке this. Логика часто опирается на замыкания для доступа к нужным значениям внутри колбэков и эффектов.
"Скрытый" Жизненный цикл (useEffect): (Ответ на Противоречие #2). У FC нет методов жизненного цикла, но хук useEffect позволяет выполнять побочные эффекты (запросы данных, подписки, манипуляции DOM) синхронизированно с рендерингом и изменениями зависимостей.
useEffect(callback, []): Выполняется один раз после монтирования (аналог componentDidMount). Функция очистки выполняется при размонтировании (аналог componentWillUnmount).
useEffect(callback, [dep1, dep2]): Выполняется после монтирования И после каждого рендера, если изменилась хотя бы одна зависимость из [dep1, dep2] (аналог componentDidUpdate + componentDidMount). Функция очистки выполняется перед следующим запуском эффекта или при размонтировании.
useEffect(callback) (без массива зависимостей): Выполняется после каждого рендера. (Используется редко). Критический взгляд на lifecycle: useEffect — это другая парадигма. Не "когда компонент смонтировался/обновился", а "когда эти данные изменились, синхронизируй с ними этот эффект". Это более декларативно, но требует тщательного управления массивом зависимостей, чтобы избежать лишних запусков или багов с "устаревшими" замыканиями.
3. Хуки vs Классы: Простота vs Ясность? (Противоречие #4)

Простота Хуков: Меньше кода, нет this, легче выделить и переиспользовать stateful-логику через пользовательские хуки (огромное преимущество!). Логика, относящаяся к одной фиче (например, подписка на что-то), может быть собрана в одном useEffect, а не разбросана по componentDidMount/Update/Unmount.
Ясность Классов (Иногда): Имена методов (componentDidMount) явно говорят, когда код выполняется. Для людей с OOP-бэкграундом это может быть привычнее. Управление сложными зависимостями в useEffect может показаться менее явным, чем проверка prevProps/prevState в componentDidUpdate.
Сложность Хуков: Массив зависимостей — главный источник сложности и ошибок для новичков. Нужно точно понимать, какие значения из замыкания используются внутри эффекта/колбэка, и как работает сравнение по ссылкам в JS. Правила Хуков (вызов на верхнем уровне и т.д.) тоже требуют привыкания.
Критический взгляд: Хуки — это мощная абстракция, которая в большинстве случаев приводит к более чистому, краткому и компонуемому коду. Да, useEffect требует аккуратности с зависимостями, но выигрыш в переиспользовании логики (Custom Hooks) и избавлении от проблем с this обычно перевешивает. "Ясность" классов часто была кажущейся, скрывая сложную логику внутри методов жизненного цикла. Хуки поощряют группировку кода по фичам, а не по фазам жизненного цикла.
4. TypeScript и Компоненты:

FC типизируются легко (React.FC<Props> или (props: Props) => ...).
Классы требуют типизации <Props, State> и аккуратной работы с типами this и state.
Хуки хорошо типизируются с помощью дженериков (useState<Type>).
Итог по Теме #3:

Функциональные компоненты с хуками — современный стандарт React. Они предлагают более простой синтаксис (без this), лучшую переиспользуемость логики (custom hooks) и более гибкое управление побочными эффектами (useEffect), хотя и требуют понимания правил хуков и аккуратной работы с зависимостями. Классы остаются рабочим вариантом (особенно для Error Boundaries), но для новой разработки FC с хуками почти всегда предпочтительнее.
