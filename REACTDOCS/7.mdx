Тема #7 (React): Хуки: Правила и Пользовательские Хуки

1. Правила Хуков – Не Просто Рекомендации!

React устанавливает два строгих правила, которым нужно следовать при использовании хуков. Это не просто советы по стилю, а требования, необходимые для корректной работы внутреннего механизма хуков. Нарушение этих правил приведет к непредсказуемым багам, которые сложно отладить. К счастью, есть ESLint плагин (eslint-plugin-react-hooks), который помогает их отслеживать.

Правило 1: Вызывайте хуки только на верхнем уровне.

Что это значит: Нельзя вызывать хуки (useState, useEffect и т.д.) внутри циклов (for, while), условных операторов (if) или вложенных обычных функций (не компонентов и не других хуков).
Почему? React полагается на порядок вызова хуков, чтобы правильно сопоставлять состояние и эффекты с конкретным вызовом хука между рендерами. Если порядок вызовов будет меняться (например, из-за if), React "запутается", какому useState принадлежит какое состояние. Вызов хуков всегда в одном и том же порядке на верхнем уровне компонента гарантирует эту стабильность.
JavaScript

function BadComponent({ shouldShow }) {
  // НЕПРАВИЛЬНО! Вызов хука внутри условия
  if (shouldShow) {
    const [state, setState] = useState(0); // Порядок вызова меняется!
    useEffect(() => { /* ... */ });      // React запутается при shouldShow=false -> true
  }
  // ...
}

function GoodComponent({ shouldShow }) {
  // ПРАВИЛЬНО! Хуки вызываются на верхнем уровне
  const [state, setState] = useState(0);
  useEffect(() => {
    if (shouldShow) { // Логика используется ВНУТРИ хука
      // ... выполнить эффект ...
    }
  }, [shouldShow]); // Зависимость указана

  if (!shouldShow) return null; // Условный рендеринг после хуков

  return <div>{state}</div>;
}
Правило 2: Вызывайте хуки только из React-функций.

Что это значит: Вызывайте хуки либо из функциональных компонентов React, либо из пользовательских хуков (функций, чье имя начинается с use...). Не вызывайте их из обычных JavaScript функций.
Почему? Хуки предназначены для "подключения" к состоянию и жизненному циклу React-компонента. Вне контекста компонента им не к чему "подключаться", и их вызов бессмысленен или приведет к ошибке.
Критический взгляд: Опора на порядок вызовов может показаться немного "магической" или неявной по сравнению с явными именами или ключами. Но это инженерный компромисс, который позволил сделать синтаксис самих хуков очень простым (не нужно передавать уникальные ID в useState и т.д.). Линтер (eslint-plugin-react-hooks) делает соблюдение этих правил гораздо проще.

2. Пользовательские Хуки (Custom Hooks) – Сила Переиспользования Логики

Это одна из самых мощных идей, пришедших с хуками.

Проблема: Часто возникает ситуация, когда одна и та же логика, включающая состояние и/или эффекты, повторяется в нескольких компонентах (например, логика запроса данных, подписка на события браузера, управление состоянием формы).
Решение: Вынести эту stateful-логику в отдельную переиспользуемую функцию, которая сама использует встроенные хуки React. Такая функция и называется "пользовательским хуком".
Соглашение об Именовании: Имя пользовательского хука обязательно должно начинаться с use (например, useFetch, useLocalStorage, useForm). Это не просто договоренность — именно префикс use позволяет ESLint-плагину проверять соблюдение Правил Хуков внутри вашего кастомного хука.
Как работают: Это обычные JavaScript функции, которые могут:
Принимать аргументы.
Вызывать другие хуки (useState, useEffect, useContext и т.д.).
Возвращать значения (обычно массив или объект, содержащий состояние и функции для его обновления, как и встроенные хуки).
Пример (useToggle):
TypeScript

import React, { useState, useCallback } from 'react';

// Пользовательский хук для управления boolean-флагом (переключателем)
function useToggle(initialState: boolean = false): [boolean, () => void] {
  const [state, setState] = useState<boolean>(initialState);

  // Используем useCallback, чтобы ссылка на функцию toggle не менялась без нужды
  const toggle = useCallback(() => {
    setState(prevState => !prevState);
  }, []); // Пустой массив зависимостей, т.к. setState стабильна

  // Возвращаем текущее состояние и функцию для его переключения
  return [state, toggle];
}

// --- Использование в компоненте ---
function LightSwitch() {
  // Используем наш кастомный хук так же, как useState
  const [isLightOn, toggleLight] = useToggle(false);

  return (
    <div>
      <p>The light is {isLightOn ? 'ON' : 'OFF'}</p>
      <button onClick={toggleLight}>
        Turn {isLightOn ? 'OFF' : 'ON'}
      </button>
    </div>
  );
}

function DarkModeToggle() {
  const [isDarkMode, toggleDarkMode] = useToggle(true); // Переиспользуем ту же логику!
  // ... остальной код ...
}
Критический взгляд: Пользовательские хуки — это основной способ композиции и переиспользования stateful-логики в современном React. Они гораздо проще и гибче старых подходов вроде Компонентов Высшего Порядка (HOCs) и Render Props. Они позволяют:
Инкапсулировать сложную логику.
Переиспользовать ее между компонентами без дублирования.
Разделять ответственность: Отделять логику управления состоянием/эффектами от логики рендеринга UI.
Упрощать тестирование: Пользовательские хуки можно тестировать изолированно. Мастерство создания и использования кастомных хуков — ключ к написанию чистого, поддерживаемого и масштабируемого React-кода.
Итог по Теме #7:

Два Правила Хуков — это нерушимые законы, обеспечивающие их корректную работу за счет стабильного порядка вызовов. Пользовательские хуки (функции use...) — это мощнейший паттерн для извлечения, переиспользования и композиции stateful-логики, являющийся одним из главных преимуществ экосистемы хуков по сравнению с классовыми компонентами.
