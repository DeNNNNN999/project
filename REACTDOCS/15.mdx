Тема #15 (TS): Тип never (в Контексте React)

Мы уже установили, что never — это специальный тип в TypeScript, представляющий значение, которое никогда не может произойти. Функция, возвращающая never, либо всегда бросает ошибку, либо уходит в бесконечный цикл. Никакое значение нельзя присвоить переменной типа never.

Зачем это нужно в React?

Основное и самое практически важное применение never в React — это проверка полноты (Exhaustiveness Checking), особенно при работе с дискриминирующими объединениями (discriminated unions), которые часто используются для:

Управления состоянием через useReducer: Описания различных типов действий (actions).
Моделирования состояний компонента: Например, 'loading' | 'success' | 'error'.
Обработки вариантов полиморфных компонентов.
Как Работает Проверка Полноты с never:

Идея в том, чтобы в конце switch или цепочки if/else, которая обрабатывает все возможные варианты объединения, добавить default (для switch) или финальный else (для if), где вы пытаетесь присвоить оставшееся значение переменной типа never.

Если вы обработали все возможные варианты из объединения, то в блок default/else управление никогда не попадет. TypeScript сможет вывести, что тип переменной в этом блоке действительно never, и ошибки компиляции не будет.
Если вы добавите новый вариант в тип объединения (например, новый тип action), но забудете добавить соответствующий case в switch, то в блок default/else теоретически сможет попасть значение этого нового типа. Попытка присвоить это значение переменной типа never вызовет ошибку компиляции!
Пример (снова с редьюсером, но акцент на never):

TypeScript

type State = { status: 'idle' | 'loading' | 'success' | 'error'; };
type Action =
  | { type: 'FETCH' }
  | { type: 'RESOLVE' }
  | { type: 'REJECT' }
  | { type: 'CANCEL' }; // <-- Добавим позже этот тип

function appReducer(state: State, action: Action): State {
  switch (action.type) {
    case 'FETCH':
      return { ...state, status: 'loading' };
    case 'RESOLVE':
      return { ...state, status: 'success' };
    case 'REJECT':
      return { ...state, status: 'error' };
    // case 'CANCEL': return { ...state, status: 'idle' }; // <-- ЗАБЫЛИ ОБРАБОТАТЬ!

    default:
      // Если мы раскомментируем 'CANCEL' в типе Action, но не добавим case,
      // сюда может попасть action с type === 'CANCEL'.
      // Попытка присвоить его к `never` вызовет ошибку компиляции:
      // "Type '{ type: "CANCEL"; }' is not assignable to type 'never'."
      const exhaustiveCheck: never = action;

      // Этот код помогает поймать ошибку на этапе компиляции!
      // В реальном коде можно либо вернуть state, либо бросить ошибку
      console.error(`Unhandled action type: ${(exhaustiveCheck as any).type}`);
      return state;
  }
}
Критический взгляд: Этот паттерн с присваиванием к never — чрезвычайно полезная техника. Она превращает потенциальную ошибку времени выполнения (необработанное состояние или действие) в ошибку времени компиляции. Это делает рефакторинг (добавление новых состояний/действий) гораздо безопаснее. Компилятор становится вашим помощником, который не даст вам забыть обновить все нужные места.
Другие (менее частые) применения never в React-контексте:

Недостижимые состояния: Если в вашей логике есть ветка, которая теоретически никогда не должна выполниться, вы можете указать тип переменной как never, чтобы TypeScript проверил это предположение.
Условные Типы: Как мы уже касались, never используется внутри сложных условных и утилитарных типов для фильтрации объединений (например, в Exclude<T, U>). Это может быть полезно при создании сложных типов для пропсов или состояния.
Итог по Теме #15:

Хотя тип never может показаться эзотерическим, его основное применение — проверка полноты обработки всех вариантов (exhaustiveness checking) в switch или if/else при работе с объединениями типов — является очень практичным и ценным инструментом в React (особенно с useReducer) и TypeScript в целом. Он повышает надежность кода и безопасность рефакторинга, используя систему типов для предотвращения логических ошибок.
