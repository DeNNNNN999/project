# Типы данных в JavaScript

Сразу забудем про сухие определения из учебников. Посмотрим на них критически, с учетом истории, неочевидных моментов и того, как это аукается нам в коде.

## Фундаментальный раскол: Примитивы vs Объекты

Казалось бы, база. Но уже здесь кроется суть философии JS и источник многих особенностей.

### Примитивы (string, number, boolean, null, undefined, symbol, bigint):

- **Неизменяемые (Immutable)**: Это ключевое! Ты не можешь изменить символ в строке или значение числа. Любая операция создает новое значение:
  ```javascript
  let str = "hi";
  str[0] = "p";
  console.log(str); // "hi"
  ```
  Это важно для понимания того, как работают сравнения и передача в функции (всегда по значению).

- **Хранятся по значению**:
  ```javascript
  let a = 5;
  let b = a;
  b = 10; // a останется 5
  ```
  Очевидно? Да. Но важно в сравнении с объектами.

### Объекты (object, включая массивы, функции, даты и т.д.):

- **Изменяемые (Mutable)**:
  ```javascript
  let obj1 = { val: 10 };
  let obj2 = obj1;
  obj2.val = 20; // obj1.val тоже станет 20
  ```

- **Хранятся и передаются по ссылке**: Переменная хранит не сам объект, а адрес в памяти. Отсюда все "сюрпризы" с копированием и сравнением объектов.

## Теперь к самим типам, с нестандартной призмы:

### null vs undefined – Вечная парочка:

- **Зачем два "ничего"?** `undefined` — это состояние переменной, которой не присвоили значение, или свойство/аргумент, которого нет. `null` — это осознанное присваивание значения "ничего" или "пусто".

- **Критический взгляд**: Действительно ли нужно было два отдельных типа для этого? Во многих языках есть только `null` (или `nil`). Эта двойственность в JS — наследие спешки и, возможно, попытки угодить разным парадигмам. Она часто порождает лишние проверки:
  ```javascript
  if (value === null || value === undefined)
  ```
  Хотя иногда различие бывает полезно для семантики.

- **Главный "прикол"**:
  ```javascript
  typeof undefined === 'undefined' // true
  typeof null === 'object' // true
  ```
  Мы уже разбирали — это исторический баг, который ломает логику `typeof` и заставляет проверять на `null` отдельно (`value === null`). Баг, ставший фичей из-за обратной совместимости.

### number – Не такой уж и точный:

- **IEEE 754 Double Precision**: Все числа в JS (до BigInt) — это 64-битные числа с плавающей точкой. Отсюда:
  - **Проблемы точности**:
    ```javascript
    0.1 + 0.2 !== 0.3 // true
    ```
    Это не баг JS, а особенность двоичного представления дробей. Но! Критически важно это осознавать, особенно при финансовых расчетах (использовать копейки/центы или библиотеки типа Decimal.js).

  - **Целые числа**: "Безопасны" только до `Number.MAX_SAFE_INTEGER` (2^53 - 1). Дальше точность теряется. Опять же, это ограничение формата.

  - **NaN (Not a Number)**: Значение, которое не равно ничему, даже самому себе:
    ```javascript
    NaN === NaN // false
    ```
    Почему? Стандарт IEEE 754 так определяет результат некорректной операции. Проверять нужно через `Number.isNaN()`. `typeof NaN === 'number'` — логично, это специальное числовое значение.

  - **Infinity и -Infinity**: Тоже валидные значения типа number. `typeof Infinity === 'number'`.

### string – Простой, но с авто-магией:

- **Неизменяемость**: Ключевой аспект.

- **Объекты-обертки**: Почему мы можем вызвать метод у примитивной строки (`"hello".toUpperCase()`)?
  Потому что JS незаметно создает временный объект-обертку `new String("hello")`, вызывает у него метод и возвращает результат. Это синтаксический сахар, чтобы примитивы вели себя удобнее, но важно понимать этот механизм "под капотом".

### boolean – Простой? Только на первый взгляд:

- Сам по себе тип прост (`true`, `false`).
- Вся сложность — в неявном преобразовании других типов к boolean (Truthy / Falsy значения) при использовании в `if`, `while`, логических операторах. Вот где зарыта собака (к этому вернемся отдельно при обсуждении Coercion).

### symbol и bigint – Новички (относительно):

- **symbol**: Добавлен в ES6. Главная цель — создание уникальных идентификаторов свойств объектов, чтобы избежать конфликтов имен (особенно для "служебных" свойств библиотек или самого языка, вроде `Symbol.iterator`). Критически: решает ли он проблему повсеместно? Часто ли его используют разработчики в прикладном коде осознанно?

- **bigint**: Добавлен позже. Решает проблему `Number.MAX_SAFE_INTEGER`. Позволяет работать с целыми числами произвольной точности. Критически: показывает, как язык эволюционирует под новые задачи (криптография, большие идентификаторы), но и добавляет сложности (нельзя смешивать number и bigint в операциях без явного преобразования).

### Оператор typeof – Не панацея:

Как мы видели, он врет про `null`. Кроме того, он возвращает `'object'` для всего, что не примитив (кроме функций). Массив? `'object'`. Дата? `'object'`. `new Number(5)`? `'object'`. Поэтому для точного определения типа объекта нужны другие подходы (`instanceof`, `Array.isArray()`, `Object.prototype.toString.call()`).

## Итог по типам (критический взгляд):

Система типов в JS — это результат быстрой разработки, влияния разных языков, стремления к "гибкости" и жестких требований обратной совместимости. Она содержит как элегантные решения (примитивы vs объекты, символы), так и явные исторические артефакты (`typeof null`) и концептуальные компромиссы (IEEE 754 для всех чисел, два вида "ничего"). Понимание этих нюансов — ключ к написанию надежного кода и разгадке многих "странностей" языка.

## Фундаментальный раскол: Примитивы vs Объекты (глубже)

### Почему такое разделение? (Value vs Reference)

#### Память и Производительность

Исторически и концептуально, примитивы — это простые, неизменяемые "кирпичики" данных. Движку JS проще и эффективнее хранить их значения прямо в стеке вызовов или там, где объявлена переменная. Когда ты пишешь `let b = a`, движок просто копирует эти несколько байт значения `a` в `b`. Это быстро.

Объекты же могут быть большими, сложными, вложенными. Хранить их целиком в стеке неэффективно и неудобно. Поэтому объект создается в "куче" (heap) — области памяти для динамически создаваемых данных, а переменная (`obj1`, `obj2`) хранит лишь ссылку (адрес) на этот объект в куче. Когда ты пишешь `let obj2 = obj1`, копируется только этот адрес, а не весь объект. Обе переменные начинают указывать на один и тот же объект в куче.

#### Семантика

Это разделение также отражает разную семантику использования. Примитивы часто представляют собой простые значения (число, строка, булево), где важна сама величина. Объекты представляют собой более сложные сущности с состоянием и поведением, где важна идентичность самой сущности.

### Почему Примитивы Неизменяемые (Immutable)?

#### Предсказуемость

Если бы строки были изменяемыми, передав строку в функцию, ты бы не мог быть уверен, что она не изменится "под капотом" этой функции, что усложнило бы отладку. С неизменяемостью ты всегда знаешь: передал "hello" — оно "hello" и останется.

#### Оптимизация

Движки могут безопасно кешировать и переиспользовать примитивные значения (особенно строки — т.н. string interning), зная, что они не изменятся. Это экономит память и ускоряет сравнения.

#### Пример "Как работает"

```javascript
let message = "Hi!";
message = message + " There";
```

Здесь не меняется исходная строка "Hi!". Создается новая строка "Hi! There", и переменная message просто начинает указывать на неё. Старая строка "Hi!", если на нее больше нет ссылок, будет удалена сборщиком мусора.

### Почему Объекты Изменяемые (Mutable)?

#### Естественное представление

Большинство сущностей реального мира, которые мы моделируем (пользователь, заказ, документ), имеют состояние, которое меняется со временем. Изменяемость объектов позволяет легко отразить это.

#### Производительность

Создавать полностью новый сложный объект при каждом изменении свойства было бы крайне неэффективно. Изменение свойства по ссылке гораздо быстрее.

#### Пример "Как работает"

```javascript
let user1 = { name: "Alice" };
let user2 = user1;
user2.name = "Bob";
```

Здесь `user1` и `user2` указывают на один объект. Инструкция `user2.name = "Bob"` находит этот объект в куче по адресу и меняет значение его свойства `name`. Так как `user1` все еще указывает на этот же объект, `console.log(user1.name)` выведет "Bob".

## null vs undefined – Зачем Двое?

### Почему undefined существует?

Это логически необходимое состояние для языка с динамической типизацией и гибким объявлением переменных/свойств. Что должно быть в переменной `let x;` до присваивания? Что должна вернуть функция без `return`? Что должно вернуться при доступе к несуществующему свойству `obj.nonExistentProp`? Ответ JS — `undefined`. Это маркер "отсутствия значения по умолчанию" или "неопределенности".

### Почему добавили null?

Часто говорят о влиянии Java. В JS `null` используется как маркер осознанного отсутствия объектного значения. То есть, программист сам присваивает `null`, чтобы показать "здесь должен быть объект, но его нет". Например, конец цепочки прототипов — `null`. DOM-метод `getElementById`, не найдя элемент, вернет `null`.

### Как проявляется проблема

Необходимость двойных проверок (`val == null` или `val === null || val === undefined`). Не всегда очевидно, вернет сторонняя функция `null` или `undefined` при ошибке/отсутствии данных. Это добавляет путаницы. Был ли выбор двух "пустот" оптимальным дизайном? Спорно.

## typeof null === 'object' – Баг Навсегда

### Как и Почему (Детальнее)

В самом первом JS (Mocha/LiveScript) значения хранились с тегом типа в младших битах. Для объектов тег был 000. `null` представлялся как машинный нулевой указатель (все биты — нули). Получилось, что представление `null` (все нули) совпало с тегом типа object (младшие биты 000). Оператор `typeof` просто проверял этот тег. Это не было осмысленным решением "`null` это подтип объекта", а чисто артефакт реализации.

### Почему не исправили?

Когда поняли ошибку, JS уже использовался на многих сайтах. Исправление `typeof null` на `'null'` сломало бы существующий код, который полагался на `typeof x === 'object'` для проверки на `null` или объект. Веб держится на обратной совместимости, поэтому баг оставили. Это ярчайший пример того, как технический долг ранних версий живет десятилетиями.

## number и IEEE 754 – Стандарт и Его Последствия

### Почему именно IEEE 754?

Это был (и есть) индустриальный стандарт для аппаратно-ускоренной работы с числами с плавающей точкой. Использование его позволило JS работать быстро на существующем железе. Альтернативы (как Decimal) потребовали бы программной реализации, что было бы на порядки медленнее, особенно в 90-е. JS изначально не метил на роль языка для высокоточных вычислений.

### Как работает неточность 0.1 + 0.2?

Компьютер хранит числа в двоичной системе. Дробь 0.1 (1/10) в двоичной системе — это бесконечная периодическая дробь 0.000110011.... Дробь 0.2 — 0.00110011.... Формат IEEE 754 (64 бита) может сохранить только ограниченное число знаков (около 53 бит для мантиссы). Происходит округление при сохранении этих бесконечных дробей. Когда ты складываешь эти уже округленные двоичные представления 0.1 и 0.2, накопленная микро-погрешность приводит к результату 0.30000000000000004.

### Как работает NaN !== NaN?

Стандарт IEEE 754 определяет NaN как результат неопределенных операций (0/0 и т.п.). И стандарт требует, чтобы любое сравнение с NaN (кроме !=) возвращало false. Логика такая: если результат операции не определен, то он не может быть равен никакому другому значению, включая другой неопределенный результат. Это сделано для того, чтобы NaN "распространялся" по вычислениям и его нельзя было случайно проигнорировать через проверку на равенство.

## string и Объекты-Обертки – Синтаксический Сахар

### Как это работает "под капотом"

1. Движок видит: `let prim = "text"; prim.length;` или `prim.toUpperCase();`
2. Понимает: обращение к свойству/методу у примитива.
3. Негласно создает: `let tempWrapper = new String(prim);`
4. Обращается к свойству/методу обертки: `let result = tempWrapper.length;` или `let result = tempWrapper.toUpperCase();`
5. Уничтожает временную обертку `tempWrapper`.
6. Возвращает `result`.

### Зачем это нужно?

Это компромисс. С одной стороны, примитивы эффективны. С другой стороны, методы — это удобно (ООП-стиль). Обертки позволяют иметь и то, и другое: работать с примитивами как с объектами, когда это нужно, не платя за это постоянными накладными расходами на объекты.

## symbol – Решение Проблемы Коллизий

### Почему понадобился?

Представь, ты пишешь библиотеку. Тебе нужно хранить какие-то служебные данные прямо в объектах пользователя. Если ты используешь строковое имя свойства, например `myLib_id`, есть риск, что у пользователя уже есть свойство с таким именем, или другая библиотека его использует. Произойдет коллизия имен.

### Как Symbol решает

`Symbol()` создает гарантированно уникальное значение. `Symbol("foo") !== Symbol("foo")`. Когда ты используешь символ как ключ объекта:

```javascript
let myID = Symbol("id");
obj[myID] = 1;
```

Ты уверен, что этот ключ не пересечется ни с каким другим строковым или символьным ключом, если только кто-то не получит ссылку именно на твой символ `myID`. Это идеально для мета-свойств, итераторов (`Symbol.iterator`), и т.д. Он скрыт от `for...in` и `JSON.stringify` по умолчанию, что подчеркивает его "служебную" природу.

## bigint – Для Больших Целых Чисел

### Почему понадобился?

Мир IT изменился с 90-х. JS стал использоваться на сервере (Node.js), в базах данных, в криптографии. Появилась потребность работать с 64-битными ID из баз данных, с очень большими числами в математических или криптографических алгоритмах, с точными временными метками высокого разрешения. Стандартный number (с его лимитом `Number.MAX_SAFE_INTEGER`) для этого не подходил.

### Как работает

Это отдельный числовой тип. Создается с суффиксом n (`123n`) или функцией `BigInt()`. Он может представлять целые числа практически неограниченного размера (ограничен только памятью). Важно: операции между number и bigint запрещены:

```javascript
1n + 2 // TypeError
```

Нужно явное преобразование:

```javascript
1n + BigInt(2) // Правильно
// или
Number(1n) + 2 // Правильно
```

Это заставляет разработчика осознанно выбирать тип и контролировать точность. Это предотвращает случайную потерю точности при смешивании типов.
