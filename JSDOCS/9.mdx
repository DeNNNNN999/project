# Замыкания (Closures)

Замыкания — это не какая-то отдельная синтаксическая конструкция, которую ты пишешь. Это фундаментальное свойство того, как работают функции и области видимости в JavaScript.

**Простое определение**: Замыкание — это комбинация функции и её лексического окружения (scope), в котором эта функция была объявлена. Лексическое окружение — это, по сути, все переменные, которые были доступны функции в момент её создания.

## Как это работает "под капотом" (критически важный механизм):

1. **Лексическая область видимости**: JS использует лексический скоупинг. Это значит, что если внутри одной функции (outer) ты объявляешь другую функцию (inner), то inner автоматически получает доступ ко всем переменным, параметрам (и даже другим функциям), объявленным внутри outer, а также ко всем переменным, к которым имела доступ сама outer (глобальные и т.д.). Этот доступ определяется тем, где функция написана в коде, а не тем, где она вызывается.

2. **"Рюкзачок" с переменными**: Когда создается функция inner, она как бы получает невидимую ссылку (внутреннее свойство, условно `[[Environment]]`) на лексическое окружение функции outer, в котором она была создана.

3. **Магия начинается, когда outer завершается**: Если функция outer возвращает функцию inner (или передает её куда-то еще, например, в setTimeout), то даже после того, как outer завершила свою работу и её собственный контекст выполнения исчез из стека вызовов, её лексическое окружение (с её переменными) НЕ уничтожается сборщиком мусора. Почему? Потому что на него всё ещё ссылается функция inner через свой "рюкзачок" `[[Environment]]`.

4. **Доступ извне**: Когда ты позже вызовешь функцию inner (которую вернула outer), она все еще будет "помнить" и иметь доступ к переменным из лексического окружения outer, захваченным в момент её создания.

## Пример для наглядности:

```javascript
function createCounter() {
  let count = 0; // Эта переменная находится в лексическом окружении createCounter

  // Эта внутренняя функция будет возвращена. Она "замыкает" переменную count.
  return function() {
    count++; // Имеет доступ к 'count' из внешнего окружения
    console.log(count);
    return count;
  };
}

// createCounter() выполнилась, её контекст ушел, НО её лексическое окружение
// (где живет 'count = 0') осталось в памяти, т.к. на него ссылается возвращенная функция.
let counter1 = createCounter();
let counter2 = createCounter(); // Создает ДРУГОЕ лексическое окружение со своим 'count'

counter1(); // Выведет 1 (count стал 1 в окружении counter1)
counter1(); // Выведет 2 (count стал 2 в окружении counter1)

counter2(); // Выведет 1 (count стал 1 в НЕЗАВИСИМОМ окружении counter2)
counter1(); // Выведет 3 (count стал 3 в окружении counter1)

// console.log(count); // Ошибка! count не доступна снаружи. Она "приватная".
```

## Критический взгляд и неочевидные моменты:

**Это не "копирование" переменных**: Внутренняя функция не копирует значения внешних переменных. Она получает живую ссылку на лексическое окружение. Если внешняя переменная изменится (до или между вызовами внутренней функции), внутренняя функция увидит это изменение (если переменная была объявлена через let/const в правильном скоупе, или если это var).

## Замыкания в циклах – Классическая ловушка с var:

```javascript
// НЕПРАВИЛЬНО с var
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    // Все 3 колбэка замыкают ОДНУ И ТУ ЖЕ переменную 'i' из внешнего окружения.
    // Когда они сработают, цикл давно закончился, и i === 3.
    console.log(`var i = ${i}`); // Выведет 3, 3, 3
  }, i * 100);
}

// ПРАВИЛЬНО с let
for (let j = 0; j < 3; j++) {
  // 'let' создает НОВУЮ переменную 'j' для КАЖДОЙ итерации цикла
  // (точнее, новую привязку в новом блочном окружении).
  setTimeout(function() {
    // Каждый колбэк замыкает свою собственную 'j'.
    console.log(`let j = ${j}`); // Выведет 0, 1, 2
  }, j * 100);
}
```

Замыкания объясняют, почему let решает эту проблему: он создает новую область видимости на каждой итерации, и колбэк замыкает переменную из этой конкретной итерационной области.

## Потребление памяти и утечки:

- Раз замыкание удерживает внешнее лексическое окружение, оно не дает сборщику мусора удалить переменные из этого окружения, пока существует ссылка на внутреннюю функцию.
- Если внутренняя функция (или объект, который на неё ссылается) "живет" долго (например, глобальная переменная, обработчик событий, который не удалили), а во внешнем окружении были большие объекты, которые нужны были только на время работы внешней функции, то эти объекты останутся в памяти, потенциально вызывая утечку памяти.
- **Критически важно**: Понимать, какие переменные реально "захватываются" замыканием. Современные движки JS очень умны и часто оптимизируют замыкания, сохраняя ссылки только на те переменные из внешнего скоупа, которые действительно используются внутри замкнутой функции, а не на всё окружение целиком. Но это детали оптимизации, на которые не всегда можно полагаться на 100%.

## Практическое Применение (где замыкания блистают):

### Инкапсуляция / Приватные переменные (Module Pattern):

```javascript
const secretModule = (function() {
  let privateData = "Секрет!"; // Приватная переменная
  let privateCounter = 0;

  function privateMethod() { // Приватный метод
    privateCounter++;
    console.log(`Вызван ${privateCounter} раз`);
  }

  // Возвращаем объект с публичным API
  return {
    getSecret: function() {
      privateMethod(); // Доступ к приватным членам через замыкание
      return privateData;
    },
    getCounter: function() {
      return privateCounter;
    }
  };
})(); // IIFE создает скоуп и сразу выполняется

console.log(secretModule.getSecret()); // Вызван 1 раз, Секрет!
console.log(secretModule.getSecret()); // Вызван 2 раз, Секрет!
console.log(secretModule.getCounter()); // 2
// console.log(secretModule.privateData); // Ошибка! Недоступно снаружи.
```

Это был основной способ создания модулей до ES6 Modules.

### Частичное применение и Каррирование:

```javascript
function multiply(a) {
  // Эта внутренняя функция замыкает 'a'
  return function(b) {
    return a * b;
  };
}
const multiplyByTwo = multiply(2); // multiplyByTwo помнит 'a = 2'
console.log(multiplyByTwo(5)); // 10
console.log(multiplyByTwo(10)); // 20

const multiplyByFive = multiply(5);
console.log(multiplyByFive(3)); // 15
```

Замыкание — это механизм, который позволяет этим техникам работать.

### Другие применения:

- **Колбэки и Обработчики событий**: Когда ты передаешь функцию как колбэк (например, в setTimeout или addEventListener), она часто должна иметь доступ к переменным, которые существовали в момент её создания, а не в момент выполнения. Замыкание обеспечивает этот доступ.
- **Функции, сохраняющие состояние**: Как в примере с createCounter.

### Производительность:
Создание замыкания (лексического окружения) — это не бесплатная операция для движка. В очень критичных к производительности участках кода (например, внутри миллиона итераций цикла) чрезмерное создание функций с замыканиями теоретически может повлиять на скорость, но на практике это крайне редко становится реальным узким местом по сравнению с другими факторами. Современные движки очень быстры.

## Итог по Замыканиям:

Замыкания — это не отдельная фича, а естественное следствие того, как работают функции и области видимости в JS. Это невероятно мощный механизм, лежащий в основе многих паттернов (модули, каррирование, обработка событий). Понимание того, как они создаются, как захватывают переменные и какие могут быть последствия для памяти — абсолютно необходимо для глубокого владения JavaScript.
