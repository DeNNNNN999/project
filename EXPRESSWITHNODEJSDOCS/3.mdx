Тема #3 (Node.js): Модульная Система: CommonJS (CJS) Глубоко

CommonJS была оригинальной системой модулей, разработанной для Node.js еще до того, как ES Modules стали частью стандарта JavaScript. Она создавалась с учетом серверных нужд.

Основные Механизмы:
require(id): Встроенная функция для синхронной загрузки модуля. id — это строка (путь к файлу или имя пакета). Когда Node встречает require, он останавливает выполнение текущего кода, находит запрошенный модуль, выполняет его код, кеширует результат и возвращает то, что модуль экспортировал.
module.exports: В каждом CJS-модуле есть специальный объект module. У него есть свойство exports (изначально пустой объект {}). Именно то, что присвоено module.exports, будет возвращено функцией require().
exports: Это просто локальная переменная-ссылка, которая по умолчанию указывает на тот же самый объект module.exports. Это синтаксический сахар для добавления свойств: exports.myFunc = ... это то же самое, что module.exports.myFunc = ....
Критическая Ловушка: Если вы переприсвоите переменную exports (exports = { myFunc: ... }), она перестанет указывать на module.exports. Внешний мир получит старый (вероятно, пустой) module.exports, а не ваш новый объект. Поэтому: либо добавляйте свойства к exports (exports.prop = ...), либо полностью переопределяйте module.exports (module.exports = ...).
Обертывание Модуля: Node.js неявно оборачивает код каждого CJS-модуля в функцию примерно такого вида:
JavaScript

(function(exports, require, module, __filename, __dirname) {
  // Ваш код модуля здесь...
});
Это создает локальную область видимости для модуля и предоставляет ему доступ к этим полезным переменным.
Кеширование: Модули кешируются после первого вызова require(). Повторные require() того же модуля вернут тот же самый объект module.exports из кеша, не выполняя код модуля заново. Это важно для производительности и для создания синглтонов.
Пример:
JavaScript

// utils.js
const PI = 3.14;
function add(a, b) { return a + b; }

// Экспортируем объект с нашими функциями/переменными
module.exports = {
  add,
  PI,
  description: "Math Utilities"
};
// Или можно было бы: exports.add = add; exports.PI = PI; ...
JavaScript

// main.js
const myUtils = require('./utils.js'); // Синхронно загружаем и выполняем utils.js

console.log(myUtils.PI); // 3.14
console.log(myUtils.add(5, 2)); // 7
console.log(myUtils.description); // Math Utilities

const myUtilsAgain = require('./utils.js'); // Берется из кеша! Код utils.js не выполняется снова.
console.log(myUtils === myUtilsAgain); // true (один и тот же объект)
Критический взгляд: CJS была простой и прагматичной системой для своего времени. Синхронный require удобен на сервере, где чтение локальных файлов обычно быстрое. Однако синхронность мешает некоторым видам оптимизаций (tree shaking) и создала проблемы при интеграции со стандартом ES Modules. Путаница exports vs module.exports — классическая ошибка новичков.
