Тема #9 (Node.js): Асинхронные Паттерны в Node (Callbacks -> Promises -> async/await)

Поскольку Node.js построен на неблокирующем вводе/выводе, эффективная работа с асинхронными операциями — это его хлеб с маслом. Стиль написания такого кода сильно эволюционировал.

1. Колбэки (Callbacks) – Наследие Прошлого

Конвенция Node.js: Исторически большинство встроенных асинхронных функций Node.js принимали последним аргументом функцию обратного вызова (колбэк). Этот колбэк обычно следовал соглашению "Error-First": первым аргументом в колбэк приходила ошибка (Error или null, если ошибки нет), а последующими — результаты операции.
JavaScript

const fs = require('fs');

fs.readFile('file.txt', 'utf8', (err, data) => { // Error-first callback
  if (err) {
    console.error("Ошибка чтения:", err);
    // Нужно как-то обработать ошибку или передать ее дальше
    return;
  }
  // Ошибки нет, работаем с data
  console.log("Файл прочитан (Callback):", data.length);
});
Проблема "Callback Hell": При выполнении нескольких последовательных асинхронных операций код превращался в "пирамиду ада" из вложенных колбэков с повторяющимися проверками ошибок на каждом уровне. Это было трудно читать, отлаживать и поддерживать.
Критический взгляд: Избегайте написания нового кода с использованием error-first колбэков. Понимать их нужно для работы с устаревшими модулями или старым кодом. Если вы сталкиваетесь с таким API, лучшая стратегия — обернуть его в Промис.
2. Промисы (Promise) – Фундамент Современной Асинхронности

Концепция: Объект, представляющий обещание предоставить результат асинхронной операции в будущем. Управляет состояниями pending, fulfilled, rejected.
Преимущества перед Колбэками:
Линейные цепочки (.then()): Позволяют выстраивать последовательные асинхронные шаги без глубокой вложенности.
Централизованная обработка ошибок (.catch()): Одна ошибка в цепочке может быть поймана одним .catch() в конце.
Композиция (Promise.all, Promise.race и др.): Легко комбинировать несколько асинхронных операций.
Оборачивание Колбэков в Промисы:
JavaScript

function readFilePromise(path, encoding) {
  return new Promise((resolve, reject) => {
    fs.readFile(path, encoding, (err, data) => {
      if (err) {
        reject(err); // Отклоняем промис при ошибке
      } else {
        resolve(data); // Резолвим промис с данными при успехе
      }
    });
  });
}

readFilePromise('file.txt', 'utf8')
  .then(data => console.log("Прочитано (Promise):", data.length))
  .catch(err => console.error("Ошибка (Promise):", err));
(Примечание: Для fs уже есть готовый require('fs/promises'), это просто пример обертки).
Комбинаторы Промисов:
Promise.all([p1, p2, ...]): Ждет выполнения всех промисов. Если хотя бы один отклонен (rejected), Promise.all немедленно отклоняется с ошибкой первого отклоненного. Возвращает массив результатов в том же порядке. Использование: Когда нужно выполнить несколько независимых операций параллельно и дождаться их всех.
Promise.allSettled([p1, p2, ...]): Ждет, пока все промисы завершатся (успешно или с ошибкой). Никогда не отклоняется сам. Возвращает массив объектов с результатами: {status: 'fulfilled', value: ...} или {status: 'rejected', reason: ...}. Использование: Когда нужно дождаться всех операций, даже если некоторые неудачны, и проанализировать результат каждой.
Promise.race([p1, p2, ...]): Завершается (fulfilled или rejected), как только первый из промисов p1, p2... завершается. Использование: Гонка на время, выбор самого быстрого результата.
Promise.any([p1, p2, ...]): Завершается успешно (fulfilled), как только первый из промисов p1, p2... завершается успешно. Отклоняется (rejected), только если все промисы были отклонены (с AggregateError). Использование: Получить первый успешный результат из нескольких попыток.
Критический взгляд: Промисы — это основа. Даже если вы пишете на async/await, вы все равно работаете с промисами "под капотом". Понимание их работы, цепочек и комбинаторов абсолютно необходимо.
3. async/await – Современный Стандарт и Лучшая Читаемость

Синтаксический Сахар: async/await — это более удобный синтаксис для работы с промисами.
async function: Всегда возвращает промис.
await: Приостанавливает выполнение только async функции, в которой он находится, дожидается разрешения промиса справа от него. Если промис успешен (fulfilled), await возвращает его значение. Если промис отклонен (rejected), await выбрасывает (throws) ошибку отклонения.
Обработка Ошибок: try...catch: Естественный способ обработки ошибок от await.
Пример (последовательное чтение и обработка):
JavaScript

const fsPromises = require('fs/promises');
const path = require('path');

async function processUserData(userId) {
  const userFilePath = path.join(__dirname, 'users', `${userId}.json`);
  const ordersFilePath = path.join(__dirname, 'orders', `${userId}.json`);

  try {
    console.log(`Читаем данные пользователя ${userId}...`);
    const userDataJson = await fsPromises.readFile(userFilePath, 'utf8');
    const userData = JSON.parse(userDataJson);
    console.log(`Пользователь ${userData.name} найден.`);

    console.log(`Читаем заказы пользователя ${userId}...`);
    const ordersDataJson = await fsPromises.readFile(ordersFilePath, 'utf8');
    const ordersData = JSON.parse(ordersDataJson);
    console.log(`Найдено ${ordersData.length} заказов.`);

    // Какая-то обработка...
    return { ...userData, orders: ordersData };

  } catch (err) {
    console.error(`Ошибка обработки данных для пользователя ${userId}:`, err.code === 'ENOENT' ? 'Файл не найден' : err.message);
    // Можно пробросить ошибку дальше или вернуть null/дефолтное значение
    return null;
  } finally {
    console.log(`Обработка для ${userId} завершена.`);
  }
}

// processUserData('user1').then(result => { if (result) console.log("Итог:", result.name, result.orders.length); });
Параллельное Выполнение с await Promise.all():
TypeScript

async function getParallelData() {
  try {
    const [userData, productData] = await Promise.all([
       fsPromises.readFile('user.txt', 'utf8'),
       fsPromises.readFile('products.txt', 'utf8')
    ]);
    console.log("Оба файла прочитаны параллельно.");
    // ... обработка userData и productData ...
  } catch (err) {
    console.error("Ошибка при параллельном чтении:", err);
  }
}
Критический взгляд: async/await делает асинхронный код максимально похожим на синхронный, что значительно улучшает читаемость и поддерживаемость. Это стандарт де-факто для современного асинхронного JS/Node.js. Однако, важно не забывать, что под капотом это промисы, и обязательно использовать try...catch для обработки потенциальных ошибок от await. Также нужно помнить о Promise.all для выполнения независимых операций параллельно, а не последовательно через несколько await.
Итог по Теме #9:

Современная разработка на Node.js немыслима без грамотной работы с асинхронностью. Промисы предоставляют надежную основу, а синтаксис async/await делает код читаемым и понятным. Ключевые навыки: умение работать с промисами (включая комбинаторы Promise.all и др.) и async/await, а также надежная обработка ошибок с помощью .catch() или try...catch. Избегайте колбэк-паттернов в новом коде.
