Тема #17: Конфигурация tsconfig.json (Compiler Options)

Файл tsconfig.json — это пульт управления компилятором TypeScript (tsc) и всей связанной с ним экосистемой (IDE, сборщики). Наличие этого файла в корне проекта сигнализирует, что это корень TypeScript-проекта.

1. Назначение tsconfig.json

Определяет, какие файлы (.ts, .tsx, а также .js при allowJs) входят в ваш проект (include, exclude, files).
Задает опции компилятора (compilerOptions), которые диктуют:
Во что компилировать TypeScript (версия JavaScript, модульная система).
Насколько строго проверять типы.
Где искать модули.
Куда помещать скомпилированные файлы.
Нужно ли генерировать Source Maps для отладки, и т.д.
2. Ключевые Опции Компилятора (compilerOptions) с Критическим Взглядом

Рассмотрим наиболее важные опции и их неочевидные аспекты:

target: (Например, "ES5", "ES2016", "ES2022", "ESNext")

Что делает: Указывает версию ECMAScript, в которую будет скомпилирован ваш TS код.
Нюансы: tsc будет транспилировать синтаксис новых версий JS (стрелочные функции, классы, async/await, ?., ??) в код, совместимый с указанной target. Выбор target влияет на то, какие встроенные типы (lib) подключаются по умолчанию и на производительность/совместимость итогового JS.
Критический взгляд: Выбирайте минимально возможную версию, которую поддерживают все ваши целевые среды (браузеры, версии Node.js). Слишком низкий target может привести к менее эффективному коду после транспиляции, слишком высокий — к неработоспособности в старых средах. "ES2016" или "ES2017" — частый безопасный выбор для широкой совместимости.
module: (Например, "CommonJS", "ES2015", "ES2020", "ESNext", "NodeNext", "None")

Что делает: Определяет, какую модульную систему использовать в скомпилированном JS коде.
Нюансы: Критически важно для совместимости! Если пишете под Node.js, вам может понадобиться "CommonJS" или "NodeNext" (для современной поддержки и CJS, и ESM). Если пишете для браузеров с <script type="module"> или используете сборщик (Webpack, Vite), часто выбирают "ES2015" или "ESNext". "None" используется редко.
Критический взгляд: Выбор module должен соответствовать вашей среде выполнения или конфигурации сборщика. Неправильный выбор приведет к ошибкам загрузки модулей.
outDir и rootDir:

outDir: Куда складывать скомпилированные .js, .d.ts, .js.map файлы. Маст-хэв для любого проекта, чтобы не смешивать исходники и сборку.
rootDir: Указывает корневую папку с исходниками (.ts). Помогает tsc сохранить структуру папок из rootDir внутри outDir.
outFile: (Устаревшая опция) Склеивает все немодульные файлы в один .js. Не используйте в современных проектах с модулями! Для сборки используйте Webpack, Rollup, Vite, esbuild.
Флаги Строгости (strict, noImplicitAny, strictNullChecks и др.):

strict: true: Настоятельно рекомендуется для всех новых проектов. Включает целый набор флагов для максимальной безопасности типов (см. Тему #14).
noImplicitAny: true: Запрещает неявный any. Абсолютный минимум.
strictNullChecks: true: Заставляет явно обрабатывать null и undefined. Резко повышает надежность.
Критический взгляд: Не бойтесь "строгости". Она требует чуть больше усилий при написании кода, но экономит массу времени на отладке рантайм-ошибок. Начинайте со strict: true и отключайте отдельные флаги только при крайней необходимости и с четким пониманием последствий.
Взаимодействие с JS (allowJs, checkJs, esModuleInterop):

allowJs: true: Позволяет включать .js файлы в компиляцию TS проекта (например, для постепенной миграции).
checkJs: true: Включает проверку типов (на основе JSDoc или вывода) в .js файлах (работает вместе с allowJs).
esModuleInterop: true: Очень важный флаг! Решает проблемы совместимости при импорте CommonJS модулей (особенно с default экспортом) в ES модули. Позволяет писать import React from 'react' вместо import * as React from 'react'. Почти всегда ставьте true, если не уверены в обратном.
Библиотеки (lib): (Например, ["ES2020", "DOM", "DOM.Iterable"])

Что делает: Указывает, какие встроенные API JavaScript и среды выполнения (DOM) должны быть известны компилятору (для них подключаются соответствующие файлы деклараций .d.ts).
Нюансы: Обычно TS сам подбирает lib на основе target. Но иногда нужно явно добавить (например, "DOM" для Node.js проекта, который работает с JSDOM, или фичи новой версии ES, если target старый).
Критический взгляд: Не добавляйте лишние lib. Если вы указали "ES2020", но ваш target — "ES5", вы должны сами обеспечить наличие полифиллов для фич ES2020 в рантайме. lib говорит TS только о доступности типов, а не о реальной реализации фич.
Разрешение Модулей (moduleResolution): (Обычно "Node", "Node16", "NodeNext", "Bundler")

Что делает: Определяет стратегию поиска модулей при import/require.
Нюансы: Обычно выставляется автоматически на основе module. "NodeNext" или "Bundler" важны для корректной работы с разными форматами модулей в Node.js или при использовании современных сборщиков.
Карты Кода (sourceMap):

sourceMap: true: Генерирует .map файлы, связывающие скомпилированный JS с исходным TS. Необходимо для комфортной отладки TS кода в браузере или Node.js.
Алиасы Путей (baseUrl, paths):

Что делают: Позволяют настроить короткие псевдонимы для путей к модулям (например, @app/* -> src/app/*), чтобы избежать длинных относительных импортов ../../../.
Критический взгляд: Очень удобно для больших проектов, НО tsc сам по себе не изменяет эти пути в итоговом JS. Вам нужно настроить ваш загрузчик модулей или сборщик (Webpack alias, Vite alias, tsconfig-paths для Node) так, чтобы он понимал эти алиасы во время выполнения.
extends: Позволяет наследовать конфигурацию из другого tsconfig.json файла. Удобно для монорепозиториев или базовых конфигураций.

Итог по Теме #17:

tsconfig.json — это нервный центр вашего TypeScript проекта. Грамотная настройка компилятора критически важна. Ключевые моменты: выбор правильного target и module для вашей среды, обязательное включение строгих проверок (strict: true) для надежности, настройка esModuleInterop: true для совместимости, генерация sourceMap для отладки и правильная конфигурация outDir/rootDir. Понимание этих опций позволяет вам контролировать процесс компиляции и получать максимум пользы от TypeScript.
