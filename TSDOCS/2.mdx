Тема #2: any vs unknown – Отключение или Безопасность?

Оба этих типа в TypeScript служат для представления значения, чей тип нам не известен на момент написания кода. Однако они делают это фундаментально по-разному с точки зрения безопасности типов. Это одна из самых важных концепций для понимания философии TS.

1. any – "Дикий Запад" и Отключение Проверок

Что это? any — это специальный тип, который, по сути, говорит компилятору TypeScript: "Я знаю, что делаю, не проверяй тип этого значения вообще". Это полноценный выход (escape hatch) из системы типов.
Как работает:
Переменной типа any можно присвоить абсолютно любое значение.
Значение типа any можно присвоить переменной почти любого другого типа (без ошибок компиляции!).
У значения типа any можно вызвать любой метод или получить доступ к любому свойству (даже несуществующему) — компилятор промолчит.
Пример:
TypeScript

let dangerZone: any;

dangerZone = 10;
dangerZone = "I am a string now";
dangerZone = { complex: { nested: true } };

// Никаких ошибок компиляции!
let myNumber: number = dangerZone; // Опасно! Что если dangerZone не число?
let upper: string = dangerZone.toUpperCase(); // Опасно! Что если не строка?
dangerZone.someMethodThatDoesNotExist(); // Опасно!
dangerZone.prop1.prop2.prop3 = 123; // Опасно!

// Ошибки проявятся только ВО ВРЕМЯ ВЫПОЛНЕНИЯ (runtime), если тип не совпадет.
"Заразность" any (Вирусный эффект): Если функция принимает any, возвращает any, или если any "протекает" в другие переменные, то эффект отключения проверок распространяется по коду. Типизация в связанных участках кода становится бессмысленной.
Критический взгляд: Использование any сводит на нет основное преимущество TypeScript — статическую проверку типов. Его следует рассматривать как крайнюю меру:
При миграции большого JS-проекта на TS (как временный шаг).
При работе с очень старыми или плохо типизированными JS-библиотеками, где нет .d.ts файлов (хотя и тут unknown часто лучше).
Когда структура данных действительно неизвестна и крайне динамична (но даже здесь unknown или дженерики могут быть безопаснее). Избыточное использование any — признак того, что TS используется неэффективно.
2. unknown – Безопасная Альтернатива (Type-Safe any)

Что это? Введенный в TS 3.0, unknown также представляет значение любого типа, но делает это безопасно. Он говорит: "Я не знаю, что здесь за тип, и ты не можешь ничего с этим сделать, пока не проверишь".
Как работает:
Переменной типа unknown можно присвоить абсолютно любое значение (как и any).
Значение типа unknown НЕЛЬЗЯ присвоить переменной любого другого типа (кроме any и unknown) без явного сужения типа (narrowing) или утверждения типа (assertion).
У значения типа unknown НЕЛЬЗЯ вызывать методы или получать доступ к свойствам напрямую.
Пример:
TypeScript

let safeZone: unknown;

safeZone = 10;
safeZone = "Now I am a string";
safeZone = { complex: { nested: true } };

// ОШИБКИ КОМПИЛЯЦИИ! TypeScript защищает нас.
// let myNumber2: number = safeZone; // Error: Type 'unknown' is not assignable to type 'number'.
// safeZone.toUpperCase(); // Error: Object is of type 'unknown'.
// safeZone.someMethodThatDoesNotExist(); // Error: Object is of type 'unknown'.
// safeZone.prop1.prop2.prop3 = 123; // Error: Object is of type 'unknown'.

// Что делать? ПРОВЕРЯТЬ ТИП (Type Narrowing)
if (typeof safeZone === 'string') {
  // Внутри этого блока TS УВЕРЕН, что safeZone - это строка
  console.log(safeZone.toUpperCase()); // OK!
} else if (typeof safeZone === 'number') {
  console.log(safeZone.toFixed(2)); // OK!
} else if (safeZone instanceof Error) {
  console.error(safeZone.message); // OK!
}
// ... или использовать пользовательские type guards, или валидацию схемы (Zod и т.п.)

// Можно использовать утверждение типа (менее безопасно!)
// const assumedString = safeZone as string; // Говорим TS: "Я уверен, что это строка"
// console.log(assumedString.toUpperCase()); // Ошибки компиляции нет, но будет ошибка в рантайме, если мы ошиблись!
Критический взгляд: unknown — это правильный способ обработки значений, тип которых неизвестен на этапе компиляции (данные из API, JSON.parse, localStorage, параметры обработчиков событий). Он заставляет разработчика явно проверять тип перед использованием значения, делая код намного безопаснее и документируя места, где требуется проверка. Он реализует принцип "доверяй, но проверяй" на уровне типов.
3. Сравнение и Когда Что Использовать

Фича	any	unknown
Присвоить ЛЮБОЕ значение?	✅ Да	✅ Да
Присвоить ДРУГОМУ типу?	✅ Да (небезопасно!)	❌ Нет (нужна проверка/утверждение)
Доступ к свойствам/методам?	✅ Да (небезопасно!)	❌ Нет (нужна проверка/утверждение)
Безопас