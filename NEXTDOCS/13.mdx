# Тема 13: Шрифты в Next.js: Магия next/font против Классики @font-face

## Введение: Дорогая Цена Красоты

Веб-шрифты (кастомные шрифты, не установленные по умолчанию в системе пользователя) — неотъемлемая часть современного веб-дизайна. Они задают тон, улучшают читаемость и придают сайту индивидуальность. Но за эту красоту часто приходится платить производительностью:

- **Задержки Загрузки**: Загрузка файлов шрифтов (особенно с внешних сервисов вроде Google Fonts) требует дополнительных сетевых запросов.
- **Блокировка Рендеринга**: Браузеры часто ждут загрузки шрифтов перед отображением текста.
- **"Мелькание" Текста**: FOUT (Flash of Unstyled Text) или FOIT (Flash of Invisible Text) — неприятные эффекты, когда текст сначала отображается системным шрифтом или не отображается вовсе.
- **Скачки Макета (CLS)**: Самая болезненная проблема. Когда кастомный шрифт загружается, он может иметь другие размеры и метрики, чем запасной (fallback) шрифт, который отображался до этого. Это приводит к "прыжку" текста и смещению других элементов на странице (Cumulative Layout Shift), что негативно сказывается на пользовательском опыте и метриках Core Web Vitals.

Next.js предлагает встроенное решение для борьбы с этими проблемами — модуль и компонент `next/font`. Действительно ли он решает все проблемы "магически", или есть нюансы?

## next/font – Встроенная Оптимизация

Модуль `next/font` (включающий `next/font/google` и `next/font/local`) был разработан для автоматизации лучших практик загрузки шрифтов.

### Основные Возможности:

- **Автоматический Самохостинг (Self-Hosting)**: При использовании `next/font/google`, Next.js во время сборки (`next build`) скачивает указанные Google шрифты и размещает их вместе с остальными статическими ассетами вашего приложения. Это устраняет необходимость обращаться к серверам Google (fonts.gstatic.com) во время загрузки страницы пользователем, убирая лишний сетевой запрос и зависимость от внешнего сервиса.

- **Предзагрузка (Preloading)**: Автоматически добавляет соответствующие теги `<link rel="preload">` в `<head>` документа, чтобы браузер начал загрузку файлов шрифтов как можно раньше.

- **Минимизация CLS через size-adjust**: Это ключевая оптимизация. `next/font` анализирует метрики загружаемого шрифта во время сборки и генерирует `@font-face` правила с использованием CSS-свойства `size-adjust` (и других дескрипторов). Это свойство позволяет "подогнать" метрики запасного системного шрифта так, чтобы он занимал примерно то же пространство, что и основной веб-шрифт после его загрузки. В результате, когда основной шрифт загружается и применяется, скачок макета (CLS) минимален или отсутствует.

- **Улучшение FOUT/FOIT**: Благодаря самохостингу, предзагрузке и минимизации CLS, неприятные эффекты "мелькания" текста значительно сокращаются.

- **Приватность**: Отсутствие запросов к Google Fonts со стороны браузера пользователя.

### Как Использовать (Примеры):

```javascript
// Для Google Fonts
import { Roboto } from 'next/font/google';
const roboto = Roboto({
  weight: ['400', '700'],
  subsets: ['latin', 'cyrillic'],
  display: 'swap', // Важная опция для стратегии отображения
});

// Для Локальных Шрифтов
import localFont from 'next/font/local';
const myLocalFont = localFont({
  src: [
    { path: '../fonts/MyFont-Regular.woff2', weight: '400', style: 'normal' },
    { path: '../fonts/MyFont-Bold.woff2', weight: '700', style: 'normal' },
  ],
  display: 'swap',
});

// В компоненте:
<body className={roboto.className}> {/* Глобально */}
  <h1 style={myLocalFont.style}> {/* Локально через стиль */}
    Hello World
  </h1>
</body>
```

## Критический Взгляд: Плюсы и Нюансы

### Плюсы:

- **Реальное Улучшение Производительности**: Устранение внешних запросов к Google, предзагрузка и, главное, эффективное решение проблемы CLS от шрифтов — это огромные плюсы для Web Vitals и UX.
- **Простота** (особенно для Google Fonts): Подключить Google шрифт стало очень легко и оптимизировано по умолчанию.
- **Приватность**: Важный аспект для некоторых приложений.

### Нюансы и Возможные Минусы:

- **Время Сборки**: Скачивание и обработка шрифтов на этапе `next build` увеличивает время сборки, особенно если используется много шрифтов или начертаний.
- **Размер Деплоя**: Файлы шрифтов (.woff2) теперь становятся частью вашего статического билда, увеличивая его размер. Однако это обычно лучше, чем внешний запрос во время загрузки страницы.
- **Конфигурация Локальных Шрифтов**: Требует правильного размещения файлов шрифтов в проекте и описания их характеристик (weight, style) в конфигурации `localFont`.
- **Ограниченная Кастомизация @font-face**: `next/font` генерирует правила `@font-face` автоматически. Если вам нужны очень специфичные или нестандартные дескрипторы `@font-face` (например, редкие font-feature-settings), применить их может быть сложнее.
- **Работа size-adjust**: Хотя этот механизм очень эффективен против CLS, он слегка изменяет вид запасного шрифта до загрузки основного. Это почти всегда незаметно, но теоретически возможно.

## Сравнение с Традиционным Подходом (@font-face / \<link\>)

### next/font:
- **Плюсы**: Автоматизация оптимизаций (self-hosting, preload, CLS fix), простота для Google Fonts.
- **Минусы**: Увеличение времени сборки/размера деплоя, меньше контроля над @font-face.

### Традиционный (@font-face в CSS, \<link\> для Google Fonts):
- **Плюсы**: Полный контроль над @font-face, не влияет на время сборки (если шрифты внешние).
- **Минусы**: Требует ручной оптимизации CLS (сложно), ручной настройки preload, создает внешние зависимости (Google Fonts), может блокировать рендеринг, FOUT/FOIT более вероятны.

## Итог

Модуль `next/font` — это однозначно рекомендуемый и лучший способ работы со шрифтами в современных приложениях на Next.js. Он элегантно решает ключевые проблемы производительности (CLS, FOUT/FOIT, внешние запросы), связанные с веб-шрифтами, автоматизируя лучшие практики, такие как самохостинг и использование size-adjust.

Хотя он добавляет некоторую нагрузку на этап сборки и требует понимания его работы, выигрыш в производительности и пользовательском опыте для конечного пользователя обычно значительно перевешивает эти нюансы. Использовать старые подходы в Next.js теперь имеет смысл только в очень специфических случаях.
