# Тема 5: Бэкенд в Next.js: API Routes против Server Actions – Когда Что Выбирать?

## Введение: Два Пути к Серверной Логике

Next.js позиционируется как full-stack фреймворк, и ему нужны способы выполнять код на сервере по запросу клиента — не только для рендеринга страниц, но и для обработки отправки форм, изменения данных, взаимодействия с внешними сервисами и т.д. Исторически для этого использовались **API Routes**. С появлением App Router был представлен новый механизм — **Server Actions**.

Являются ли Server Actions просто "новым способом" делать то же самое, что и API Routes? Заменяют ли они их? Или у них разные цели и сценарии использования? Давайте разберемся в их философии, механизмах и компромиссах.

## API Routes (Маршруты API)

### Механизм:
Позволяют создавать традиционные HTTP API эндпоинты внутри вашего Next.js приложения. Клиент отправляет стандартный HTTP-запрос (GET, POST, PUT, DELETE...) на определенный URL, а сервер выполняет соответствующий код и возвращает HTTP-ответ (часто JSON).

### Реализация:
- **Pages Router**: Файлы внутри директории `pages/api/`. Экспортируют одну функцию-обработчик `handler(req, res)`, напоминающую обработчики в Express/Node.js.
- **App Router**: Файлы с именем `route.js` (или `.ts`) внутри папок в `app/`. Экспортируют асинхронные функции по имени HTTP-метода (`export async function GET(request) {...}`, `export async function POST(request) {...}`). Используют стандартные Web API объекты Request и Response.

### Философия:
Реализация стандартного, универсального RESTful (или REST-подобного) API.

### Плюсы:
- **Универсальность и Стандарт**: Понятный и привычный паттерн HTTP API. Может использоваться любым клиентом (веб-фронтенд, мобильное приложение, другой бэкенд-сервис, cURL).
- **Четкое Разделение**: Явно отделяет логику API от UI-компонентов.
- **Полный Контроль над HTTP**: Позволяет тонко настраивать заголовки, статус-коды, методы, работать со стримингом ответа.

### Минусы:
- **Дополнительный Код**: Требует написания как серверного обработчика, так и клиентского кода для выполнения fetch-запроса к этому эндпоинту.
- **Больше Шаблона (Boilerplate)**: Для простых мутаций создание отдельного файла и обработчика может показаться избыточным.

## Server Actions

### Механизм:
Это асинхронные функции, помеченные директивой `"use server";` (либо в начале файла модуля, где они определены, либо прямо перед самой функцией). Их можно вызывать напрямую из Server или Client Components (например, при отправке формы или по клику кнопки).

### Принцип Работы:
Когда Server Action вызывается с клиента, Next.js автоматически создает специальный RPC-подобный (Remote Procedure Call) запрос к серверу для выполнения этой функции. Вам не нужно вручную создавать API эндпоинт или писать fetch на клиенте. Next.js берет на себя передачу аргументов (сериализуемых) и возврат результата (тоже сериализуемого) или ошибки.

### Реализация:

```typescript
// app/actions.ts
'use server'; // Директива на уровне модуля

export async function createUser(formData: FormData) {
  const name = formData.get('name');
  // ... логика создания пользователя в БД ...
  // revalidatePath('/users'); // Опционально: инвалидировать кэш
  return { success: true, userName: name };
}

// app/some-component.tsx (Client Component)
"use client";
import { createUser } from './actions';
import { useFormState, useFormStatus } from 'react-dom';

function MyForm() {
  const [state, formAction] = useFormState(createUser, null); // Hook для управления состоянием формы
  const { pending } = useFormStatus(); // Hook для отслеживания статуса

  return (
    <form action={formAction}>
      <input type="text" name="name" required />
      <button type="submit" disabled={pending}>
        {pending ? 'Creating...' : 'Create User'}
      </button>
      {state?.success && <p>{state.userName} created!</p>}
      {/* Можно также обрабатывать ошибки из state */}
    </form>
  );
}
```

### Философия:
Предоставить упрощенный способ выполнения серверных мутаций напрямую из React-компонентов, тесно интегрированный с формами и механизмом обновления данных React/Next.js.

### Плюсы:
- **Уменьшение Кода**: Значительно сокращает шаблонный код для связки UI-действий с серверной логикой (не нужен API route, не нужен fetch на клиенте).
- **Интеграция с Формами**: Отлично работает с HTML-формами (`<form action={...}>`) и хуками useFormState/useFormStatus.
- **Progressive Enhancement**: Формы могут работать даже без JS на клиенте (хотя без интерактивных состояний).
- **Инвалидация Кэша**: Легко интегрируется с revalidatePath/revalidateTag для обновления данных после мутации.

### Минусы:
- **Не REST API**: Это не стандартный HTTP API. Предназначен в первую очередь для вызова из вашего же Next.js фронтенда. Сделать его публичным API для сторонних клиентов сложнее и менее естественно.
- **Новизна**: Как относительно новая фича, лучшие практики еще формируются, могут быть неочевидные моменты.
- **Меньше Контроля над HTTP**: Абстрагирует детали HTTP. Если нужен тонкий контроль над запросом/ответом, API Routes гибче.
- **Безопасность**: Как и любой серверный код, требует тщательной валидации входных данных и проверки прав доступа.

## Критическое Сравнение: Замена или Дополнение?

Server Actions не заменяют API Routes полностью. Это два инструмента с разными целями:

### Server Actions Идеальны Для:
- Обработки отправки форм.
- Выполнения мутаций данных (Create, Update, Delete), инициированных действиями пользователя в UI.
- Сценариев, где нужен тесный цикл "UI -> Server Logic -> UI Update" с минимальным кодом.

### API Routes Остаются Лучшим Выбором Для:
- Создания стандартных RESTful/HTTP API для использования сторонними клиентами (мобильные приложения, другие сервисы, публичные API).
- Сценариев, где требуется полный контроль над HTTP запросом/ответом (специфические заголовки, статус-коды, методы).
- Реализации веб-хуков или интеграций, требующих стандартного HTTP интерфейса.
- Получения данных (хотя в App Router это часто делается напрямую в Server Components).

В сложном приложении, скорее всего, будут использоваться оба подхода для разных задач.

## Итог

API Routes и Server Actions предоставляют разные способы выполнения бэкенд-логики в Next.js. API Routes следуют классической модели HTTP API, обеспечивая универсальность и контроль. Server Actions предлагают упрощенную RPC-подобную модель, тесно интегрированную с React-компонентами и идеальную для обработки мутаций данных из UI.

Понимание их различий, сильных и слабых сторон необходимо для выбора правильного инструмента для конкретной задачи в вашем Next.js приложении.
