# Тема 2: SSR vs SSG в Next.js: Битва за Скорость и Свежесть

## Введение: Как и Когда Рендерить HTML?

Next.js предоставляет разработчику мощные инструменты для рендеринга React-компонентов на сервере, что критично для SEO и начальной производительности (First Contentful Paint, FCP). Два фундаментальных подхода — это **Server-Side Rendering (SSR)** и **Static Site Generation (SSG)**. Оба генерируют HTML на сервере, но делают это в совершенно разное время и с совершенно разными последствиями для производительности, актуальности данных и нагрузки на инфраструктуру.

Заявления вроде "SSG всегда быстрее" или "SSR нужен для всего динамического" часто являются упрощениями. Давайте критически разберем обе стратегии, их компромиссы и как выбор между ними влияет на ваше приложение Next.js.

## Server-Side Rendering (SSR): Динамика по Запросу

### Механизм:
HTML для страницы генерируется на сервере динамически, для каждого входящего запроса пользователя. Когда пользователь запрашивает страницу, сервер Next.js выполняет необходимый код (включая получение данных), рендерит React-компоненты в HTML-строку и отправляет готовый HTML клиенту.

### Реализация:
- **Pages Router:** Через экспорт асинхронной функции `getServerSideProps` из файла страницы. Эта функция выполняется на сервере при каждом запросе перед рендерингом страницы.
- **App Router (Концептуально):** Компоненты (особенно Server Components) рендерятся динамически по умолчанию, если они используют динамические данные (например, fetch с опцией `{ cache: 'no-store' }` или `revalidate: 0`), динамические функции (`headers()`, `cookies()`) или динамические сегменты роута без статической генерации.

### Плюсы:
- **Актуальность Данных:** HTML всегда содержит самые свежие данные, доступные на момент запроса. Идеально для персонализированного контента (личные кабинеты), дашбордов, страниц с часто обновляемой информацией (биржевые сводки).
- **Хорошо для SEO:** Поисковые роботы получают полностью отрендеренный, актуальный HTML.

### Минусы:
- **Нагрузка на Сервер:** Каждый запрос требует вычислений на сервере (получение данных, рендеринг). Это может создавать значительную нагрузку при большом трафике.
- **Time To First Byte (TTFB):** Время до получения первого байта HTML может быть выше, чем у SSG, так как сервер тратит время на генерацию страницы.
- **Сложность Кэширования:** Готовый HTML сложно эффективно кэшировать на CDN, так как он может быть уникальным для каждого запроса или часто меняться.

## Static Site Generation (SSG): Сборка Заранее

### Механизм:
HTML для страниц генерируется заранее, один раз во время сборки (build time) приложения (`next build`). Для каждой страницы (или каждого набора параметров динамического роута) создается отдельный статический `.html` файл. Эти файлы затем можно разместить на любом статическом хостинге или CDN.

### Реализация:
- **Pages Router:** Через экспорт асинхронной функции `getStaticProps`. Она выполняется во время сборки. Для динамических роутов (`pages/posts/[slug].js`) требовалась также `getStaticPaths` для указания, какие именно страницы нужно сгенерировать.
- **App Router (Концептуально):** Компоненты рендерятся статически по умолчанию, если они НЕ используют динамические функции или динамический data fetching. Next.js автоматически определяет статичные пути и генерирует для них статический HTML и RSC Payload во время сборки.

### Плюсы:
- **Максимальная Скорость:** Статические файлы мгновенно отдаются с CDN по всему миру. Очень низкий TTFB, отличная производительность.
- **Надежность и Масштабируемость:** Не требуется активный Node.js сервер для отдачи страниц. Статику легко масштабировать и она очень надежна. Минимальная нагрузка на сервер (только во время билда).
- **Превосходно для SEO:** Поисковики получают контент мгновенно.

### Минусы:
- **Устаревание Данных:** Контент страницы "заморожен" на момент сборки. Любое обновление данных требует полной пересборки и деплоя всего сайта (если не используется ISR). Абсолютно не подходит для динамического или персонализированного контента.
- **Время Сборки:** Для сайтов с тысячами или миллионами страниц (`getStaticPaths` может вернуть много путей) время сборки может стать очень большим, замедляя деплой.

## Критический Взгляд: Компромиссы и Современные Реалии

Выбор между SSR и SSG — это фундаментальный архитектурный компромисс:

- **SSR:** Свежесть данных ↔ Нагрузка на сервер / TTFB
- **SSG:** Скорость / Масштабируемость ↔ Устаревание данных / Время сборки

К счастью, Next.js предлагает не только эти два полюса:

### Смешанный Подход
Вы можете использовать разные стратегии для разных страниц вашего приложения.

### Incremental Static Regeneration (ISR)
Гибрид SSG и SSR. Страница генерируется статически, но может периодически (например, каждые 60 секунд - `revalidate: 60`) или по запросу (On-demand ISR - `revalidatePath`/`revalidateTag`) пересобираться в фоне на сервере. Это позволяет обновлять статический контент без полного деплоя, предлагая хороший баланс между скоростью и свежестью для многих сайтов (новости, блоги, каталоги).

### App Router и Гранулярность
Новый App Router делает выбор еще более гибким. Теперь статичность или динамичность определяется на уровне компонентов и запросов данных. Часть страницы (например, шапка) может быть статической, а другая часть (лента новостей) — динамической. Next.js пытается автоматически определять оптимальную стратегию рендеринга для каждого сегмента пути. Это мощно, но требует глубокого понимания правил кэширования и того, что именно делает компонент динамическим.

## Когда Что Выбирать (Упрощенные Рекомендации)

### SSG:
Идеально для сайтов, где контент меняется редко или не требует мгновенной актуальности:
- Лендинги
- Документация
- Блоги (с ISR для обновлений)
- Портфолио
- Сайты-визитки

Старайтесь использовать SSG/ISR везде, где это возможно, для лучшей производительности.

### SSR:
Необходимо для страниц, где контент персонализирован для каждого пользователя или должен быть абсолютно актуальным в момент запроса:
- Личные кабинеты
- Панели управления
- Корзины интернет-магазинов
- Страницы с результатами поиска в реальном времени

## Итог

SSR и SSG — это две основные стратегии пререндеринга в Next.js, каждая со своими сильными и слабыми сторонами. Выбор между ними (или их гибридом ISR) должен основываться на требованиях к актуальности данных и характере контента конкретной страницы или всего приложения.

SSG обеспечивает наилучшую производительность и масштабируемость, но ценой потенциального устаревания данных. SSR гарантирует свежесть данных, но требует больших серверных ресурсов и может иметь больший TTFB.

Современный Next.js (особенно с App Router) предлагает более гранулярные и автоматизированные подходы, но понимание фундаментальных различий между SSR и SSG остается абсолютно необходимым для принятия грамотных архитектурных решений.
