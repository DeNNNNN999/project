# Тема 16: Обработка ошибок в Next.js App Router: Многоуровневый подход

## Введение: Ошибки Неизбежны

Любое нетривиальное приложение сталкивается с ошибками: проблемы с сетью, недоступность базы данных, ошибки валидации, баги в коде рендеринга, несуществующие ресурсы. В Next.js App Router, где код выполняется в разных средах (сервер, клиент, edge) и используются разные типы компонентов (Server Components, Client Components), обработка ошибок становится многоуровневой задачей.

Как грациозно перехватывать ошибки на разных этапах? Как показать пользователю осмысленное сообщение вместо "белого экрана" или стандартной ошибки сервера? Как различать "ресурс не найден" и "неожиданная проблема"? Next.js предлагает набор конвенций и использует механизмы React для решения этих задач.

## Ошибки в Server Components

### Где Возникают:
При получении данных (fetch, доступ к БД в async компоненте), во время рендеринга самого компонента (например, доступ к свойству undefined), при вызове Server Actions.

### Механизм Обработки (Конвенция Next.js): error.js

**Что это**: Специальный файл `error.js` (или `.tsx`) внутри папки сегмента роута (`app/dashboard/error.js`).

**Требование**: Этот файл обязательно должен экспортировать React-компонент, помеченный как `"use client";`. Error Boundaries в React по своей природе должны быть клиентскими компонентами.

**Как Работает**: Если во время рендеринга дочерних компонентов этого сегмента (включая `page.js` или вложенные `layout.js`/`template.js`) происходит неперехваченная ошибка (на сервере или на клиенте во время гидратации/рендеринга), Next.js останавливает рендеринг сбойного поддерева и рендерит вместо него UI из ближайшего `error.js`, расположенного выше по дереву каталогов.

**Изоляция**: Важно! `error.js` не ловит ошибки, произошедшие в `layout.js`, находящемся в той же папке. Это сделано для того, чтобы критические части UI (например, главная навигация в корневом layout) не пропадали из-за ошибки на конкретной странице. Ошибки в layout ловятся `error.js` на уровень выше.

**Props**: Компонент `error.js` получает два пропа:
- `error`: Объект ошибки (может содержать `digest` для серверных ошибок).
- `reset`: Функция, при вызове которой Next.js попытается перерендерить сбойный сегмент дерева компонентов. Полезна для ошибок, которые могут быть временными (например, сетевой сбой).

**Критический Взгляд**: `error.js` — это мощная конвенция на основе React Error Boundaries, позволяющая гранулярно обрабатывать ошибки рендеринга и показывать пользователю адекватный запасной UI с возможностью повторной попытки. Главные ограничения — он должен быть клиентским и не ловит ошибки в layout'е того же уровня.

## Обработка "Не Найдено" (404): notFound()

### Механизм:
Если внутри Server Component (или Server Action, API Route) вы понимаете, что запрошенный ресурс не существует (например, fetch вернул 404 или БД не нашла запись), вы можете вызвать функцию `notFound()` из `next/navigation`.

### Поведение:
Вызов `notFound()` немедленно прерывает рендеринг текущего сегмента и ищет ближайший файл `not-found.js` (или `.tsx`) вверх по дереву для отображения кастомной 404-страницы. Если он не найден, используется стандартная 404-страница Next.js.

**Критический Взгляд**: Это семантически правильный способ обработать ситуацию "ресурс не найден", отличая её от непредвиденных ошибок сервера или рендеринга (которые должен ловить `error.js`).

## Ошибки в Client Components

### Где Возникают:
Ошибки рендеринга, ошибки в useEffect, ошибки в обработчиках событий.

### Механизм Обработки:

- **Ошибки Рендеринга**: Используются React Error Boundaries. Вы можете создавать свои собственные компоненты-границы ошибок (классовые с `componentDidCatch` или с помощью библиотеки `react-error-boundary`) и оборачивать ими части вашего UI внутри Client Components для более тонкой обработки. Важно: `error.js` из Next.js уже является Error Boundary и поймает ошибки рендеринга в дочерних Client Components, если у них нет своей, более близкой границы.

- **Ошибки в Обработчиках Событий / useEffect**: Error Boundaries не ловят ошибки, происходящие асинхронно или в обработчиках событий. Их нужно обрабатывать с помощью стандартного `try...catch` внутри самих обработчиков или эффектов.

## Ошибки в API Routes (route.js)

### Механизм:
Стандартный `try...catch` внутри ваших функций GET, POST и т.д.

### Ответ Клиенту:
При перехвате ошибки необходимо сформировать и вернуть объект `NextResponse` с соответствующим HTTP статус-кодом (например, 400 Bad Request, 500 Internal Server Error) и, опционально, телом ответа с деталями ошибки (например, `{ "error": "Invalid input" }`). Неперехваченная ошибка приведет к стандартному ответу 500 от Next.js.

## Ошибки в Server Actions

### Механизм:
Server Action — это async функция. Ошибки можно выбрасывать (`throw new Error(...)`).

### Обработка на Клиенте:
- **try...catch**: Если вы вызываете Server Action через `await myAction()`, вы можете обернуть вызов в `try...catch`.
- **useFormState**: Если Action используется в `<form action={...}>`, хук `useFormState` позволяет Action'у вернуть объект состояния, который может содержать информацию об ошибке. Компонент затем может прочитать это состояние и отобразить ошибку пользователю. Это предпочтительный способ для обработки ошибок валидации форм.

## Ошибки в Middleware

### Механизм:
`try...catch` внутри функции middleware.

### Реакция:
Из блока `catch` вы можете вернуть `NextResponse` с сообщением об ошибке или редиректом на страницу ошибки. Неперехваченная ошибка приведет к стандартной странице ошибки сервера.

## Критический Взгляд: Сложность Распределенной Системы

- **Много Уровней**: Обработка ошибок в Next.js App Router усложняется тем, что ошибки могут возникать в разных контекстах (серверный рендеринг RSC, клиентский рендеринг/гидратация Client Components, выполнение API Route, Server Action, Middleware на Edge/Node). Нужно понимать, какой механизм перехвата сработает в каждом случае.

- **error.js - Ограничен**: Помните, что он ловит ошибки рендеринга дочерних элементов и не ловит ошибки в layout'е того же уровня. Также он сбрасывает состояние при срабатывании (через reset), что не всегда подходит.

- **Различайте notFound() и Ошибки**: Это разные сценарии, требующие разных механизмов обработки.

- **Асинхронные Ошибки**: Промисы и await требуют явной обработки rejections через `.catch()` или `try...catch` в async функциях/компонентах.

- **Логирование Серверных Ошибок**: КРИТИЧЕСКИ ВАЖНО! Ошибки, происходящие на сервере (в RSC, API Routes, Server Actions, Middleware), не видны в консоли браузера. Необходимо настроить надежную систему логирования на стороне сервера (например, с помощью сервисов вроде Sentry, Logtail или просто console.error), чтобы отслеживать и диагностировать проблемы.

## Итог

Next.js App Router предоставляет структурированные механизмы для обработки ошибок на разных уровнях (`error.js` для ошибок рендеринга, `notFound()` для отсутствующих ресурсов, стандартные `try...catch` и Error Boundaries). Однако распределенная природа выполнения кода (сервер/клиент/edge) и новые концепции (RSC) вносят дополнительную сложность.

Ключ к надежной обработке ошибок — это понимание, какой механизм использовать в каком контексте, четкое разделение ситуаций "не найдено" и "ошибка", правильная обработка асинхронных операций и, самое главное, настройка надежного логирования серверных ошибок.
