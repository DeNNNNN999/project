# Тема #7: Модуль fs (File System)

Модуль `fs` предоставляет API для взаимодействия с файловой системой операционной системы. Чтение файлов, запись файлов, работа с папками — всё это делается через `fs`.

## 1. Асинхронность по Умолчанию – Философия Node.js в Действии

### Неблокирующий I/O
Подавляющее большинство функций модуля `fs` по умолчанию асинхронны. Они не блокируют Event Loop во время ожидания операции ввода/вывода (чтения с диска, записи на диск).

### Колбэки (Старый Стиль)
Традиционно, асинхронные `fs` функции принимали колбэк последним аргументом, который вызывался по завершении операции. Стандартная сигнатура колбэка: `(error, data) => { ... }`. Если `error` не null, значит, произошла ошибка.

```javascript
const fs = require('fs');

console.log("Начинаем чтение файла...");
fs.readFile('./my-file.txt', 'utf8', (err, data) => { // 'utf8' - кодировка
  // Этот колбэк выполнится ПОЗЖЕ, когда файл прочитается
  if (err) {
    console.error("Ошибка чтения файла:", err);
    return;
  }
  console.log("Файл прочитан (колбэк):", data.substring(0, 50), "...");
});
console.log("...Запрос на чтение отправлен, код продолжает выполняться...");
```

### Синхронные Альтернативы (...Sync) – ОПАСНОСТЬ!

- Почти для каждой асинхронной функции есть синхронный аналог с суффиксом Sync (например, `readFileSync`, `writeFileSync`, `statSync`).
- **Как работают**: Они **ПОЛНОСТЬЮ БЛОКИРУЮТ** Event Loop и весь ваш Node.js процесс, пока операция ввода/вывода не завершится.

**Критический взгляд**: Использование синхронных `fs` методов в серверном приложении (особенно внутри обработчиков запросов) — это путь к катастрофе производительности. Пока Node.js ждет ответа от диска, он не может обрабатывать никакие другие запросы или события.

**Когда (редко) допустимо**:
- При инициализации приложения, до старта сервера (например, чтение конфигурационного файла один раз при запуске).
- В простых скриптах командной строки, где блокировка не критична.

**Вывод**: Избегайте `...Sync` методов в серверном коде любой ценой, если нет абсолютно веской причины и понимания последствий.

## 2. Эволюция API: Промисы (fs/promises) и async/await

К счастью, с колбэками мучиться больше не нужно! Современный Node.js предоставляет промисифицированную версию `fs`.

### Использование:

```javascript
// Способ 1: CommonJS
const fsPromises = require('fs/promises');
// или const { readFile, writeFile } = require('fs/promises');

// Способ 2: ES Modules
// import { readFile, writeFile } from 'fs/promises';
// import * as fsPromises from 'fs/promises';
```

**Преимущества**: Позволяет использовать async/await, делая асинхронный код гораздо более читаемым и похожим на синхронный, но без блокировки Event Loop.

### Сравнение Стилей (Чтение + Запись):

```javascript
const fs = require('fs');
const fsPromises = require('fs/promises');
const path = require('path');

const inputFile = path.join(__dirname, 'input.txt');
const outputFile = path.join(__dirname, 'output.txt');

// --- 1. Callback Hell ---
fs.readFile(inputFile, 'utf8', (err, data) => {
  if (err) { console.error("Read Error:", err); return; }
  const processedData = data.toUpperCase();
  fs.writeFile(outputFile, processedData, 'utf8', (errWrite) => {
    if (errWrite) { console.error("Write Error:", errWrite); return; }
    console.log("File written (Callback)");
  });
});

// --- 2. Promises (.then) ---
fsPromises.readFile(inputFile, 'utf8')
  .then(data => {
    const processedData = data.toUpperCase();
    return fsPromises.writeFile(outputFile, processedData, 'utf8');
  })
  .then(() => {
    console.log("File written (Promise)");
  })
  .catch(err => {
    console.error("Promise Error:", err);
  });

// --- 3. async/await (Предпочтительный) ---
async function processFile() {
  try {
    console.log("Reading file (async)...");
    const data = await fsPromises.readFile(inputFile, 'utf8');
    console.log("Processing data...");
    const processedData = data.toUpperCase();
    console.log("Writing file (async)...");
    await fsPromises.writeFile(outputFile, processedData, 'utf8');
    console.log("File written (async/await)");
  } catch (err) {
    console.error("Async/Await Error:", err);
  }
}
// processFile(); // Не забудьте вызвать async функцию
```

**Критический взгляд**: Переход на `fs/promises` и `async`/`await` — это огромный шаг вперед для читаемости и поддерживаемости асинхронного кода работы с файлами. Используйте именно этот подход в новом коде.

## 3. Распространенные Операции (с fs/promises)

- **Чтение**: `readFile(path, [options])` (опции: `{ encoding: 'utf8' }`). Без encoding вернет Buffer.
- **Запись**: `writeFile(path, data, [options])` (перезаписывает файл).
- **Дозапись**: `appendFile(path, data, [options])` (добавляет в конец файла).
- **Статистика**: `stat(path)` (возвращает объект `fs.Stats` с методами `isFile()`, `isDirectory()`, `size` и др.).
- **Директории**: `mkdir(path, [options])`, `readdir(path, [options])` (читает содержимое папки), `rmdir(path)` (удаляет пустую папку), `rm(path, [options])` (удаляет файлы и папки рекурсивно - осторожно!).

## 4. Обработка Ошибок – Обязательно!

- Операции с файловой системой очень часто завершаются ошибками: файл не найден (ENOENT), нет прав доступа (EACCES, EPERM), диск переполнен (ENOSPC) и т.д.
- Всегда оборачивайте вызовы `fs/promises` в `try...catch` при использовании async/await или добавляйте `.catch()` к цепочке промисов. Необработанная ошибка промиса или выброшенная из колбэка ошибка может уронить ваш Node.js процесс!

## 5. Ловушка: Проверка Существования Файла перед Операцией

- **Анти-паттерн**: Пытаться проверить, существует ли файл (`fs.access` или устаревший `fs.exists`), а затем читать/писать его.
- **Почему плохо?** Это состояние гонки (race condition). Между вашей проверкой и самой операцией другой процесс может удалить/создать/изменить файл или права доступа.
- **Правильный подход**: Сразу пытайтесь выполнить нужную операцию (чтение/запись) и обрабатывайте возможную ошибку (например, ENOENT, если файла нет) в блоке catch.

## 6. Кодировки и Buffer

- При чтении/записи текстовых файлов всегда указывайте кодировку (обычно `'utf8'`).
- Если кодировка не указана, `readFile` вернет, а `writeFile` будет ожидать объект Buffer. Buffer — это специальный класс в Node.js для работы с бинарными данными (сырыми байтами). Он нужен для работы с изображениями, архивами, бинарными сетевыми протоколами и т.д. (Мы коснемся его подробнее в теме про Стримы).

## 7. Напоминание: Используйте Модуль path!

- Всегда формируйте пути, передаваемые в `fs`, с помощью `path.join()` или `path.resolve()` для кросс-платформенной совместимости.

## Итог

Модуль `fs` — ключевой для любых серверных задач, связанных с файлами. Приоритет всегда отдавайте асинхронным методам через `fs/promises` с `async`/`await`. Тщательно обрабатывайте ошибки. Избегайте синхронных методов в серверном коде и анти-паттерна "проверка существования перед операцией". Помните про кодировки для текстовых файлов и используйте `path` для путей. Для больших файлов смотрите в сторону стримов.
