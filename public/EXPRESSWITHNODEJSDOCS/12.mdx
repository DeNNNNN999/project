Тема #12 (Node.js/Express): Маршрутизация в Express

1. Что такое Маршрутизация?

В контексте веб-сервера, маршрутизация (или роутинг) — это процесс определения того, как приложение должно отвечать на запрос клиента, приходящий на определенный URL (путь) и с определенным HTTP-методом (GET, POST, PUT, DELETE и т.д.).

2. Основы Маршрутизации в Express

Express предоставляет очень гибкий и выразительный способ определения маршрутов. Основная структура:

app.METHOD(PATH, HANDLER)

app: Экземпляр вашего Express-приложения (const app = express();).
METHOD: HTTP-метод запроса в нижнем регистре (get, post, put, delete, patch, options и т.д.). Есть также app.all() для любого метода.
PATH: Строка (или шаблон строки, или регулярное выражение), определяющая путь URL, на который должен сработать этот маршрут.
HANDLER: Функция (или несколько функций), которая будет выполнена, если пришел запрос, соответствующий METHOD и PATH. Эта функция получает как минимум два аргумента: req (объект запроса) и res (объект ответа), а также опционально next (для передачи управления следующему обработчику/middleware).
Пример Простого Роутинга:

JavaScript

const express = require('express');
const app = express();
const port = 3004;

// Маршрут для GET запроса на '/'
app.get('/', (req, res) => {
  res.send('Главная страница!');
});

// Маршрут для POST запроса на '/users'
app.post('/users', (req, res) => {
  // Здесь обычно логика создания нового пользователя
  res.status(201).json({ message: 'Пользователь создан (симуляция)', id: Date.now() }); // Отвечаем JSON и статусом 201
});

// Маршрут для GET запроса на '/about'
app.get('/about', (req, res) => {
  res.send('О нас');
});

app.listen(port, () => {
  console.log(`Сервер с роутингом запущен на http://localhost:${port}`);
});
3. Параметры Маршрута (req.params)

Часто нужно, чтобы часть URL была динамической (например, ID пользователя или товара). Для этого используются параметры маршрута, которые объявляются с помощью двоеточия (:).

JavaScript

// Маршрут для получения пользователя по ID
// :userId - это параметр маршрута
app.get('/users/:userId', (req, res) => {
  // Значение параметра доступно в req.params
  const userId = req.params.userId;
  console.log('Запрошен пользователь с ID:', userId);
  // Здесь логика поиска пользователя по ID...
  res.json({ id: userId, name: `User ${userId}` }); // req.params.userId - всегда строка!
});

// Маршрут с несколькими параметрами
app.get('/products/:category/:productId', (req, res) => {
  const { category, productId } = req.params; // Удобно использовать деструктуризацию
  res.send(`Товар ${productId} из категории ${category}`);
});
Критический взгляд: req.params — удобный способ извлекать динамические части пути. Помните, что значения в req.params всегда строки, даже если в URL были цифры. Если вам нужно число, делайте parseInt(req.params.userId, 10).
4. Query-параметры (Строка Запроса) (req.query)

Это параметры, которые идут в URL после знака вопроса ? в виде ключ=значение&другойКлюч=другоеЗначение. Используются для фильтрации, сортировки, пагинации и т.д. Express автоматически парсит их в объект req.query.

JavaScript

// Пример запроса: GET /items?limit=10&sortBy=price&color=red
app.get('/items', (req, res) => {
  console.log('Query параметры:', req.query);
  // Выведет: { limit: '10', sortBy: 'price', color: 'red' }

  const limit = parseInt(req.query.limit || '20', 10); // Получаем и парсим (с дефолтом)
  const sortBy = req.query.sortBy || 'name';

  res.send(`Запрошены товары. Лимит: ${limit}, Сортировка: ${sortBy}`);
});
Критический взгляд: req.query очень удобен. Опять же, помните, что значения там изначально строки. req.params используется для идентификации ресурса, req.query — для опций работы с этим ресурсом или коллекцией.
5. Обработчики Маршрутов (HANDLER)

Что делают: Получают req, res, (иногда next). Их задача — обработать запрос и отправить ответ, используя методы res (res.send(), res.json(), res.status(), res.sendFile(), res.redirect() и т.д.). Важно: Обработчик должен завершить цикл запрос-ответ (вызвав один из методов res.send/json/end/etc), иначе запрос "зависнет".
Несколько Обработчиков: Можно передать несколько функций-обработчиков для одного маршрута. Они выполняются по порядку. Чтобы передать управление следующему обработчику, нужно вызвать функцию next(). Это основа работы middleware (Тема #13).
JavaScript

const logMiddleware = (req, res, next) => { console.log('LOG:', req.method, req.url); next(); };
const finalHandler = (req, res) => { res.send('Final Handler'); };

app.get('/chained', logMiddleware, finalHandler);
6. Модульность с express.Router()

Когда маршрутов становится много, хранить их все в одном файле неудобно. express.Router позволяет сгруппировать связанные маршруты в отдельном модуле.

Как использовать:
Создать роутер: const router = express.Router();
Определить маршруты на роутере: router.get('/:id', ...), router.post('/', ...) (пути относительны точки монтирования).
Экспортировать роутер: module.exports = router;
Подключить (смонтировать) роутер в основном приложении: const userRouter = require('./routes/users'); app.use('/users', userRouter); (Все маршруты из userRouter теперь будут доступны по путям, начинающимся с /users).
Критический взгляд: Использование express.Router необходимо для организации кода в сколь-нибудь больших приложениях. Позволяет декомпозировать логику по фичам или ресурсам.
7. Важные Нюансы Роутинга:

Порядок Имеет Значение! Express проверяет маршруты в том порядке, в котором они определены. Первый совпавший маршрут будет обработан. Поэтому более специфичные маршруты (/users/me) должны идти до более общих (/users/:id), иначе общий маршрут "перехватит" запрос к специфичному.
Нет Встроенной Валидации: Express не валидирует параметры маршрута, query-параметры или тело запроса. Это нужно делать либо вручную в обработчике, либо с помощью специальных middleware (например, express-validator). Это часть "минималистичной" философии.
Асинхронные Обработчики: Обработчики маршрутов могут быть async function. Важно: Если вы используете async/await, обязательно оборачивайте код в try...catch и передавайте ошибки в next(err), либо используйте специальные обертки (типа express-async-handler) или Express v5+ (где ошибки промисов могут обрабатываться автоматически). Непойманная ошибка в асинхронном обработчике может уронить сервер.
Итог по Теме #12:

Система маршрутизации Express проста для старта, но достаточно мощна. Она позволяет определять обработчики для разных HTTP-методов и путей, извлекать динамические данные из URL (req.params, req.query) и структурировать приложение с помощью express.Router. Ключевые моменты для запоминания: порядок определения роутов важен, необходима явная валидация данных, и асинхронные обработчики требуют аккуратной обработки ошибок.
