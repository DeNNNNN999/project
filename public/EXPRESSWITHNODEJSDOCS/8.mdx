# Тема #8: Встроенный Модуль http и Создание Базового Сервера

## 1. Модуль http – Основа Веб-Сервера

**Назначение**: Этот встроенный модуль предоставляет фундаментальные возможности для работы с протоколом HTTP. Он позволяет создавать HTTP-серверы, которые слушают входящие запросы, и делать HTTP-запросы к другим серверам (как клиент).

Мы сфокусируемся на создании сервера.

## 2. Создание HTTP Сервера

Основная функция — `http.createServer()`.

- **http.createServer([requestListener])**: Создает новый экземпляр класса `http.Server`.
- **requestListener** (Необязательный Колбэк): Это функция, которая будет автоматически вызываться при каждом входящем HTTP-запросе к вашему серверу. Если вы не передадите ее сюда, вам нужно будет подписаться на событие 'request' сервера (`server.on('request', requestListener)`).

Эта функция получает два ключевых аргумента:
- **request** (или **req**): Объект типа `http.IncomingMessage`. Содержит всю информацию о запросе от клиента (URL, метод, заголовки, тело запроса как Readable Stream).
- **response** (или **res**): Объект типа `http.ServerResponse`. Используется для формирования и отправки ответа клиенту (установка статуса, заголовков, отправка тела ответа как Writable Stream).

## 3. Запуск Сервера

**server.listen(port, [hostname], [callback])**: Запускает сервер и заставляет его слушать входящие соединения на указанном порту и (опционально) хосте. Колбэк вызывается, когда сервер успешно стартовал.

## 4. Пример: Очень Простой Сервер

Давай напишем сервер, который отвечает по-разному на разные URL, чтобы увидеть все "прелести" ручной обработки.

```javascript
// Подключаем модуль http
const http = require('http');
const port = 3001; // Порт, на котором будет работать сервер

// Функция-обработчик запросов (requestListener)
const serverLogic = (req, res) => {
  // req - объект запроса (http.IncomingMessage)
  // res - объект ответа (http.ServerResponse)

  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);

  // --- Ручная Маршрутизация (Routing) ---
  if (req.url === '/' && req.method === 'GET') {
    // Отвечаем на главный маршрут
    res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' }); // Статус 200, Заголовок
    res.end('Привет! Это базовый сервер Node.js!'); // Завершаем ответ с текстом

  } else if (req.url === '/json' && req.method === 'GET') {
    // Отвечаем JSON
    res.writeHead(200, { 'Content-Type': 'application/json' });
    const data = { message: 'Это JSON ответ', timestamp: Date.now() };
    res.end(JSON.stringify(data)); // Преобразуем объект в JSON строку

  } else if (req.url === '/data' && req.method === 'POST') {
    // --- Ручная Обработка Тела POST Запроса (Очень Упрощенно!) ---
    let requestBody = '';
    // Запрос (req) - это Readable Stream, слушаем событие 'data'
    req.on('data', (chunk) => {
      requestBody += chunk.toString(); // Собираем чанки (куски) данных
      console.log('Received chunk:', chunk.toString());
      // Здесь нужна проверка на размер тела, чтобы избежать переполнения памяти!
    });
    // Слушаем событие 'end', когда все данные получены
    req.on('end', () => {
      console.log('Request body received:', requestBody);
      res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
      try {
        // Пытаемся распарсить JSON (если ожидаем JSON)
        // const parsedData = JSON.parse(requestBody);
        res.end(`Сервер получил POST данные: ${requestBody}`);
      } catch(e) {
         res.writeHead(400); // Bad Request
         res.end("Invalid JSON in request body");
      }
    });
     req.on('error', (err) => { // Обработка ошибок чтения тела запроса
        console.error("Request body stream error:", err);
        res.writeHead(500);
        res.end("Server error reading request");
     });

  } else {
    // Ответ для всех остальных маршрутов - 404 Not Found
    res.writeHead(404, { 'Content-Type': 'text/plain; charset=utf-8' });
    res.end('404 Страница Не Найдена');
  }
};

// Создаем сервер с нашим обработчиком
const server = http.createServer(serverLogic);

// Запускаем сервер на прослушивание порта
server.listen(port, (err) => {
  if (err) {
    return console.error('Ошибка при запуске сервера:', err);
  }
  console.log(`Сервер успешно запущен на порту ${port}`);
  console.log(`Попробуйте открыть: http://localhost:${port}/`);
  console.log(`Или: http://localhost:${port}/json`);
  console.log(`Или отправить POST на http://localhost:${port}/data`);
});
```

## 5. Критический Взгляд: Почему Нужны Фреймворки (Как Express)

Посмотрев на этот код, даже для простейших задач, становится очевидно, почему люди создали фреймворки:

- **Маршрутизация**: Блок if/else if/else для req.url и req.method очень быстро станет огромным и неуправляемым в реальном приложении. Нет удобного способа задавать параметры (`/users/:id`) или группировать роуты.

- **Обработка Тела Запроса**: Читать тело запроса (POST, PUT) через обработку событий 'data' и 'end' крайне неудобно и многословно. Нужно самому собирать чанки, обрабатывать ошибки, парсить JSON или x-www-form-urlencoded.

- **Работа с req и res**: Объект res требует явного вызова writeHead (или установки statusCode/setHeader) и обязательного вызова end(). Легко забыть end(), и запрос "зависнет". Объекты req и res предоставляют базовую функциональность, но фреймворки добавляют множество удобных методов-хелперов (res.json(), res.status(), req.params, req.query, req.body после парсинга).

- **Middleware (Промежуточное ПО)**: В базовом http нет простого способа встроить логику, которая должна выполняться для группы запросов (например, логирование, аутентификация, сжатие).

- **Обработка Ошибок**: Нужно вручную отлавливать ошибки на разных этапах и отправлять корректные HTTP-ответы.

## Итог

Модуль http — это низкоуровневая основа для всей веб-разработки на Node.js. Он позволяет создать рабочий HTTP-сервер, но требует большого количества рутинного кода для базовых задач вроде маршрутизации и обработки данных запроса/ответа.

Понимание его работы очень полезно, чтобы оценить, какую огромную работу по абстрагированию и упрощению берут на себя фреймворки вроде Express, к которому мы перейдем дальше.
