# Тема #4: Модульная Система: Интеграция ES Modules (ESM)

Node.js постепенно внедрил поддержку стандартных ES Модулей (import/export).

## Как Включить ESM

По умолчанию Node.js считает файлы `.js` модулями CommonJS. Чтобы использовать ESM, нужно:

- Использовать расширение файла `.mjs`.
- **ИЛИ** в ближайшем package.json указать `"type": "module"`. Тогда все файлы `.js` в этой папке и подпапках будут считаться ESM по умолчанию. (А если какой-то файл нужно оставить CJS, ему дают расширение `.cjs`).

## Ключевые особенности ESM

- **Синтаксис**: Стандартный import/export (named, default, * as ns, export * from ...).
- **Загрузка**: Асинхронная по своей природе (хотя после загрузки import на верхнем уровне ведет себя синхронно). Структура зависимостей анализируется статически, до выполнения кода.
- **Top-Level await**: В ESM модулях можно использовать await прямо на верхнем уровне (удобно для асинхронной инициализации).

## Отличия от CJS в Node

- Нет переменных `__filename`, `__dirname`. Используйте `import.meta.url` и модули `path`, `url`.
- Нет `require`, `module`, `exports`.
- `this` на верхнем уровне модуля равен `undefined` (в CJS он ссылается на `module.exports`).

## Сложности Взаимодействия CJS и ESM (The Friction)

### Основная Проблема
Синхронный `require` не может просто так загрузить асинхронный ESM. А статический `import` не может динамически загружать CJS так же гибко, как `require`.

### Импорт CJS из ESM
- Обычно работает. `import myCjsModule from './legacy.cjs';` или `import * as cjsNs from './legacy.cjs';`.
- Часто Node.js предоставляет объект `module.exports` из CJS как default export для ESM (особенно при `"esModuleInterop": true` в tsconfig.json, что мы обсуждали). Доступ к именованным экспортам CJS может быть не таким прямым.

### Импорт ESM из CJS
- **Нельзя использовать require()**! Вызовет ошибку.
- Нужно использовать динамический `import()` (который возвращает Promise):

```javascript
// В файле CJS (например, old-code.cjs)
async function loadEsmModule() {
  try {
    const esmModule = await import('./new-code.mjs'); // Динамический import()
    console.log(esmModule.someExportedValue);
    esmModule.default(); // Доступ к default export
  } catch (err) {
    console.error("Failed to load ESM module:", err);
  }
}
loadEsmModule();
```

## Циклические Зависимости

Обе системы пытаются их обрабатывать (CJS возвращает частично сформированный `module.exports`, ESM — "живые" привязки, которые могут быть `undefined` до завершения инициализации), но это почти всегда признак плохо спроектированной архитектуры и может привести к непредсказуемому поведению. Лучше избегать циклов путем рефакторинга.

## Критический взгляд

Сосуществование двух систем в Node.js — это историческая необходимость, но она создает сложности. Разработчикам приходится понимать правила взаимодействия, использовать динамический `import()` из CJS, правильно настраивать package.json (`"type": "module"`) и tsconfig.json (`"module": "NodeNext"`, `"moduleResolution": "NodeNext"` часто рекомендуются для современных проектов). Переход экосистемы на ESM продолжается, но CJS все еще очень распространен.

## Итог

Node.js исторически использовал CommonJS (require/module.exports) — простую, синхронную систему. Сейчас стандарт — ES Modules (import/export) — асинхронная, статически анализируемая система, принятая во всем JavaScript.

Node.js поддерживает оба формата, но их взаимодействие нетривиально из-за разницы в синхронности. Понимание обеих систем и правил их взаимодействия (`import()` из CJS, `"type": "module"`) необходимо для современного Node.js разработчика. Для новых проектов рекомендуется использовать ES Modules.
