# Транзакции в Redis (MULTI/EXEC): Атомарность без Отката

## Введение: Обещание Атомарности?

Redis предоставляет механизм транзакций через команды `MULTI` и `EXEC`. Само слово "транзакция" немедленно вызывает ассоциации с надежными ACID-транзакциями из мира реляционных баз данных, где действует принцип "всё или ничего". Однако транзакции в Redis работают существенно иначе, и непонимание этих отличий — прямой путь к ошибкам и неожиданному поведению. Давайте критически рассмотрим, что на самом деле гарантируют транзакции Redis, а чего от них ждать не стоит.

## Механизм: MULTI, Очередь, EXEC

Процесс использования транзакций прост:

1. **MULTI**: Клиент отправляет команду `MULTI`. Сервер отвечает OK и переходит в режим ожидания команд транзакции.

2. **Постановка в Очередь**: Клиент отправляет последовательность команд (`SET`, `INCR`, `LPUSH` и т.д.). Сервер не выполняет эти команды немедленно, а просто проверяет их синтаксическую корректность и ставит в очередь. На каждую успешно добавленную команду сервер отвечает `QUEUED`.

3. **EXEC**: Клиент отправляет команду `EXEC`. Сервер последовательно выполняет все команды из очереди как единый, непрерываемый блок. После выполнения всех команд, сервер возвращает клиенту массив ответов, содержащий результаты каждой выполненной команды в том же порядке, в котором они были поставлены в очередь.

4. **DISCARD**: Если клиент решает отменить транзакцию до вызова `EXEC`, он может отправить команду `DISCARD`. Очередь команд очищается, и сессия возвращается в обычный режим.

## Ключевая Гарантия: Атомарность Исполнения

Redis гарантирует, что пока выполняются команды между `MULTI` и `EXEC`, никакие другие команды от других клиентов не будут выполнены. Весь блок команд выполняется атомарно с точки зрения внешних наблюдателей. Это защищает от ситуаций, когда другой клиент мог бы вклиниться и изменить данные между двумя командами вашей транзакции.

---

## Главное Противоречие: Ошибки НЕ Вызывают Откат!

Вот самый важный и часто шокирующий момент для тех, кто привык к ACID: **Redis НЕ поддерживает откат транзакции (rollback) в случае ошибки выполнения команды внутри блока MULTI/EXEC**.

### Как обрабатываются ошибки:

#### Ошибки до EXEC:

Если вы отправляете команду с неверным синтаксисом или неправильным количеством аргументов до вызова `EXEC` (пока команды ставятся в очередь), Redis обнаружит это сразу. Он вернет ошибку на эту команду, пометит всю транзакцию как некорректную, и при последующем вызове `EXEC` транзакция будет отменена (DISCARDed), и ни одна команда не выполнится. Это предсказуемое поведение.

#### Ошибки во время EXEC:

Если же ошибка возникает во время выполнения команды из очереди (например, вы пытаетесь выполнить арифметическую операцию `INCR` над строковым значением, или `LPUSH` на хэш), происходит следующее:

- Redis **не останавливает** выполнение транзакции.
- Для команды, вызвавшей ошибку, в итоговом массиве результатов `EXEC` будет возвращен объект ошибки.
- Все остальные команды в транзакции, которые были до и после ошибочной, будут выполнены (если они сами по себе корректны)!

### Пример:

```
MULTI
OK
SET user:1:name Alice
QUEUED
INCR user:1:name  # Ошибка во время EXEC, т.к. name - строка
QUEUED
SET user:1:city London
QUEUED
EXEC
1) OK
2) (error) WRONGTYPE Operation against a key holding the wrong kind of value
3) OK
```

**Результат**: Ключ `user:1:name` останется "Alice", ключ `user:1:city` будет установлен в "London". Транзакция не откатилась к состоянию до MULTI из-за ошибки с INCR.

### Почему так сделано?

- **Простота и Скорость**: Реализация механизма отката (сохранение предыдущих состояний, логирование) значительно усложнила бы внутреннюю структуру Redis и снизила бы его производительность.
- **Философия**: Redis придерживается мнения, что ошибки типа (вроде INCR строки) — это ошибки программирования на стороне клиента, которые должны быть исправлены в коде приложения, а не обрабатываться сложным механизмом отката на сервере. Синтаксические ошибки ловятся до EXEC.

---

## Оптимистические Блокировки (WATCH)

Простая транзакция MULTI/EXEC не защищает от гонок данных, если ваша транзакция зависит от значения ключа, которое может быть изменено другим клиентом между тем, как вы его прочитали, и тем, как вы вызвали EXEC.

- **WATCH key1 key2 ...**: Команда, которую нужно вызвать до `MULTI`. Она указывает Redis следить за изменениями указанных ключей.
- **Механизм Check-and-Set (CAS)**: Если хотя бы один из "наблюдаемых" ключей был изменен другим клиентом в промежутке между `WATCH` и `EXEC`, то при вызове `EXEC` вся транзакция немедленно отменяется, и `EXEC` возвращает специальное значение nil.
- **Действия клиента**: Если `EXEC` вернул nil, клиент понимает, что произошел конфликт. Он должен повторить всю операцию: заново прочитать данные, заново вызвать `WATCH`, `MULTI`, поставить команды в очередь и вызвать `EXEC`.

**Критический взгляд**: `WATCH` реализует механизм оптимистической блокировки. Он не блокирует ключи для других клиентов, а просто проверяет перед выполнением транзакции, не изменил ли кто-то данные "из-под ног". Это необходимо для всех операций "прочитал-изменил-записал", требующих условной атомарности.

## Транзакции Redis vs ACID

Давайте сравним с классическими ACID-гарантиями:

- **Atomicity (Атомарность)**: Есть, но ограниченная. Гарантируется только атомарность исполнения блока команд (никто не вклинится). Нет атомарности "всё или ничего" при runtime-ошибках внутри блока.

- **Consistency (Согласованность)**: Redis сам по себе не обеспечивает согласованность данных в бизнес-смысле. Это ответственность приложения и команд внутри транзакции.

- **Isolation (Изоляция)**: Да, во время выполнения `EXEC` команды изолированы от других клиентов. Однако использование `WATCH` показывает, что модель изоляции отличается от строгих уровней изоляции в СУБД (нет блокировок до EXEC).

- **Durability (Надежность)**: Полностью зависит от выбранной стратегии персистентности (RDB/AOF), а не от самого механизма транзакций.

## Итог

Транзакции в Redis (MULTI/EXEC) — это полезный инструмент для атомарного выполнения группы команд, защищающий от вмешательства других клиентов в процессе. Однако их ключевое и критически важное отличие от ACID-транзакций — отсутствие отката при ошибках времени выполнения.

Для обеспечения условного выполнения операций и защиты от гонок данных необходимо использовать оптимистические блокировки с `WATCH`. Называть их полноценными ACID-транзакциями некорректно и может привести к неправильным ожиданиям и ошибкам проектирования. Для сложных атомарных операций с условной логикой часто предпочтительнее использовать Lua-скрипты.
