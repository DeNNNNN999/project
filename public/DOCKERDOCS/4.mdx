Тема 4: Многоступенчатые Сборки: Осознанная Сложность ради Оптимизации
Суть — разделить процесс создания образа на несколько этапов (стадий) внутри одного Dockerfile, чтобы в финальный образ попало только то, что действительно нужно для запуска приложения, а весь сборочный "мусор" остался за бортом.

Как это проявляется (Глубокий взгляд):
Проблема до Multi-stage: Представь, ты собираешь Java-приложение. Тебе нужен JDK и Maven (или Gradle) для компиляции и сборки .jar. В простом Dockerfile ты бы сделал: FROM maven:3-jdk-17, скопировал исходники, запустил mvn package. В результате в твоем образе остался бы и JDK, и Maven, и все скачанные зависимости сборки, и исходники — сотни мегабайт или даже гигабайт лишнего балласта, который не нужен для запуска итогового .jar-файла (ему достаточно JRE). Кроме раздутого размера, ты тащишь в прод кучу ненужного ПО (JDK, Maven) со своими потенциальными уязвимостями (CVE).
Решение с Multi-stage: Ты делишь Dockerfile на стадии:
Стадия 1: Сборщик (builder)
Dockerfile

FROM maven:3-jdk-17 AS builder
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline # Опционально, для кеширования зависимостей
COPY src ./src
RUN mvn package -DskipTests
# На этой стадии в /app/target/myapp.jar лежит наш артефакт
Стадия 2: Финальный образ (runtime)
Dockerfile

FROM openjdk:17-jre-slim # Используем минимальный образ с JRE
WORKDIR /app
# Ключевой момент: копируем ТОЛЬКО артефакт из предыдущей стадии!
COPY --from=builder /app/target/myapp.jar .
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "myapp.jar"]
Механизм:
Каждая инструкция FROM начинает новую стадию сборки. Стадии нумеруются с 0 или могут иметь имя (AS builder).
Инструкция COPY --from=<имя_или_индекс_стадии> <путь_источник> <путь_назначение> позволяет копировать файлы из файловой системы предыдущей стадии в текущую.
Только последняя стадия в Dockerfile (если не указано иное через --target) формирует финальный образ. Все предыдущие стадии и их артефакты (кроме скопированных) отбрасываются.
В чем особенность / проблематика? (Глубокий взгляд):
Да, появляется некоторая добавленная сложность, но она с лихвой окупается.

Усложнение Dockerfile: Файл становится длиннее, появляются именованные стадии, нужно использовать COPY --from. Требуется более четкое понимание процесса сборки: что является артефактом, а что — сборочной зависимостью.
Отладка Сборки: Если что-то пошло не так, нужно разбираться, на какой стадии произошла ошибка. Иногда проблема возникает при копировании артефакта (COPY --from), если путь указан неверно или артефакт не создался на предыдущей стадии. Можно собрать образ только до определенной стадии для отладки: docker build --target builder .
Взаимодействие с Кешем: Каждая стадия имеет свой контекст кеширования. Изменение в одной стадии инвалидирует кеш для нее и всех последующих стадий. Поэтому важен порядок команд внутри каждой стадии (например, копировать pom.xml и скачивать зависимости до копирования исходников src).
Огромные Преимущества:
Радикальное Уменьшение Размера: Это главное! Вместо гигабайтного образа с JDK+Maven получаем образ на ~150 МБ с JRE+jar. Для Go или Rust, компилируемых в статический бинарник, можно использовать FROM scratch (пустой образ) или distroless/static и получить итоговый образ размером в несколько мегабайт. Это экономит место в реестре, ускоряет скачивание и развертывание (особенно при масштабировании).
Существенное Снижение Поверхности Атаки: Убирая из финального образа компиляторы, SDK, менеджеры пакетов (apt, apk, npm), shell'ы, ненужные библиотеки, мы драматически уменьшаем количество потенциальных уязвимостей. Меньше кода = меньше дыр. Это критически важно для безопасности в production.
Чистота и Разделение Ответственности: Dockerfile явно документирует, что нужно для сборки, а что — для запуска. Это улучшает понимание зависимостей приложения.
Критический взгляд :
Называть multi-stage "сложностью" — это смотреть на ситуацию только с одной стороны. С точки зрения профессиональной разработки и эксплуатации, это необходимый инструмент оптимизации.

Цена Качества: Да, написать multi-stage Dockerfile требует чуть больше усилий, чем простой. Но это как потратить время на настройку CI/CD пайплайна: начальные вложения окупаются многократно в долгосрочной перспективе за счет скорости, надежности и безопасности. Отказ от multi-stage ради "простоты" — это экономия на спичках, которая приведет к пожару (уязвимости, медленные деплои, высокие расходы на трафик/хранение).
"Сложность" как Дисциплина: Эта "сложность" заставляет тебя лучше структурировать процесс сборки. Ты вынужден четко определить артефакты и runtime-зависимости. Это приводит к более чистому и понятному процессу. Так что это скорее полезная дисциплинирующая мера, чем реальная сложность.
Безопасность Превыше Всего: В больших компаниях, где безопасность — абсолютный приоритет, multi-stage билды — это стандарт де-факто. Любой security review завернет образ, собранный без multi-stage (если это технически применимо), потому что он содержит тонну ненужного хлама, увеличивающего attack surface. Уменьшение CVE count в образах — это постоянная головная боль SRE и Security команд.
Итог: Противоречие "сложность vs эффективность" здесь решается однозначно в пользу эффективности. Дополнительная структурированность Dockerfile — это мизерная плата за огромные выгоды в размере, скорости и, главное, безопасности финального образа. Для любого production-окружения использование multi-stage сборок (где это применимо) должно быть обязательной практикой, а не опцией. Считать это излишней сложностью — значит не понимать современных реалий разработки и эксплуатации контейнеризированных приложений.
