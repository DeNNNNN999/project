Тема 8: Неизменяемость Контейнеров: Идеал DevOps vs Суровая Реальность Отладки
Идея неизменяемой инфраструктуры проста и элегантна: однажды созданный артефакт (в нашем случае — Docker-образ) никогда не изменяется. Обновление системы происходит путем замены старых экземпляров (контейнеров) новыми, созданными из нового артефакта.

Как это проявляется (Глубокий взгляд):
Идеальный Мир (Immutable Workflow):

Сборка: Любое изменение кода, зависимостей или конфигурации приложения приводит к сборке нового Docker-образа (docker build) с уникальным тегом (например, хеш коммита, версия). Dockerfile — единственный источник истины о содержимом образа.
Тестирование: Этот новый образ развертывается в тестовых/staging окружениях. Запускаются новые контейнеры из этого образа, прогоняются тесты.
Развертывание: Если все ОК, происходит выкатка в продакшен путем замены старых контейнеров на новые экземпляры, запущенные из нового, протестированного образа. Используются стратегии вроде Rolling Update, Blue-Green, Canary для минимизации или исключения даунтайма.
Эксплуатация: Запущенные контейнеры рассматриваются как "черные ящики". Никто никогда не подключается к ним для установки патчей, правки конфигов или установки утилит.
Отладка: Проблемы диагностируются извне: через логи (агрегированные централизованно), метрики (мониторинг), внешние health checks. Если нужен глубокий анализ, то либо анализируются артефакты после остановки контейнера (логи, core dumps), либо запускаются специальные диагностические контейнеры, либо проблема воспроизводится в dev/staging окружении.
Реальный Мир (Практические Отклонения):

docker exec: Главный Соблазн. Это происходит постоянно. Что-то не работает в проде -> docker exec -it <id_контейнера> /bin/bash (или sh) -> смотрим процессы (ps aux), сеть (netstat), логи (tail -f), ставим утилиты (apt update && apt install procps dnsutils tcpdump vim), правим конфиг "на живую". Быстро, грязно, но дает немедленный доступ к внутренностям работающего контейнера.
Хотфиксы "на Месте": Критический баг, нужно починить прямо сейчас. Разработчик или SRE заходят через exec, патчат код или конфиг прямо в контейнере, перезапускают процесс внутри контейнера. Сервис восстановлен, но... ценой нарушения процесса и потери изменений при следующем деплое.
Дрифт Конфигурации (Configuration Drift): Если конфигурация не управляется строго извне (например, через ConfigMaps в K8s, переменные окружения, read-only тома), изменения, сделанные через exec или даже самим приложением (если оно пишет в свои конфиги), приводят к тому, что состояние контейнера отличается от исходного образа и от других экземпляров этого же сервиса.
Запись в Writable Layer: Приложение по ошибке или из-за незнания пишет важные данные не в том (volume), а в эфемерный записываемый слой контейнера. Эти данные живут, пока жив контейнер, но теряются при его замене.
Ручные Патчи: В менее зрелых компаниях админы могут по привычке относиться к контейнерам как к обычным серверам и пытаться заходить внутрь для установки обновлений безопасности (apt upgrade).
В чем особенность / проблематика? (Глубокий взгляд):
Конфликт возникает между долгосрочными преимуществами идеального подхода и краткосрочными тактическими выгодами "быстрых" отклонений.

Зачем Нужна Неизменяемость (Преимущества Идеала):
Консистентность: Гарантия, что все экземпляры приложения одной версии идентичны друг другу и окружениям (dev/staging/prod). Устраняет фразу "А у меня работает!".
Воспроизводимость: Деплойменты становятся предсказуемыми и повторяемыми. Откат к предыдущей версии — это просто деплой старого образа.
Надежность: Уменьшает дрифт конфигурации и количество "серверов-снежинок" (уникальных экземпляров), которые сложно поддерживать и отлаживать.
Упрощение Управления: Отпадает необходимость в сложных системах управления конфигурацией (Ansible, Chef) внутри работающих контейнеров. Вся конфигурация либо запекается в образ, либо внедряется декларативно извне.
Почему Реальность Кусается (Причины Отклонений):
Срочность: Когда продакшен лежит, давление починить "любой ценой" огромно. docker exec кажется самым быстрым способом диагностики и исправления.
Сложность Отладки: Диагностика исключительно по внешним сигналам (логи, метрики) может быть сложнее или медленнее, особенно при нетривиальных проблемах. Отсутствие привычных утилит в минималистичных образах (Alpine, Distroless) усугубляет ситуацию.
Легаси: Старые приложения, не спроектированные под контейнеры, могут требовать изменений "на лету" или писать состояние в неожиданные места.
Медленные Пайплайны: Если сборка, тестирование и выкатка нового образа занимают часы, соблазн применить хотфикс через exec за минуты очень велик.
Отсутствие Дисциплины/Инструментов: Недостаток опыта, плохая культура DevOps, отсутствие адекватных инструментов мониторинга и логирования могут делать exec единственным знакомым способом понять, что происходит.
Последствия Отклонений:
Потеря Воспроизводимости: Хотфикс через exec не отражен в коде/Dockerfile. При следующем рестарте или деплое он исчезнет.
Дрифт Конфигурации: Приводит к неконсистентному поведению, трудноуловимым багам ("почему этот инстанс работает иначе?").
Риски Безопасности: Установка пакетов "на лету" может привнести уязвимости. Измененные файлы не будут видны сканерам безопасности, проверяющим исходный образ. Ручные патчи — источник ошибок.
Технический Долг: Каждый exec-фикс — это, по сути, костыль, который маскирует проблемы в приложении, процессе сборки/деплоя или в системе мониторинга.
Критический взгляд:
Неизменяемость — это не догма, а цель и направление. Важно не столько достичь 100% чистоты (что иногда непрактично), сколько минимизировать отклонения и иметь процессы для их устранения.

docker exec как "Запах" Проблемы (Code Smell): Частое использование exec в проде — это симптом, а не решение. Он указывает на проблемы глубже:
Слабая наблюдаемость (observability): не хватает логов, метрик, трейсов.
Неадекватные health checks.
Медленные или ненадежные CI/CD пайплайны.
Отсутствие заранее подготовленных инструментов/образов для отладки.
Реальность FAANG: Здесь к неизменяемости относятся очень серьезно. Доступ в прод через exec либо жестко ограничен и аудируется, либо полностью запрещен. Ставка делается на автоматизацию, мониторинг и самовосстановление систем. Отладка — через анализ логов/метрик/дампов или направление части трафика на специальные "отладочные" инстансы, а не через вмешательство в живые боевые контейнеры.
Проектирование под Неизменяемость: Приложения должны создаваться с учетом этого принципа: конфигурация извне (env vars, config files in volumes/ConfigMaps), логи в stdout/stderr, состояние в томах/БД, четкие health check эндпоинты. Использование минималистичных образов (distroless) помогает форсировать неизменяемость, убирая сам соблазн (/bin/sh там нет).
Итог: "Противоречие" между идеалом неизменяемости и операционной реальностью существует. Но преимущества идеала (консистентность, надежность, воспроизводимость) огромны. Отклонения (docker exec), хотя иногда тактически оправданы в чрезвычайных ситуациях, подрывают эти преимущества и создают риски. Профессиональный подход — строить системы и процессы так, чтобы минимизировать саму необходимость в таких отклонениях. Нужно инвестировать в автоматизацию, мониторинг, быстрые пайплайны и дисциплину. docker exec в прод — это сигнал SOS, а не штатный инструмент отладки.
