Тема #20: Эмуляция Номинативной Типизации (Branded Types)

1. Проблема: Структурная Типизация Не Всегда Достаточна

Мы установили (в Теме #3), что TypeScript использует структурную типизацию: совместимость типов определяется их формой, а не именем. Это хорошо согласуется с JavaScript, но иногда создает проблемы.

Представь ситуацию:

TypeScript

type UserID = string;
type OrderID = string;

function cancelOrder(id: OrderID) {
  console.log(`Order ${id} cancelled.`);
}

function getUserInfo(id: UserID) {
  console.log(`Workspaceing info for user ${id}...`);
}

let myUserId: UserID = "user-abc";
let myOrderId: OrderID = "order-123";

getUserInfo(myUserId);   // OK
cancelOrder(myOrderId); // OK

// Опа! Структурная типизация НЕ видит проблемы:
getUserInfo(myOrderId); // OK на этапе компиляции! (string совместим с string)
cancelOrder(myUserId);  // OK на этапе компиляции! (string совместим с string)
Хотя и UserID, и OrderID — это просто строки, они несут разный семантический смысл. Мы бы хотели, чтобы компилятор запретил передавать ID заказа в функцию, ожидающую ID пользователя, и наоборот. Структурная типизация сама по себе этого не делает. Нам нужно сымитировать номинативное поведение, где имя типа имеет значение.

2. Решение: "Брендированные" Типы (Branded Types Pattern)

Это популярный паттерн в TypeScript для достижения номинативной типизации для типов, которые иначе были бы структурно эквивалентны (чаще всего для примитивов вроде string или number).

Идея: Добавить к базовому типу (например, string) уникальную, фиктивную "метку" или "бренд", которая существует только на уровне типов и не влияет на рантайм-значение. Эта метка делает типы структурно несовместимыми для компилятора.

Реализация:

Определяем уникальный "бренд". Часто это делается через unique symbol или просто объектный тип с уникальным свойством.
Создаем новый тип с помощью пересечения (&) базового типа и типа "бренда".
Так как создать значение с фиктивным свойством нельзя, для преобразования базового типа в "брендированный" используются утверждения типа (as), часто обернутые во вспомогательные функции.
Пример с UserID и OrderID:

TypeScript

// Шаг 1: Определяем "бренды" (используем самый простой вариант с __brand)
type UserIdBrand = { readonly __brand: unique symbol }; // Или { __brand: "UserID" };
type OrderIdBrand = { readonly __brand: unique symbol };// Или { __brand: "OrderID" };

// Шаг 2: Создаем брендированные типы
type UserID = string & UserIdBrand;
type OrderID = string & OrderIdBrand;

// Шаг 3: Вспомогательные функции для "безопасного" создания (кастинга)
// В реальном коде здесь может быть валидация формата ID
function createUserId(id: string): UserID {
    return id as UserID; // Утверждение типа - мы "знаем", что это валидный UserID
}
function createOrderId(id: string): OrderID {
    return id as OrderID; // Утверждение типа
}

// --- Использование ---
function cancelOrder(id: OrderID) {
  console.log(`Order ${id} cancelled.`); // 'id' все еще можно использовать как string
}
function getUserInfo(id: UserID) {
  console.log(`Workspaceing info for user ${id}...`); // 'id' все еще можно использовать как string
}

let userIdValue = "user-abc";
let orderIdValue = "order-123";

let myUserId = createUserId(userIdValue);
let myOrderId = createOrderId(orderIdValue);

getUserInfo(myUserId);   // OK
cancelOrder(myOrderId); // OK

// --- Теперь TypeScript видит ошибку! ---
// getUserInfo(myOrderId);
// ОШИБКА TS: Argument of type 'OrderID' is not assignable to parameter of type 'UserID'.
//           Type 'OrderID' is not assignable to type 'UserIdBrand'.

// cancelOrder(myUserId);
// ОШИБКА TS: Argument of type 'UserID' is not assignable to parameter of type 'OrderID'.
//           Type 'UserID' is not assignable to type 'OrderIdBrand'.

// При этом значение остается строкой в рантайме
let combined: string = myUserId + "_" + myOrderId; // OK
console.log(combined); // user-abc_order-123
3. Альтернативы (Менее Подходящие для ID)

enum: Создает реальные объекты в рантайме. Подходит для перечисления известных констант, но не для уникальных ID, которые являются строками/числами.
class: class UserId { constructor(public readonly value: string) {} }. Обеспечивает строгую номинативность, но создает полноценные объекты вместо примитивов, что может быть излишним и менее производительным для простых идентификаторов. Требует доступа к значению через .value.
4. Критический Взгляд

Это "Хак"? Да, по сути, "брендирование" — это умный обходной путь, использующий особенности системы типов TS (пересечения и структурную несовместимость) для симуляции номинативного поведения там, где оно нужно. Фиктивный бренд (__brand) не существует в рантайме.
Нужны Утверждения Типа (as): Главный недостаток — необходимость использовать as для создания "брендированных" значений из базовых примитивов. Это место, где ответственность за корректность типа ложится на разработчика. Хотя обычно это происходит в контролируемых местах (функции-конструкторы createUserId).
Бойлерплейт: Требует определения брендов, самих типов и часто вспомогательных функций. Немного больше кода, чем просто type UserID = string.
Почему нет Встроенного Решения? В сообществе TS давно идут дискуссии о нативной поддержке "непрозрачных" (opaque) или номинативных псевдонимов типов, но пока (на ~апрель 2025) стандартного решения нет. Branded Types — устоявшийся комьюнити-паттерн.
Когда Использовать? Не нужно "брендировать" каждый string или number! Используйте этот паттерн только тогда, когда смешивание типов с одинаковой структурой может привести к серьезным логическим ошибкам или проблемам безопасности. Классические примеры:
Различные виды ID (UserID, ProductID, SessionID).
Единицы измерения (Meters, Kilograms, оба могут быть number).
Валидированные или "безопасные" строки (SafeHTML, ValidatedEmail), чтобы отличать их от обычных string.
Итог по Теме #20:

Паттерн "Branded Types" — это стандартный способ эмулировать номинативную типизацию в структурной системе типов TypeScript. Он позволяет компилятору различать типы с одинаковой базовой структурой (часто примитивы), предотвращая их случайное смешивание в коде. Хотя он требует некоторого бойлерплейта и использования утверждений типа при создании значений, он значительно повышает безопасность и семантическую корректность кода в тех случаях, где простое структурное сравнение недостаточно.
