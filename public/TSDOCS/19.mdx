Тема #19: Декораторы (Decorators)

1. Что такое Декораторы?

Синтаксис: Это специальные объявления, которые начинаются с символа @ и ставятся перед объявлением класса, метода, свойства, аксессора (get/set) или параметра метода/конструктора. Пример: @Component, @log, @Input().
Суть: Декоратор — это функция, которая вызывается во время определения (а не во время выполнения) класса/метода/свойства и получает информацию о декорируемой сущности. Она может наблюдать, модифицировать или даже заменять эту сущность.
Назначение: Предоставить декларативный способ добавления поведения, метаданных или трансформации к классам и их членам, не засоряя основную логику этих классов. Это мощный инструмент для метапрограммирования.
2. Статус: Эксперимент на Пути к Стандарту (Очень Важно!)

ECMAScript Proposal: Декораторы — это предложение для стандарта JavaScript, которое прошло долгий путь и сейчас (на момент ~апреля 2025) находится на Stage 3 в комитете TC39. Это очень высокая стадия, означающая, что фича скорее всего войдет в стандарт, но финальные детали еще могут уточняться.
TypeScript: Поддерживал декораторы экспериментально уже очень давно, основываясь на более ранних версиях предложения. Эта поддержка включается флагом "experimentalDecorators": true в tsconfig.json.
Несоответствие и Эволюция: Современный Stage 3 proposal отличается от старой экспериментальной реализации TS. Новые версии TypeScript стремятся соответствовать Stage 3. Это означает, что код, использующий "старые" экспериментальные декораторы, может потребовать миграции или будет работать иначе с новыми настройками компилятора.
emitDecoratorMetadata: Еще один флаг ("emitDecoratorMetadata": true), часто используемый вместе с experimentalDecorators. Он заставляет TS сохранять информацию о типах декорируемых элементов в метаданных (с помощью полифилла reflect-metadata), что критически важно для фреймворков с Dependency Injection.
Критический взгляд: Эта двойственность статуса и эволюция стандарта — главный источник путаницы и потенциальных проблем. Нужно четко понимать, какую версию декораторов вы используете (старую экспериментальную или новую, соответствующую Stage 3) и какие флаги компилятора для этого нужны. Всегда сверяйтесь с документацией TypeScript по вашей версии!
3. Типы Декораторов и Что Они Могут:

Декораторы применяются к разным частям класса:

Декоратор Класса (@sealed, @Component): Применяется ко всему классу. Получает конструктор класса. Может обернуть/заменить конструктор, добавить статические свойства или метаданные.
Декоратор Метода (@logMethod, @Get): Применяется к методу. Получает прототип класса, имя метода и дескриптор свойства. Может изменить дескриптор (сделать метод writable: false), обернуть оригинальный метод (для логирования, проверки прав).
Декоратор Аксессора (@enumerable(false)): Применяется к get или set. Похож на декоратор метода.
Декоратор Свойства (@Input, @Column): Применяется к свойству класса. Нюанс: В современном Stage 3 / TS он не может напрямую легко модифицировать инициализатор свойства или перехватывать доступ к нему так, как это было в старых экспериментальных версиях. В основном используется для добавления метаданных, которые потом читаются другими декораторами (например, классовым) или фреймворком.
Декоратор Параметра (@Inject, @Param): Применяется к параметру в конструкторе или методе. Получает прототип, имя метода/undefined (для конструктора) и индекс параметра. Используется почти исключительно для записи метаданных (например, какой сервис внедрить в этот параметр конструктора).
4. Практические Применения (Часто во Фреймворках):

Декораторы расцвели в таких фреймворках, как Angular, NestJS, TypeORM и др.

Dependency Injection (DI): @Injectable(), @Inject('SERVICE_TOKEN') — маркировка классов и параметров для автоматического внедрения зависимостей.
Маршрутизация (Routing): @Controller('/users'), @Get('/:id') — привязка методов класса к HTTP-маршрутам и методам.
Валидация Данных: @IsString(), @MinLength(5) (библиотека class-validator) — декларативное описание правил валидации для свойств класса.
ORM (Object-Relational Mapping): @Entity(), @Column(), @ManyToOne() (библиотека TypeORM) — описание связи классов с таблицами и полями в базе данных.
Логирование / Мониторинг: @logExecutionTime — обертка методов для замера времени выполнения.
Пример (Концептуальный):

TypeScript

// Необходим "experimentalDecorators": true и "emitDecoratorMetadata": true в tsconfig.json
// и npm install reflect-metadata (и импорт 'reflect-metadata' в начале приложения)

function Log(message: string): ClassDecorator {
  console.log("Log Decorator Factory called");
  return function (constructor: Function) {
    console.log(`${message}: Class ${constructor.name} initialized`);
    // Можно добавить статические свойства или изменить конструктор (редко)
  };
}

function MethodLogger(): MethodDecorator {
  console.log("MethodLogger Factory called");
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log(`MethodLogger applied to ${propertyKey}`);
    const originalMethod = descriptor.value;
    descriptor.value = function (...args: any[]) { // Оборачиваем метод
      console.log(`Entering ${propertyKey} with args: ${JSON.stringify(args)}`);
      const result = originalMethod.apply(this, args);
      console.log(`Exiting ${propertyKey}, result: ${result}`);
      return result;
    };
  };
}

@Log("SERVICE:") // Декоратор класса
class Calculator {
  @MethodLogger() // Декоратор метода
  add(a: number, b: number): number {
    return a + b;
  }
}

// Вывод при загрузке класса (декораторы выполняются при определении):
// Log Decorator Factory called
// MethodLogger Factory called
// MethodLogger applied to add
// SERVICE:: Class Calculator initialized

// Вывод при использовании:
const calc = new Calculator();
const sum = calc.add(5, 3);
// Entering add with args: [5,3]
// Exiting add, result: 8
console.log(sum); // 8
5. Критический Взгляд:

Метапрограммирование = Мощь + "Магия": Декораторы позволяют писать очень лаконичный код для сложных задач (DI, ORM), но они скрывают много логики. Понять, что именно происходит при вызове метода @Get('/:id'), бывает непросто — нужно знать, как работает декоратор и фреймворк. Это может усложнить отладку.
Зависимость от Экспериментального Статуса: Исторически, использование нестабильной фичи было риском. Сейчас Stage 3 дает больше уверенности, но все равно важно следить за стандартом и обновлениями TS.
Зависимость от reflect-metadata: Для многих сценариев (особенно DI) требуется полифилл reflect-metadata и флаг emitDecoratorMetadata, что добавляет рантайм-зависимость и использует рефлексию (интроспекцию типов во время выполнения), что нетипично для философии JS/TS со стиранием типов.
Альтернативы: Не всегда нужен декоратор. Часто ту же логику можно реализовать через функции высшего порядка (HOF), композицию или явные вызовы функций-фабрик. Декораторы удобны, когда нужно декларативно применить однотипное поведение ко многим членам класса.
Итог по Теме #19:

Декораторы — это продвинутая фича TypeScript (и будущий стандарт JS) для метапрограммирования. Они очень популярны во фреймворках (Angular, NestJS) для уменьшения бойлерплейта в задачах вроде DI, роутинга, ORM. Однако их статус все еще формально экспериментальный (хоть и на Stage 3), они могут добавлять "магию" в код и часто требуют специфических настроек компилятора и полифиллов. Используйте их осознанно, особенно если пишете свой код, а не просто используете фреймворк.
