Тема #3: Структурная Типизация (Structural Typing)

Представь, что ты пришел на фейсконтроль в клуб.

Номинативная типизация (Nominal Typing): (Как в Java, C#, C++) Охранник смотрит на твой паспорт (имя типа). Если в паспорте написано "VIP-гость" или "Член клуба" (т.е. тип явно объявлен как совместимый), тебя пропускают. Неважно, что ты одет так же, как VIP-гость, если в паспорте этого нет. Имя решает.
Структурная типизация (Structural Typing): (Как в TypeScript, Go) Охранник смотрит на тебя (структуру объекта). Если у тебя есть клубная карта (нужное свойство), ты выглядишь подобающе (другие нужные свойства) и можешь произнести пароль (нужные методы), то тебя пропускают. Неважно, как называется твой "тип" — "VIP-гость", "Случайный прохожий с картой" или "Маскирующийся репортер" — важна только структура (форма, shape). Это еще называют "утиной типизацией" (duck typing): "Если нечто выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка".
Как это работает в TypeScript:

TypeScript определяет совместимость типов не по их именам или явному наследованию, а по их структуре. Если объект А имеет как минимум тот же набор свойств и методов (с совместимыми типами), что и тип Б, то А считается совместимым с Б (или подтипом Б).

Пример "Неожиданной" Совместимости:

TypeScript

interface Point {
  x: number;
  y: number;
}

class Vector {
  constructor(public x: number, public y: number) {}
  // Может иметь и другие свойства/методы
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
}

function logPoint(p: Point) {
  console.log(`Coordinate: (${p.x}, ${p.y})`);
}

let myPoint: Point = { x: 5, y: 10 };
let myVector: Vector = new Vector(1, 2);
let randomObject = { x: 100, y: 200, z: 300 }; // Имеет x и y, и даже больше!

logPoint(myPoint);      // OK - Ожидаемо
logPoint(myVector);     // OK! - Хотя Vector не наследует Point, у него есть x и y нужного типа.
logPoint(randomObject); // OK! - Лишнее свойство 'z' не мешает, главное - x и y есть.

// А вот так нельзя:
// let p: Point = { x: 1 }; // Ошибка TS: Property 'y' is missing in type '{ x: number; }' but required in type 'Point'.
Критический взгляд и Нюансы:

Почему структурная? JavaScript сам по себе работает именно так. Если у объекта есть нужный метод, ты его вызываешь, не спрашивая "паспорт" (тип). TypeScript выбрал структурную типизацию, чтобы лучше соответствовать динамической природе JS и упростить постепенную типизацию существующих JS-проектов. Наложить строгую номинативную систему на JS было бы гораздо сложнее и менее естественно.
Фокус на "Что умеет", а не "Кто ты": Структурная типизация фокусируется на возможностях объекта (какие у него есть поля и методы), а не на его формальной идентичности (как он был объявлен). Это очень гибко.
Потенциальная Путаница: Разработчики из номинативных языков часто удивляются, когда два совершенно не связанных по замыслу типа оказываются совместимыми только из-за совпадения формы. Это может привести к логическим ошибкам, если ты случайно передал не тот объект, который ожидался семантически, но который подошел по структуре.
"Слабые" типы: Если интерфейс/тип содержит только необязательные свойства ({ a?: string, b?: number }), то любой объект (даже пустой {}) формально будет ему соответствовать. Это снижает безопасность в таких случаях.
Желание Номинативности: Иногда именно имя типа важно для семантики (например, UserID и ProductID могут быть оба строками, но мы не хотим их путать). Структурная типизация этого не обеспечивает. Для таких случаев в TS приходится эмулировать номинативное поведение (см. Тему #20 про Branded Types). Это показывает, что чисто структурный подход не всегда идеален.
Связь с Лишними Свойствами (Тема #9): TypeScript иногда отступает от чисто структурного подхода. При присвоении объектного литерала переменной с явным типом TS проверяет наличие лишних свойств, чтобы поймать опечатки. Это не часть структурной проверки, а дополнительная защита. let p: Point = { x: 1, y: 2, z: 3 }; // Ошибка!, но let temp = { x: 1, y: 2, z: 3 }; let p: Point = temp; // OK!.
Классы и private/protected: Хотя классы в основном подчиняются структурным правилам, наличие private или protected членов вносит элемент номинативности, так как проверяется происхождение этих членов из одного и того же объявления класса.
Итог по Теме #3:

Структурная типизация — это основополагающая черта TypeScript, отличающая его от многих других языков и сближающая с JavaScript. Она обеспечивает гибкость, фокусируясь на форме, а не на имени. Это нужно понимать, чтобы не удивляться "неожиданной" совместимости типов и осознавать как её преимущества, так и потенциальные недостатки (например, при работе со "слабыми" типами или когда важна семантика имени типа).

Готов перейти к Теме #4: interface vs type? Посмотрим, есть ли реальная разница, кроме синтаксиса.
