Тема #4 (React): Пропсы (Props) и Передача Данных (включая Подъем Состояния vs Prop Drilling)

Пропсы (от "properties") — это основной способ передачи данных в React, который строго следует принципу однонаправленного потока данных (one-way data flow).

1. Что такое Пропсы?

Данные Сверху Вниз: Пропсы — это данные, которые родительский компонент передает своим дочерним компонентам. Это как аргументы, передаваемые в функцию.
Доступ:
Функциональные Компоненты (FC): Получают объект props первым аргументом. Обычно используется деструктуризация для извлечения нужных значений.
TypeScript

interface GreetingProps {
  name: string;
  messageCount?: number; // Необязательный проп
}

// Деструктуризация прямо в параметрах
const Greeting: React.FC<GreetingProps> = ({ name, messageCount = 0 }) => {
  return <h1>Hello, {name}! You have {messageCount} messages.</h1>;
};

// Или традиционно:
// function Greeting(props: GreetingProps) {
//  const { name, messageCount = 0 } = props; ...
// }
Классовые Компоненты: Доступны через this.props.
TypeScript

class Welcome extends React.Component<{ name: string }> { // Типизация пропсов
  render() {
    // Доступ через this.props
    return <h1>Welcome, {this.props.name}</h1>;
  }
}
Передача в JSX: Используется синтаксис, похожий на HTML-атрибуты.
JavaScript

<Greeting name="Alice" messageCount={10} />
<Welcome name="Bob" />
<Greeting name={dynamicName} /> // Можно передавать переменные
props.children: Специальный проп, содержащий всё, что передано между открывающим и закрывающим тегами компонента. Позволяет создавать "обертки" и лэйауты.
JavaScript

function Card({ children }: React.PropsWithChildren) { // Типизация children
  return <div className="card">{children}</div>;
}
// Использование: <Card><p>Контент внутри карточки</p></Card>
2. Иммутабельность Пропсов – Священное Правило

Props are Read-Only: Компонент никогда не должен изменять свои собственные пропсы. Он должен рассматривать их как неизменяемые (immutable) данные, полученные от родителя.
Почему?
Предсказуемость: Гарантирует, что поток данных идет только в одном направлении (сверху вниз). Если бы дочерние компоненты могли менять пропсы, стало бы очень сложно отследить, откуда приходят данные и почему UI выглядит именно так.
Отладка: Упрощает поиск источника данных и ошибок.
Оптимизация: React может делать оптимизации (например, React.memo), основываясь на том, что если пропсы не изменились (сравнение по ссылке или значению), то компонент можно не рендерить заново. Мутация пропсов сломала бы эти оптимизации.
Что делать, если нужно изменить данные? Компонент должен либо:
Использовать пропсы для инициализации своего собственного состояния (useState).
Вызвать функцию-колбэк, переданную через пропсы от родителя, чтобы попросить родителя изменить данные у источника.
TS на страже: Использование Readonly<Props> или readonly модификаторов для свойств в interface/type помогает обеспечить неизменяемость на уровне типов во время компиляции.
TypeScript

interface MyProps { readonly user: { name: string }; } // Делаем user readonly
const Comp: React.FC<MyProps> = ({ user }) => {
  // user.name = "Hacker"; // ОШИБКА TS! Cannot assign to 'name' because it is a read-only property.
  return <div>{user.name}</div>
}
3. Общее Состояние: Подъем Состояния Вверх (Lifting State Up)

Проблема: Что если нескольким компонентам нужно отображать или изменять одни и те же данные? Где хранить это состояние?
Решение React: Найти ближайшего общего предка этих компонентов в дереве и поднять состояние в него. Этот предок будет хранить "единый источник правды" (single source of truth).
Механизм:
Состояние (useState, useReducer) объявляется в общем предке.
Предок передает значение состояния вниз дочерним компонентам через пропсы.
Предок передает функции для изменения состояния (например, setCount из useState или dispatch из useReducer) вниз через пропсы тем дочерним компонентам, которые должны инициировать изменения.
Пример: Два счетчика, которые должны показывать одно и то же значение.
TypeScript

function CounterDisplay({ count }) { return <p>Count is: {count}</p>; }
function CounterButton({ onClick }) { return <button onClick={onClick}>+1</button>; }

function ParentComponent() {
  const [count, setCount] = useState(0); // Состояние поднято в родителя

  const handleIncrement = () => setCount(c => c + 1);

  return (
    <div>
      {/* Передаем состояние и колбэк вниз через пропсы */}
      <CounterDisplay count={count} />
      <CounterButton onClick={handleIncrement} />
      <CounterDisplay count={count} /> {/* Второй тоже показывает актуальный count */}
    </div>
  );
}
Критический взгляд: "Подъем состояния" — основной и "правильный" способ управления общим состоянием в React без внешних библиотек. Он следует однонаправленному потоку данных и делает его предсказуемым.
4. Цена Подъема: Проброс Пропсов (Prop Drilling) (Противоречие #13)

Проблема: Когда состояние поднято очень высоко, а использовать его нужно компоненту, находящемуся очень глубоко в дереве, приходится передавать пропсы через все промежуточные компоненты, даже если они сами эти пропсы не используют. Это и называется "пробросом пропсов".
Пример: App -> Layout -> UserProfile -> UserAvatar (нужен user) — user придется передать через Layout и UserProfile.
Недостатки:
Многословность: Лишний код в промежуточных компонентах.
Сильная связанность: Промежуточные компоненты становятся зависимы от пропсов, которые им не нужны.
Сложность рефакторинга: Изменение формы пропсов или перенос компонента требует изменений на многих уровнях.
Критический взгляд: Prop Drilling — это естественное следствие паттерна "подъема состояния" и однонаправленного потока данных. Это компромисс. Небольшой проброс через 1-2 уровня — это нормально. Но глубокий проброс — это "code smell", указывающий, что, возможно, стоит применить другие техники.
Решения для Prop Drilling:
Композиция Компонентов: Передача children или других компонентов как пропсов (<Layout left={<Sidebar />} right={<Content />} />).
Context API (Тема #9): Позволяет передавать данные "напрямую" глубоко вложенным компонентам, минуя промежуточные.
Внешние библиотеки управления состоянием (Redux, Zustand и т.д.) (Тема #13 опционально).
5. Коммуникация Вверх: Функции-Колбэки в Пропсах

Как дочерний компонент сообщает родительскому об изменениях (например, клик кнопки, ввод в поле)? Через функции-колбэки, переданные от родителя как пропсы.
JavaScript

 // В родителе:
 const [name, setName] = useState('');
 const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
   setName(event.target.value);
 };
 return <ChildComponent onNameChange={handleNameChange} name={name} />;

 // В дочернем ChildComponent:
 function ChildComponent({ name, onNameChange }) {
   return <input type="text" value={name} onChange={onNameChange} />;
 }
Критический взгляд: Стандартный паттерн. Требует понимания функций первого класса и замыканий в JS (колбэк handleNameChange имеет доступ к setName). Важно использовать useCallback для мемоизации колбэков, передаваемых в мемоизированные дочерние компоненты, чтобы избежать лишних ре-рендеров.
Итог по Теме #4:

Пропсы — это механизм React для однонаправленной передачи данных от родителя к ребенку. Они иммутабельны для компонента-получателя. Для обмена состоянием используется подъем состояния в общего предка с передачей данных и колбэков через пропсы. Недостаток этого подхода — prop drilling, для борьбы с которым существуют композиция, Context API и внешние state managers. TypeScript сильно упрощает и обезопасивает работу с пропсами благодаря статической типизации.
