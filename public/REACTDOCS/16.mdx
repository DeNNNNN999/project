Тема #16 (React): Concurrent Mode / Асинхронный Рендеринг (React 18+)

(Примечание: Термин "Concurrent Mode" использовался раньше, сейчас чаще говорят о "Concurrent Features" или "Concurrent Rendering", которые включаются при использовании новых API React 18+).

1. Проблема: Блокирующий Рендеринг

Как было раньше: В предыдущих версиях React процесс рендеринга был синхронным и блокирующим. Если компонент начинал ре-рендериться (из-за изменения state или props), React должен был полностью завершить этот рендеринг (включая рендеринг всех дочерних компонентов), прежде чем он мог бы отреагировать на что-либо еще (например, на ввод пользователя в поле).
Последствия: На сложных страницах или медленных устройствах долгий рендеринг мог приводить к "зависанию" интерфейса, неотзывчивости на действия пользователя.
2. Идея Конкурентности (Concurrency)

Не Параллелизм: Важно понимать, что JS остается однопоточным. Конкурентность в React не означает выполнение рендеринга в нескольких потоках одновременно.
Прерываемый Рендеринг: Ключевая идея — рендеринг становится прерываемым. React может начать рендерить обновление, приостановить его, если появилось что-то более срочное (например, пользовательский ввод), обработать срочное обновление, а затем возобновить приостановленный рендеринг (или отбросить его, если он устарел).
Приоритезация: React может приоритизировать обновления. Срочные обновления (связанные с вводом пользователя) обрабатываются немедленно, а менее срочные (переход на новую страницу, фильтрация большого списка) могут быть отложены или прерваны.
Как включается: В React 18+ конкурентные фичи включаются автоматически при использовании нового корневого API createRoot (вместо ReactDOM.render) и при использовании специфичных API вроде startTransition.
3. Ключевые API и Концепции Конкурентного Рендеринга

Transitions (startTransition, useTransition):

Цель: Позволяют пометить обновления состояния как не срочные (transitions). React будет стараться не блокировать интерфейс во время рендеринга этих обновлений.
startTransition(callback): Функция, в которую оборачивается вызов setState или dispatch, чтобы пометить его как transition.
useTransition(): Хук, возвращающий [isPending, startTransition].
isPending (boolean): Указывает, выполняется ли в данный момент переход (полезно для отображения индикаторов загрузки/ожидания).
startTransition: Функция для обертки несрочных обновлений.
Пример (Фильтрация большого списка):
TypeScript

import React, { useState, useTransition } from 'react';

function FilterableList({ items }) {
  const [filter, setFilter] = useState('');
  // isPending - флаг, что переход (фильтрация списка) еще выполняется
  // startTransition - функция для обертки НЕСРОЧНОГО обновления
  const [isPending, startTransition] = useTransition();

  const filteredItems = items.filter(item => item.includes(filter));

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const nextFilter = event.target.value;
    // Обновление поля ввода - СРОЧНОЕ, делаем сразу
    setFilter(nextFilter);

    // Обновление списка может быть долгим, делаем его НЕСРОЧНЫМ (transition)
    // startTransition(() => {
    //    setFilteredListState(heavyFilter(items, nextFilter)); // Пример, если фильтрация в state
    // });
    // В данном простом примере список фильтруется при рендере,
    // но startTransition все равно нужен, если бы мы *отдельно* обновляли
    // состояние отфильтрованного списка. Сам факт вызова startTransition
    // помечает последующий рендер как transition.
  };

  return (
    <div>
      <input type="text" value={filter} onChange={handleChange} />
      {isPending && <p>Filtering...</p>}
      <ul>
        {/* Рендерим уже отфильтрованные элементы */}
        {filteredItems.map(item => <li key={item}>{item}</li>)}
      </ul>
    </div>
  );
}
Критический взгляд: Transitions — мощный инструмент для сохранения отзывчивости UI при выполнении "тяжелых" обновлений состояния/рендеринга. useTransition позволяет легко показывать пользователю состояние ожидания.
Отложенные Значения (useDeferredValue):

Цель: Позволяет отложить обновление части UI, которая зависит от быстро меняющегося значения, но не является критически важной для немедленного отображения.
Как работает: const deferredValue = useDeferredValue(value, { timeoutMs: 500 });. Хук возвращает "отложенную" версию value. Эта deferredValue будет "отставать" от value во время срочных обновлений. React сначала обновит UI с использованием value, а затем, когда будет время (в рамках transition или когда основной поток свободен), обновит UI с использованием deferredValue.
Применение: Отображение результатов поиска по мере ввода (поле ввода обновляется мгновенно, а список результатов — с небольшой задержкой, не блокируя ввод), отрисовка сложных графиков по меняющимся данным.
Пример (Концептуальный):
TypeScript

function SearchResults({ query }) {
  // Показываем старые результаты, пока новые не готовы (без блокировки ввода)
  const deferredQuery = useDeferredValue(query);

  // ExpensiveList рендерится с deferredQuery, обновление будет отложено
  const results = useMemo(() => <ExpensiveList query={deferredQuery} />, [deferredQuery]);

  return (
    <div>
      {/* Input обновляется сразу с 'query' */}
      <input value={query} onChange={...} />
      {/* Список обновляется позже с 'deferredQuery' */}
      {results}
    </div>
  );
}
Критический взгляд: useDeferredValue — тонкий инструмент для оптимизации. Он позволяет сохранить отзывчивость интерфейса ценой временного показа слегка устаревших данных в некритичных частях UI.
4. Сдвиг Парадигмы и Ментальной Модели (Противоречие #10)

Рендер Не Атомарен: Самое главное — привыкнуть, что рендеринг может быть прерван и возобновлен. Код ваших компонентов должен быть устойчив к этому.
Состояние "в Полете": Концептуально, во время конкурентного рендеринга может существовать несколько "версий" состояния.
useEffect и Очистка: Функции очистки в useEffect становятся еще важнее, так как эффект может быть прерван до завершения или запущен снова после возобновления рендеринга. Логика эффектов должна быть идемпотентной, насколько это возможно. React.StrictMode специально вызывает эффекты (и очистку) дважды в разработке, чтобы помочь выявить проблемы с этим.
Критический взгляд: Конкурентный рендеринг — это значительное усложнение ментальной модели React по сравнению с синхронным подходом. Он требует более глубокого понимания рендер-цикла и того, как писать "устойчивый" к прерываниям код. Для простых приложений он может быть излишним, но для сложных, интерактивных интерфейсов он открывает новые возможности для повышения производительности и UX.
5. Связь с Suspense:

Конкурентный рендеринг тесно связан с React.Suspense, особенно для асинхронной загрузки данных. React может "приостановить" рендеринг компонента, ожидающего данные, показать fallback из Suspense, заняться другими задачами и возобновить рендеринг, когда данные готовы.

Итог по Теме #16:

Конкурентные возможности React 18+ — это фундаментальный сдвиг, позволяющий создавать более отзывчивые и плавные интерфейсы за счет прерываемого рендеринга и приоритезации обновлений. Ключевые инструменты — startTransition/useTransition для несрочных обновлений и useDeferredValue для отложенного рендеринга частей UI. Это требует новой ментальной модели и более внимательного написания эффектов, но открывает путь к значительно лучшей производительности и UX в сложных приложениях.
