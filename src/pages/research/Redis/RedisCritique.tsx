import React from 'react';

const RedisCritique: React.FC = () => {
  return (
    <section id="critique" className="p-6 border rounded-lg bg-slate-800/40 border-slate-700/50 mb-6">
      <h2 className="mb-4 text-2xl font-semibold text-indigo-400">Критический Взгляд на Redis</h2>
      
      <div className="text-gray-300">
        <h3 className="text-lg font-semibold text-sky-400 mt-4 mb-2">Дуализм: База данных или кэш?</h3>
        <p className="mb-3">
          Redis занимает неоднозначную позицию между кэшем и базой данных. Хотя его можно использовать 
          как постоянное хранилище, подавляющее большинство сценариев использования в продакшн сводятся 
          к кэшированию, хранению сессий или временных данных. Это важно учитывать при проектировании 
          архитектуры - не стоит возлагать на Redis ответственность полноценной основной базы данных без 
          тщательного анализа последствий.
        </p>
        
        <h3 className="text-lg font-semibold text-sky-400 mt-4 mb-2">Ограничения in-memory архитектуры</h3>
        <p className="mb-3">
          Хранение всех данных в оперативной памяти - источник как сильных, так и слабых сторон Redis:
        </p>
        <ul className="list-disc pl-6 mb-4">
          <li><span className="text-red-400">Ограничение объема данных</span> - размер доступной RAM</li>
          <li><span className="text-red-400">Дороговизна масштабирования</span> - RAM стоит дороже дисковой памяти</li>
          <li><span className="text-red-400">Риск потери данных</span> при сбоях, если не настроена правильная стратегия персистентности</li>
        </ul>
        
        <h3 className="text-lg font-semibold text-sky-400 mt-4 mb-2">Компромиссы персистентности</h3>
        <p className="mb-3">
          Механизмы персистентности Redis имеют свои компромиссы:
        </p>
        <ul className="list-disc pl-6 mb-4">
          <li><strong className="text-violet-400">RDB</strong> - возможна потеря данных между снимками</li>
          <li><strong className="text-violet-400">AOF</strong> - медленнее и занимает больше места</li>
          <li>Реальные гарантии всегда ниже, чем у традиционных СУБД, ориентированных на ACID</li>
        </ul>
        
        <h3 className="text-lg font-semibold text-sky-400 mt-4 mb-2">Ограниченные возможности запросов</h3>
        <p className="mb-3">
          В отличие от SQL или даже NoSQL баз данных, Redis не предлагает гибкого языка запросов:
        </p>
        <ul className="list-disc pl-6 mb-4">
          <li>Доступ преимущественно по ключу, без сложных условий выборки</li>
          <li>Ограниченные возможности для агрегации данных (без Lua скриптов)</li>
          <li>Отсутствие индексов и оптимизатора запросов (кроме модуля RediSearch)</li>
        </ul>
        
        <h3 className="text-lg font-semibold text-sky-400 mt-4 mb-2">Трудности с моделированием сложных данных</h3>
        <p className="mb-3">
          Хотя Redis поддерживает сложные структуры данных, моделирование сложных отношений между данными может быть неудобным:
        </p>
        <ul className="list-disc pl-6 mb-4">
          <li>Необходимость вручную управлять связями между объектами</li>
          <li>Отсутствие транзакций с полными ACID-гарантиями</li>
          <li>Риск денормализации и дублирования данных</li>
        </ul>
        
        <h3 className="text-lg font-semibold text-sky-400 mt-4 mb-2">Заключение</h3>
        <p className="mb-3">
          Redis - исключительно мощный инструмент, когда используется по назначению: как 
          высокопроизводительный кэш, хранилище сессий, брокер сообщений для простых сценариев, 
          или решение специфических задач (рейтинги, счетчики, блокировки). Но не стоит пытаться 
          превратить его в полноценную замену основной базы данных, если ваш сценарий не подходит 
          под его специализацию.
        </p>
      </div>
    </section>
  );
};

export default RedisCritique;