import React from 'react'
// Можно добавить компонент для рендеринга кода, если нужно
// import CodeBlock from '@/components/UI/CodeBlock';

const JavaScriptCritique: React.FC = () => {
  return (
    <section id="critique" className="p-6 border rounded-lg bg-red-900/20 border-red-700/50">
      {' '}
      {/* Выделяем цветом */}
      <h2 className="mb-4 text-2xl font-semibold text-red-400">Критический Анализ и Противоречия JavaScript</h2>
      {/* Используем стили для текста, например, Tailwind Prose */}
      <div className="space-y-4 prose text-gray-300 prose-invert max-w-none">
        <p>
          JavaScript, несмотря на свою вездесущность и гибкость, несет в себе значительный багаж исторических
          компромиссов, дизайн-решений, вызывающих споры, и особенностей экосистемы, которые важно понимать для
          эффективной разработки. Критический взгляд позволяет использовать его сильные стороны осознанно и митигировать
          слабые.
        </p>

        {/* --- Подраздел 1 --- */}
        <div>
          <h3 className="text-xl text-red-300 !mb-2">Исторические "Странности" и Наследие</h3>
          <p>
            Язык создавался в спешке (легендарные "10 дней Брендана Эйха"), что привело к ряду известных "причуд",
            которые сохраняются ради обратной совместимости ("не сломать веб"):
          </p>
          <ul className="space-y-1 list-disc list-inside">
            <li>
              <strong>
                <code>typeof null === 'object'</code>
              </strong>
              : Признанная ошибка в спецификации, которая уже никогда не будет исправлена. Требует дополнительных
              проверок на `null`.
            </li>
            <li>
              <strong>Числа IEEE 754:</strong> Проблемы с точностью арифметики с плавающей запятой (
              <code>0.1 + 0.2 !== 0.3</code>). Критично для финансовых расчетов, требует использования `BigInt` или
              библиотек вроде `Decimal.js`.
            </li>
            <li>
              <strong>Неконсистентное приведение типов:</strong> Неявное приведение типов может приводить к совершенно
              неожиданным результатам (<code>[] + {}</code> vs <code>{} + []</code>). Подчеркивает необходимость
              использования строгого сравнения (<code>===</code> / <code>!==</code>) и явного преобразования типов.
            </li>
            <li>
              <strong>Название "JavaScript":</strong> Чисто маркетинговый ход для ассоциации с популярной тогда Java,
              хотя языки фундаментально разные по философии и реализации (прототипы vs классы, динамика vs статика).
            </li>
          </ul>
        </div>

        {/* --- Подраздел 2 --- */}
        <div>
          <h3 className="text-xl text-red-300 !mb-2">Противоречия Дизайна</h3>
          <p>Эволюция языка привела к сосуществованию разных, порой противоречивых, подходов:</p>
          <ul className="space-y-1 list-disc list-inside">
            <li>
              <strong>Прототипы vs Классы:</strong> Введение синтаксиса `class` в ES6 упростило ООП для многих, но под
              капотом остались прототипы. Непонимание этого может вести к ошибкам. Язык пытается выглядеть классовым, не
              являясь им по сути.
            </li>
            <li>
              <strong>ООП + Функциональный Стиль:</strong> JS позволяет писать и в императивном/ООП стиле, и в
              функциональном (функции высшего порядка, замыкания, неизменяемость). Эта гибкость мощна, но требует от
              разработчика дисциплины и понимания обоих подходов.
            </li>
            <li>
              <strong>Сложности с `this`:</strong> Контекст `this` определяется динамически в момент вызова (кроме
              стрелочных функций), что является постоянным источником ошибок для новичков и требует четкого понимания
              правил его определения.
            </li>
          </ul>
        </div>

        {/* --- Подраздел 3 --- */}
        <div>
          <h3 className="text-xl text-red-300 !mb-2">Экосистема и Практика</h3>
          <ul className="space-y-1 list-disc list-inside">
            <li>
              <strong>Эволюция асинхронности:</strong> От "ада колбэков" (callback hell) через Promises к `async/await`.
              Хотя `async/await` значительно улучшил читаемость, понимание его работы поверх Promise и Event Loop все
              еще необходимо.
            </li>
            <li>
              <strong>Модульные системы:</strong> Историческое отсутствие встроенных модулей, затем зоопарк (CommonJS,
              AMD, UMD), и наконец стандарт ESM. Совместимость и настройка сборщиков (Webpack, Vite) все еще могут быть
              нетривиальными.
            </li>
            <li>
              <strong>NPM и `node_modules`:</strong> Огромная экосистема пакетов — это и сила, и слабость. Проблемы "ада
              зависимостей", размер `node_modules`, безопасность пакетов (`left-pad` как символ).
            </li>
          </ul>
        </div>

        {/* --- Подраздел 4 --- */}
        <div>
          <h3 className="text-xl text-red-300 !mb-2">Философия Применения (Твой Взгляд)</h3>
          <p>Здесь ты излагаешь свои выводы:</p>
          <ul className="space-y-1 list-disc list-inside">
            <li>Когда и для каких задач JS подходит идеально, несмотря на недостатки?</li>
            <li>
              Какие практики (например, использование TypeScript, линтеров, строгих сравнений, функционального подхода,
              паттернов проектирования) помогают митигировать его проблемы?
            </li>
            <li>Почему, несмотря на все "странности", он остается доминирующим языком веба?</li>
            <li>
              Твое личное отношение: принимаешь ли ты его "как есть" или стремишься использовать более строгие или
              альтернативные подходы (PureScript, ReasonML, Elm)?
            </li>
          </ul>
        </div>
      </div>
    </section>
  )
}

export default JavaScriptCritique
