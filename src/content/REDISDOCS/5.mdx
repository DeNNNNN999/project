# Управление Памятью в Redis: maxmemory и Политики Вытеснения

## Введение: Когда RAM Заканчивается

Мы установили, что Redis — это хранилище данных в оперативной памяти. RAM быстрая, но она не бесконечна и стоит дороже дисков. Что произойдет, когда данные, которые вы пытаетесь записать в Redis, больше не помещаются в выделенный лимит памяти? В отличие от системы, которая просто упадет с ошибкой "Out of Memory", Redis имеет встроенные механизмы для управления этой ситуацией, главным образом через директиву **maxmemory** и **политики вытеснения** (eviction policies).

Именно эти политики определяют, какие данные будут принесены в жертву, чтобы освободить место для новых. Понимание того, как они работают (и как не работают), критически важно, особенно при использовании Redis в роли кэша, но эти детали часто упускаются из виду.

## Директива maxmemory

**Что это?** Основная настройка в redis.conf, которая задает максимальный объем оперативной памяти (в байтах), который Redis может использовать для хранения ваших данных (ключей и значений).

**Важно**: Этот лимит не включает память, используемую самим процессом Redis, буферами репликации, буферами клиентских соединений и т.д. Общее потребление памяти процессом Redis всегда будет больше, чем maxmemory.

**Значение по умолчанию**: На 64-битных системах по умолчанию часто 0, что означает "нет лимита". Это опасно! Redis будет потреблять память, пока она не кончится на сервере, что может привести к его падению или активации OOM Killer'а операционной системы, убивающего процесс Redis.

**Рекомендация**: Всегда устанавливайте явное значение maxmemory, оставляя достаточный запас памяти для нужд ОС, других процессов и собственных накладных расходов Redis (обычно рекомендуют оставлять 10-25% свободной RAM).

## Что Происходит при Достижении maxmemory?

Когда новая команда записи (`SET`, `LPUSH`, `HSET` и т.д.) должна привести к превышению лимита maxmemory, поведение Redis определяется настройкой **maxmemory-policy**:

### noeviction (Политика по умолчанию во многих версиях):

- Redis перестает выполнять все команды, которые увеличивают потребление памяти. На такие команды он возвращает клиенту ошибку (например, `OOM command not allowed when used memory > 'maxmemory'.`).
- Команды только для чтения (`GET`, `LRANGE` и т.п.) и команды удаления (`DEL`, `UNLINK`) продолжают работать нормально.

**Критический взгляд**: Это "безопасный" вариант — Redis не удаляет данные сам. Но если ваше приложение не готово обрабатывать ошибки записи, оно может фактически остановиться или работать некорректно. Требует активного мониторинга и ручного или автоматического вмешательства (удаление старых данных, масштабирование).

### Политики с Вытеснением (Eviction):

Redis пытается удалить ("вытеснить") некоторые существующие ключи согласно выбранной стратегии, чтобы освободить достаточно места для выполнения новой команды записи. Если ему удается освободить место, команда выполняется успешно.

---

## Политики Вытеснения: Кого Выгоняем?

Вот основные стратегии, по которым Redis решает, какие ключи удалить:

- **allkeys-lru**: Вытесняет наименее недавно использовавшиеся (Least Recently Used) ключи из всех ключей. Подходит для общего кэширования.

- **volatile-lru**: Как allkeys-lru, но выбирает только среди ключей, у которых установлен TTL (срок жизни). Полезна, если вы хотите сохранить важные "вечные" ключи, а вытеснять только временные.

- **allkeys-random**: Вытесняет случайные ключи из всех ключей. Может быть полезна, если все ключи примерно равноценны и доступ к ним случаен. Меньше нагрузка на CPU, чем у LRU/LFU.

- **volatile-random**: Вытесняет случайные ключи, но только среди тех, у которых установлен TTL.

- **volatile-ttl**: Вытесняет ключи с установленным TTL, отдавая предпочтение тем, у которых осталось меньше всего времени жизни. Логично для удаления того, что и так скоро исчезнет.

- **allkeys-lfu** (с Redis 4.0): Вытесняет наименее часто использовавшиеся (Least Frequently Used) ключи из всех ключей. Полезна, если есть ключи, к которым обращаются часто, но не обязательно недавно — LFU постарается их сохранить.

- **volatile-lfu** (с Redis 4.0): Как allkeys-lfu, но выбирает только среди ключей с TTL.

## Критический Взгляд на LRU и LFU: Они "Приблизительные"!

Это важнейший нюанс, который часто упускают: реализации LRU и LFU в Redis не являются точными.

**Почему?** Отслеживание точного времени последнего доступа (LRU) или точной частоты доступа (LFU) для каждого ключа при каждом обращении требует значительных вычислительных ресурсов и памяти, что противоречит философии Redis о максимальной скорости.

**Как работает Redis?** Он использует алгоритм на основе сэмплирования (выборки). Когда нужно вытеснить ключ:

1. Redis выбирает небольшое случайное подмножество ключей (размер выборки задается **maxmemory-samples**, по умолчанию 5).
2. Среди этих 5 ключей он находит "наихудший" по выбранной метрике (самый старый доступ для LRU, самый низкий счетчик частоты для LFU).
3. Именно этот "локально наихудший" ключ из выборки и вытесняется.

**Последствия**: Это приблизительный LRU/LFU. Он статистически стремится удалять старые/нечастые ключи, но не гарантирует, что будет удален абсолютно самый старый или самый нечастый ключ во всем Redis. На практике это часто работает "достаточно хорошо", но может приводить к преждевременному вытеснению нужных данных, если "не повезло" с выборкой. Точность можно немного повысить, увеличив maxmemory-samples, но это увеличит нагрузку на CPU при вытеснении.

**Нюансы LFU**: У LFU есть дополнительные настройки (**lfu-log-factor**, **lfu-decay-time**), определяющие, как быстро растет и "затухает" счетчик частоты доступа. Неправильная настройка может привести к тому, что давно не используемые, но когда-то очень популярные ключи будут сохраняться слишком долго, или наоборот.

---

## Выбор Политики: Что Подходит Вам?

Выбор maxmemory-policy зависит от вашей задачи:

- **noeviction**: Если потеря данных недопустима. Требует внешнего контроля за памятью.
- **allkeys-lru**: Хороший стандарт для кэшей общего назначения.
- **volatile-lru**: Если нужно защитить "вечные" ключи и вытеснять только временные (с TTL).
- **allkeys-lfu / volatile-lfu**: Если важно сохранить часто используемые ключи, даже если к ним обращались не только что. Требует большего понимания и возможной подстройки.
- **volatile-ttl**: Логична для удаления "почти истекших" ключей в первую очередь.
- ***-random**: Самые простые, но могут вытеснить важные данные. Используются редко.

## Мониторинг — Обязателен!

Независимо от выбранной политики, критически важно отслеживать:

- Использование памяти (`INFO memory -> used_memory, used_memory_peak`).
- Количество вытесненных ключей (`INFO stats -> evicted_keys`).
- Количество ключей с истекшим TTL (`expired_keys`).
- Процент попаданий в кэш (`keyspace_hits`, `keyspace_misses`).

Это поможет понять, достаточно ли у вас maxmemory, эффективно ли работает политика вытеснения, и не теряете ли вы слишком много нужных данных.

## Итог

Механизм maxmemory и политики вытеснения — это неотъемлемая часть работы с Redis как с хранилищем, ограниченным оперативной памятью. Выбор политики должен быть осознанным, основанным на требованиях к сохранности данных и паттернах доступа.

Помните, что популярные LRU/LFU являются приблизительными из-за сэмплирования. Не забывайте про мониторинг использования памяти и эффективности вытеснения.
