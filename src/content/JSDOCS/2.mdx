# Переменные и Область видимости (Scope) в JavaScript

Казалось бы, что может быть проще переменных? Но в JS эта тема полна исторических артефактов и неочевидных моментов, особенно если смотреть на эволюцию от var к let и const.

## 1. var – Динозавр с функциональной пропиской и "поднятием"

### Почему var такой "странный"? Область видимости – функция, не блок!

В отличие от большинства C-подобных языков (C++, Java, C#), где переменные обычно ограничены ближайшими фигурными скобками {}, переменные, объявленные через var, игнорируют блоки (if, for, while) и видны во всей функции, в которой они объявлены (или в глобальной области, если вне функции).

Как это проявляется (классика):

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // Выведет 3, 3, 3
  }, 100);
}
// Почему? Потому что `var i` одна на всю область видимости (глобальную или функциональную).
// К моменту срабатывания `setTimeout`, цикл уже завершился, и `i` стала равна 3.
// Все три функции `setTimeout` замыкают *одну и ту же* переменную `i`.
```

**Критический взгляд**: Такое поведение крайне контринтуитивно для новичков и является источником трудноуловимых багов. Почему так сделали? Возможно, для упрощения первой реализации интерпретатора или под влиянием языков с динамической областью видимости (хотя JS использует лексическую). Факт в том, что это дизайн, который со временем признали неудачным.

### "Поднятие" (Hoisting) var – Объявления всплывают, инициализация тонет:

**Как работает**: Интерпретатор JS концептуально "поднимает" объявления var (и function declaration) в начало их области видимости (функциональной или глобальной) во время фазы компиляции (еще до выполнения кода). Однако присваивание значения (= ...) остается на своем месте.

Пример:

```javascript
console.log(myVar); // Выведет undefined (не ReferenceError!)
var myVar = 10;
console.log(myVar); // Выведет 10

// Как это "видит" интерпретатор (концептуально):
// var myVar; // Объявление поднято
// console.log(myVar); // -> undefined
// myVar = 10; // Присваивание осталось на месте
// console.log(myVar); // -> 10
```

**Почему hoisting?** Точных причин мало, но вероятно, это упрощало реализацию однопроходных интерпретаторов или позволяло использовать функции до их формального объявления в коде (что удобно).

**Критический взгляд**: Hoisting var — еще одна ловушка. Возможность использовать переменную до ее объявления (пусть и со значением undefined) маскирует ошибки и ухудшает читаемость кода.

### Неявные Глобалы – Опасная Ловушка:

Если внутри функции присвоить значение переменной, не объявляя ее через var (или let/const), JS создаст глобальную переменную (или выдаст ошибку в strict mode).

```javascript
function setGlobal() {
  myGlobalVar = "I'm global!"; // Опасно! Создаст window.myGlobalVar в браузере
}
setGlobal();
console.log(myGlobalVar); // "I'm global!"
```

**Критический взгляд**: Это одна из самых опасных особенностей "старого" JS, приводящая к загрязнению глобального пространства имен и трудноуловимым конфликтам. Режим 'use strict'; частично решает проблему, запрещая такое поведение.

## 2. let и const (ES6) – Работа над ошибками

Появление let и const в ES6 (ES2015) было прямым ответом на проблемы var.

### Блочная область видимости – Наконец-то!

Переменные, объявленные через let и const, видны только внутри блока ({}), в котором они объявлены (включая блоки if, for, while).

Как это решает проблему с циклом:

```javascript
for (let i = 0; i < 3; i++) { // (!) let
  // На каждой итерации создается НОВАЯ переменная `i` со своей областью видимости!
  setTimeout(function() {
    console.log(i); // Выведет 0, 1, 2
  }, 100);
}
```

**Критический взгляд**: Это сделало JS более предсказуемым и похожим на другие языки, значительно снизив количество ошибок, связанных со scope.

### const – Не совсем "константа", а неизменяемая привязка

- const тоже имеет блочную область видимости.
- Главное отличие от let: переменной const нужно сразу присвоить значение, и ей нельзя переприсвоить другое значение (`const x = 5; x = 10; // TypeError`).
- Важнейший нюанс: const не делает сам объект или массив неизменяемым (immutable)! Он запрещает только переприсвоить самой переменной ссылку на другой объект/массив.

```javascript
const myArr = [1, 2];
myArr.push(3); // OK! Массив изменился: [1, 2, 3]
myArr[0] = 99; // OK! Массив изменился: [99, 2, 3]
// myArr = [4, 5]; // НЕЛЬЗЯ! TypeError: Assignment to constant variable.
```

**Почему const?** Поощряет стиль программирования с меньшим количеством переприсваиваний, что делает код легче для понимания. Если переменная не должна менять свое значение/ссылку, лучше использовать const.

### Hoisting let/const и TDZ (Temporal Dead Zone – Временная Мертвая Зона):

**Как работает**: let и const тоже "поднимаются" (движок знает о них с начала блока), но они не инициализируются значением undefined, как var. Вместо этого они попадают во "временную мертвую зону" от начала блока до строки их объявления (let x). Попытка доступа к переменной в TDZ вызывает ReferenceError.

```javascript
console.log(a); // ReferenceError: Cannot access 'a' before initialization
let a = 5;
```

**Почему TDZ?** Это сделано намеренно, чтобы предотвратить использование переменных до их объявления, делая код более строгим и безопасным по сравнению с var. Ошибка лучше, чем undefined.

## 3. Глобальная область видимости – Общее пространство (и проблемы)

**Как создается**: Переменные, объявленные вне любых функций (и модулей) с помощью var, let или const.

**Браузер vs Node.js**:
- **Браузер**: Глобальные переменные var становятся свойствами глобального объекта window (`var x = 1; console.log(window.x); // 1`). let и const тоже глобальны, но не становятся свойствами window.
- **Node.js**: Верхний уровень файла — это модульная область видимости, а не глобальная в том же смысле, что в браузере. Переменные модуля не попадают автоматически в объект global.

**Критический взгляд**: Глобальная область — источник конфликтов имен между разными скриптами, библиотеками и встроенными API браузера/Node.js. Современные практики (модули ES6, замыкания, IIFE в прошлом) направлены на минимизацию использования глобальных переменных.

## Итог по Scope и Переменным:

Эволюция от var к let/const — это яркий пример того, как JavaScript повзрослел, признал ошибки дизайна и внедрил более строгие, предсказуемые и безопасные механизмы работы с переменными и их областями видимости. Понимание "старого" var все еще важно (для legacy кода, собеседований), но современный JS стал значительно лучше благодаря блочной области видимости и TDZ.
