# Функции в JavaScript

Функции в JS — это не просто блоки кода, это объекты первого класса. Это означает, что их можно присваивать переменным, передавать как аргументы другим функциям, возвращать из функций — они ведут себя как любые другие значения (объекты). Это основа функционального программирования в JS и источник его гибкости.

## 1. Способы Создания Функций: Ключевые Различия

Существуют три основных способа (и один нерекомендуемый):

### Function Declaration (FD) – Классическое Объявление:

```javascript
console.log(declaredFunc()); // OK: "Declared!" (из-за hoisting)

function declaredFunc() {
  return "Declared!";
}

// Нельзя объявить условно (в старых движках вело себя непредсказуемо)
// if (true) {
//   function conditional() {} // В строгом режиме ('use strict') - ошибка, без него - разное поведение
// }
```

**Особенность**: Полностью поднимается (hoisted). И имя функции, и её тело "поднимаются" в начало своей области видимости. Поэтому можно вызвать функцию до её объявления в коде.

**Критический взгляд**: Hoisting FD удобен для организации кода (можно размещать вспомогательные функции в конце файла), но может приводить к менее очевидному потоку выполнения. Использование FD внутри блоков (if, for) не рекомендуется из-за исторических проблем с кросс-браузерной совместимостью и не всегда интуитивным поведением; используйте Function Expression с let/const для условного создания функций.

### Function Expression (FE) – Выражение-Функция:

```javascript
// console.log(expressedFunc()); // ОШИБКА! TypeError: expressedFunc is not a function (или ReferenceError если let/const)

var expressedFuncVar = function() { // Переменная поднимается (undefined), но функция - нет
  return "Expressed with var!";
};

let expressedFuncLet = function optionalName() { // Имя optionalName видно только внутри функции
  // console.log(optionalName); // Работает
  return "Expressed with let!";
};
// console.log(optionalName); // ОШИБКА! ReferenceError

console.log(expressedFuncVar()); // OK
console.log(expressedFuncLet()); // OK

// Можно объявлять условно
let conditionalFunc;
if (true) {
  conditionalFunc = function() { return "Conditional"; };
}
console.log(conditionalFunc()); // OK
```

**Особенность**:
- Функция создается как часть выражения (обычно присваивания). Hoisting не применяется к телу функции. Если используется var, переменная поднимается со значением undefined. Если let/const — переменная попадает в TDZ до строки присваивания.
- **Именованные FE (NFE)**: Когда у функции-выражения есть имя (`optionalName` в примере). Это имя доступно только внутри самой функции (полезно для рекурсии или отладки), но не снаружи.

**Критический взгляд**: FE более гибкие, чем FD. Идеальны для колбэков, IIFE, методов объектов, условного создания функций. Отсутствие hoisting тела функции делает код более предсказуемым (нельзя использовать до присваивания).

### Arrow Functions (AF, =>) (ES6) – Лексический this и Краткость:

```javascript
const arrowFunc = (a, b) => a + b; // Неявный return

const complexArrow = (x) => { // Нужен явный return
  const y = x * 2;
  return y;
};

// Главная особенность - `this`
const myObject = {
  value: 42,
  getValueFunc: function() {
    // 'this' здесь - это myObject
    setTimeout(function() {
      // 'this' здесь - window/global или undefined (в strict mode)! Потерян контекст.
      // console.log(this.value); // Ошибка или undefined
    }, 100);

    setTimeout(() => {
      // 'this' здесь - это myObject! Стрелочная функция берет 'this' из окружающего контекста (getValueFunc)
      console.log("Arrow this:", this.value); // 42
    }, 100);
  },
  // Не подходит для методов, где нужен динамический this
  // getValueArrow: () => {
  //   // 'this' здесь будет взят из того места, где ОБЪЕКТ был создан,
  //   // а не из самого объекта myObject! Скорее всего, window/global/undefined.
  //   console.log(this.value); // Не то, что ожидаем
  // }
};
myObject.getValueFunc();
```

**Особенности**:
- **Лексический this**: Не имеют своего this. Значение this берется из окружающей области видимости в момент определения функции, а не в момент вызова. Это решает 90% проблем с this в колбэках, setTimeout, addEventListener.
- **Нет arguments**: Вместо псевдо-массива arguments используйте rest параметры (...args).
- **Не конструкторы**: Нельзя вызывать с new. У них нет свойства prototype.
- **Краткий синтаксис**: Особенно для однострочных функций с неявным возвратом (=> expression).

**Критический взгляд**: Стрелочные функции — огромное улучшение для многих сценариев, особенно асинхронных и функциональных. Понимание лексического this критически важно. Однако они не заменяют обычные функции полностью: они не подходят для методов объектов, где нужен динамический this, и для функций-конструкторов.

### new Function(...) – Опасный Конструктор:

```javascript
// ТАК ДЕЛАТЬ НЕ НАДО!
let sum = new Function('a', 'b', 'return a + b');
console.log(sum(2, 3)); // 5

let localVar = 10;
let dynamicFunc = new Function('console.log(localVar)');
// dynamicFunc(); // ОШИБКА! ReferenceError: localVar is not defined
               // (Доступ есть только к глобальным переменным)
```

**Особенности**: Создает функцию из строки кода.

**Критический взгляд**: Избегайте его использования!
- **Безопасность**: Выполнение кода из строки — это как eval(), огромная дыра в безопасности, если строка приходит извне.
- **Производительность**: Движок не может оптимизировать эту функцию при парсинге, она компилируется во время выполнения.
- **Область видимости**: Функция видит только глобальную область видимости, а не ту, где она была создана (localVar не виден).

## 2. Параметры и Аргументы

### arguments (Псевдо-массив):

```javascript
function showArgs() {
  console.log(arguments); // Выглядит как массив, но не массив!
  console.log(arguments.length);
  // arguments.forEach(el => console.log(el)); // ОШИБКА! arguments.forEach is not a function
  Array.from(arguments).forEach(el => console.log(el)); // OK, после преобразования
}
showArgs(1, "hello", true);
```

- Доступен внутри обычных функций (не стрелочных!).
- Содержит все переданные аргументы.
- Не является настоящим массивом! Нет методов map, filter и т.д.

**Критический взгляд**: Неудобен и почти полностью вытеснен rest параметрами. Используйте его только при работе с очень старым кодом.

### Rest Параметры (...) (ES6):

```javascript
function sumAll(...numbers) { // numbers - это НАСТОЯЩИЙ массив
  return numbers.reduce((sum, current) => sum + current, 0);
}
console.log(sumAll(1, 2, 3, 4)); // 10
```

Собирает оставшиеся аргументы в настоящий массив. Гораздо удобнее и понятнее.

### Параметры по Умолчанию (ES6):

```javascript
function greet(name = "Anonymous") {
  console.log(`Hello, ${name}!`);
}
greet("Alice"); // Hello, Alice!
greet(); // Hello, Anonymous!
greet(undefined); // Hello, Anonymous!
greet(null); // Hello, null! (Важно: `null` не заменяется дефолтом)
```

Гораздо чище старого `name = name || "Anonymous"` (который ломался на 0 или "").

## 3. IIFE (Immediately Invoked Function Expression) – Самовызывающиеся Функции

```javascript
(function() {
  // Этот код выполняется немедленно
  let message = "Secret message"; // Эта переменная локальна, не загрязняет global scope
  console.log(message);
})();
// console.log(message); // ОШИБКА! ReferenceError: message is not defined
```

**Как работает**: Функция оборачивается в скобки `()` и тут же вызывается `()`.

**Зачем?** Основная цель исторически — создать изолированную область видимости, чтобы переменные внутри не "утекли" в глобальную область. До появления let/const и модулей ES6 это был главный способ инкапсуляции.

**Критический взгляд**: В современном JS с модулями и блочной областью видимости нужда в IIFE сильно уменьшилась, но они все еще встречаются (особенно в скриптах сборки или старом коде) и полезны для понимания истории развития JS.

## Итог по Функциям:

Функции — сердце JS. Понимание разницы между FD, FE и AF (особенно в части hoisting и this), умение работать с параметрами (rest, default) и осознание роли функций как объектов первого класса — это абсолютно необходимая база. Современные возможности (стрелочные функции, rest-параметры) сделали работу с функциями гораздо удобнее и безопаснее, чем раньше.
