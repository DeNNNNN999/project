# Основные Концепции Функционального Программирования в JS

Важно понимать: JavaScript — не чисто функциональный язык (как Haskell), но он обладает всеми необходимыми возможностями (функции первого класса, замыкания), чтобы писать код в функциональном стиле. Этот стиль — не фреймворк, а парадигма, набор принципов и подходов к написанию кода.

Зачем это нужно? Основные цели ФП — повышение предсказуемости, тестируемости и надежности кода за счет минимизации изменяемого состояния и побочных эффектов.

Давай разберем ключевые концепции с примерами и критическим взглядом:

## 1. Чистые Функции (Pure Functions)

**Что это?** Функция считается "чистой", если она удовлетворяет двум условиям:
- **Детерминизм**: Для одних и тех же входных данных она всегда возвращает один и тот же результат.
- **Отсутствие побочных эффектов (Side Effects)**: Она не изменяет никаких внешних переменных или состояний (не меняет свои аргументы, если это объекты/массивы, не пишет в DOM, не выводит в консоль, не делает HTTP-запросы и т.д.). Она просто вычисляет и возвращает результат.

### Примеры:

```javascript
// Чистая функция
function sum(a, b) {
  return a + b;
}
console.log(sum(2, 3)); // Всегда 5
console.log(sum(2, 3)); // Всегда 5

// --- Нечистые функции ---

// 1. Имеет побочный эффект (изменяет внешнюю переменную)
let globalCounter = 0;
function incrementGlobal() {
  globalCounter++; // Побочный эффект!
  return globalCounter;
}
console.log(incrementGlobal()); // 1
console.log(incrementGlobal()); // 2 (Результат зависит от предыдущих вызовов)

// 2. Недетерминированная (зависит от внешнего изменяемого состояния)
function getGreeting(name) {
  // Зависит от Date(), который меняется со временем
  return `Hello, ${name}! Time is ${new Date().toLocaleTimeString()}`;
}
console.log(getGreeting("Alice")); // Результат будет разным при каждом вызове

// 3. Имеет побочный эффект (модифицирует аргумент-объект)
function addUserProp(user) {
  user.isAdmin = true; // Побочный эффект! Изменяет переданный объект.
  return user;
}
let user = { name: "Bob" };
addUserProp(user);
console.log(user); // { name: 'Bob', isAdmin: true } - Оригинал изменен!
```

**Критический взгляд**: Чистота — это идеал. Реальные приложения не могут существовать без побочных эффектов (нужно же что-то показать пользователю, сохранить данные!). Парадигма ФП не запрещает их полностью, а призывает максимально изолировать их: выделить в отдельные модули, выполнять на "границах" приложения (в обработчиках событий, хуках эффектов и т.д.), а основную логику обработки данных строить на чистых функциях. Почему? Чистые функции легко тестировать (не нужен сложный setup/teardown), их легко понимать (результат зависит только от входов), их результаты можно кешировать (мемоизировать).

## 2. Иммутабельность (Immutability)

**Что это?** Принцип, согласно которому данные (особенно объекты и массивы) не должны изменяться после их создания. Вместо модификации старых данных нужно создавать новые копии с внесенными изменениями.

- **Примитивы уже иммутабельны**: Как мы обсуждали, строки, числа и т.д. в JS неизменяемы.
- **Проблема с Объектами/Массивами**: Они по умолчанию мутабельны.

```javascript
// Мутабельный подход (ПЛОХО в ФП)
function addItemToArrayMutating(arr, item) {
  arr.push(item); // Изменяет оригинальный массив!
  return arr;
}
let nums1 = [1, 2];
addItemToArrayMutating(nums1, 3);
console.log(nums1); // [1, 2, 3] - Оригинал изменен!
```

### Как достичь иммутабельности (ХОРОШО в ФП):

```javascript
// 1. Массивы: spread-оператор, concat, slice, map, filter, reduce, toSorted и др.
function addItemToArrayImmutable(arr, item) {
  // return arr.concat([item]); // Старый способ
  return [...arr, item]; // Современный способ - создает новый массив
}
let nums2 = [1, 2];
let nums3 = addItemToArrayImmutable(nums2, 3);
console.log(nums2); // [1, 2] - Оригинал НЕ изменен!
console.log(nums3); // [1, 2, 3] - Новый массив
console.log(nums2 === nums3); // false

// 2. Объекты: spread-оператор, Object.assign()
function updateUserAgeImmutable(user, newAge) {
  // return Object.assign({}, user, { age: newAge }); // Старый способ
  return { ...user, age: newAge }; // Создает новый объект
}
let user1 = { name: "Charlie", age: 30 };
let user2 = updateUserAgeImmutable(user1, 31);
console.log(user1); // { name: 'Charlie', age: 30 } - Оригинал НЕ изменен!
console.log(user2); // { name: 'Charlie', age: 31 } - Новый объект
console.log(user1 === user2); // false
```

**Критический взгляд**: Иммутабельность — краеугольный камень современного фронтенда (React, Redux, Vuex и т.д.). Она делает управление состоянием предсказуемым и отслеживаемым. Легко понять, когда и как данные изменились, потому что любое изменение создает новую ссылку. Это упрощает отладку (time-travel debugging) и оптимизацию рендеринга (проверка изменения по ссылке быстрее глубокого сравнения). Да, создание новых объектов/массивов имеет свою цену, но движки JS хорошо это оптимизируют, а для сложных структур есть библиотеки (Immer.js), упрощающие иммутабельные обновления. Переход на иммутабельность требует изменения мышления, но дает огромные преимущества в сложных приложениях.

## 3. Побочные Эффекты (Side Effects) – Контролировать, а не Исключать

**Что это (повторим)**: Любое взаимодействие функции с внешним миром (изменение внешних переменных, DOM, console.log, сеть, localStorage и т.д.).

**Критический взгляд**: ФП не ставит целью полностью избавиться от побочных эффектов — это невозможно. Цель — локализовать и контролировать их. Отделить чистую логику вычислений от "грязной" работы с внешним миром. Это делает основную часть кода чистой, тестируемой и предсказуемой.

## 4. Функции Высшего Порядка (Higher-Order Functions - HOFs)

**Что это (повторим)**: Функции, которые либо принимают другие функции как аргументы, либо возвращают функции как результат (или и то, и другое).

**Примеры**: `Array.prototype.map`, `.filter`, `.reduce`, `functionReturningFunc = () => () => {}`, `element.addEventListener('click', myFunc)`.

**Критический взгляд**: HOFs — это клей, который соединяет маленькие чистые функции в более сложные конструкции в ФП. Они позволяют абстрагировать и переиспользовать паттерны поведения (итерация, трансформация, фильтрация).

## 5. Композиция Функций (Function Composition)

**Что это?** Процесс объединения двух или более функций для создания новой функции, где результат одной передается на вход другой. Математически: `compose(f, g)(x) = f(g(x))`.

### Пример:

```javascript
const getName = (person) => person.name;
const makeUpperCase = (str) => str.toUpperCase();
const getInitial = (str) => str[0];

// Хотим получить первую букву имени в верхнем регистре
const person = { name: "alice" };

// Ручная композиция (читается изнутри наружу)
const initialManual = getInitial(makeUpperCase(getName(person)));
console.log(initialManual); // "A"

// С помощью утилиты `pipe` (или `compose`) - выполняется слева направо
// Представим, что есть функция pipe: const pipe = (...fns) => (x) => fns.reduce((v, f) => f(v), x);
// const getUpperInitial = pipe(getName, makeUpperCase, getInitial);
// console.log(getUpperInitial(person)); // "A"
// Комментарий: Пока не будем углубляться в реализацию pipe/compose
```

**Критический взгляд**: Композиция позволяет строить сложные потоки обработки данных из мелких, независимых, часто чистых и тестируемых функций. Это приводит к более декларативному и читаемому коду (особенно в point-free стиле, хотя он может быть и сложен для понимания). Основа многих ФП-библиотек.

## 6. Каррирование (Currying)

**Что это?** Трансформация функции с несколькими аргументами (`f(a, b, c)`) в последовательность вложенных функций, каждая из которых принимает один аргумент (`f(a)(b)(c)`).

**Как работает**: Использует замыкания. Каждая вызванная функция возвращает новую функцию, которая "помнит" предыдущие аргументы.

### Пример:

```javascript
// Обычная функция
const multiply = (a, b, c) => a * b * c;

// Каррированная вручную
const curryMultiply = a => b => c => a * b * c;
// или более явно:
// function curryMultiply(a) {
//   return function(b) {
//     return function(c) {
//       return a * b * c;
//     }
//   }
// }

console.log(multiply(2, 3, 4)); // 24
console.log(curryMultiply(2)(3)(4)); // 24

// Польза: Легкое создание частично примененных функций
const multiplyBy6 = curryMultiply(2)(3); // Помнит a=2, b=3. Ждет c.
console.log(multiplyBy6(4)); // 24
console.log(multiplyBy6(5)); // 30
```

**Критический взгляд**: Каррирование кажется экзотикой, но оно тесно связано с частичным применением и очень удобно для композиции функций, так как все функции в цепочке становятся унарными (принимают один аргумент). Многие ФП-библиотеки предоставляют функцию `curry` для автоматического каррирования.

## 7. Частичное Применение (Partial Application)

**Что это?** Фиксация нескольких начальных аргументов функции, возвращая новую функцию, которая принимает оставшиеся аргументы. Отличается от каррирования тем, что не обязательно разбивает на функции с одним аргументом.

### Пример (bind):

```javascript
function greet(greeting, punctuation, name) {
  console.log(`${greeting}, ${name}${punctuation}`);
}

// Фиксируем первые два аргумента
const greetHelloExcitedly = greet.bind(null, "Hello", "!");
// this = null, greeting = "Hello", punctuation = "!"

greetHelloExcitedly("World"); // Hello, World!
greetHelloExcitedly("Universe"); // Hello, Universe!
```

### Пример (замыкание):

```javascript
function createAdder(a) { // Фиксируем 'a'
  return function(b) { // Принимаем оставшийся 'b'
    return a + b;
  };
}
const add5 = createAdder(5);
console.log(add5(10)); // 15
```

**Критический взгляд**: Чрезвычайно полезная техника для создания специализированных функций из более общих, уменьшения дублирования кода и повышения читаемости.

## Итог по ФП:

Функциональный стиль в JS — это не догма, а набор мощных инструментов и принципов. Применение чистых функций, иммутабельности, композиции и других техник может сделать ваш код значительно более предсказуемым, тестируемым и легким для понимания, особенно в сложных приложениях. Понимание этих концепций — ключ к эффективному использованию современных библиотек и фреймворков, таких как React.
