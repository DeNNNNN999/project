# Итераторы и Генераторы

До ES6 (ES2015) в JavaScript не было единого стандартного способа перебирать различные структуры данных (кроме простого for с индексами для массивов и коварного for...in для объектов). Итераторы и генераторы ввели протоколы и инструменты для унифицированного и гибкого обхода элементов.

## 1. Протоколы Итерации – Стандартный Контракт

Это два соглашения (протокола), которые определяют, как объект может быть перебираемым и как происходит сам процесс перебора:

### Протокол Итерируемости (Iterable Protocol):

- **Что делает объект итерируемым?** Наличие специального метода с ключом `Symbol.iterator`.
- **Что должен делать obj[Symbol.iterator]()?** Эта функция (вызываемая без аргументов) должна возвращать объект-итератор (см. следующий протокол).
- **Кто уже итерируемый?** Встроенные типы: Array, String, Map, Set, TypedArray, NodeList (в браузере), arguments. Важно: Обычные объекты `{}` по умолчанию не итерируемы.

#### Пример (Сделать объект итерируемым):

```javascript
let range = {
  from: 1,
  to: 5,

  // 1. Реализуем Symbol.iterator
  [Symbol.iterator]() {
    // Он должен вернуть объект-итератор
    let current = this.from;
    let last = this.to;

    // 2. Итератор с методом next()
    return {
      next() {
        if (current <= last) {
          return { done: false, value: current++ }; // Возвращаем текущее значение
        } else {
          return { done: true }; // Итерация завершена
        }
      }
    };
  }
};

// Теперь range можно использовать в for..of!
for (let num of range) {
  console.log(num); // 1, 2, 3, 4, 5
}

console.log([...range]); // [ 1, 2, 3, 4, 5 ] (Работает со spread)
```

### Протокол Итератора (Iterator Protocol):

- **Что такое итератор?** Любой объект, имеющий метод `next()`.
- **Что должен делать iterator.next()?** Вызывается без аргументов и возвращает объект вида `{ value: ..., done: ... }`:
  - `value`: Следующее значение в последовательности (может отсутствовать, если done: true).
  - `done`: false, если итератор вернул следующее значение; true, если последовательность закончилась.

### Кто использует эти протоколы?

- **for...of**: Основной потребитель. Автоматически вызывает Symbol.iterator, затем вызывает next() на каждой итерации и извлекает value, пока done не станет true.
- **Spread синтаксис (...)**: `let arr = [...iterable];`
- **Деструктуризация**: `let [a, b] = iterable;`
- **Array.from(iterable)**
- Конструкторы Map, Set, WeakMap, WeakSet.
- Promise.all(), Promise.race().

**Критический взгляд**: Протоколы итерации — это мощная абстракция. Они разделяют источник данных (итерируемый объект) и механизм обхода (for...of). Любой объект можно научить "быть итерируемым", что позволяет стандартным конструкциям языка работать с разнообразными структурами данных единообразно. Сам итератор хранит состояние (текущую позицию), поэтому обычно его можно использовать только один раз; для повторной итерации нужно снова вызвать [Symbol.iterator]().

## 2. Функции-Генераторы (function*) – Фабрики Итераторов

Создавать объект-итератор вручную (как в примере с range) довольно громоздко, особенно если логика итерации сложная и требует сохранения состояния между вызовами next(). Генераторы — это синтаксический сахар для упрощения этой задачи.

**Синтаксис**: `function* myGen() { ... }`. Звездочка * — ключевой признак.

**Поведение**: При вызове `myGen()` код внутри не выполняется сразу. Вместо этого возвращается специальный объект-генератор. Этот объект одновременно является и итерируемым, и итератором.

### Ключевое слово yield:

- Используется внутри генератора.
- Приостанавливает выполнение функции-генератора.
- Значение справа от yield возвращается как `{ value: ..., done: false }` при вызове generator.next().
- Состояние функции (локальные переменные, место остановки) сохраняется до следующего вызова next().

**Возобновление**: Следующий вызов generator.next() возобновляет выполнение с места сразу после yield.

### Пример (перепишем range):

```javascript
function* generateRange(from, to) {
  for (let current = from; current <= to; current++) {
    console.log(`Yielding ${current}`);
    yield current; // Пауза и возврат значения
  }
  console.log("Generator finished");
  // Неявный return undefined в конце
}

let rangeGenerator = generateRange(1, 3); // Код еще не выполнялся!

console.log("Calling next() 1st time:");
console.log(rangeGenerator.next());
// Output:
// Calling next() 1st time:
// Yielding 1
// { value: 1, done: false }

console.log("Calling next() 2nd time:");
console.log(rangeGenerator.next());
// Output:
// Calling next() 2nd time:
// Yielding 2
// { value: 2, done: false }

console.log("Calling next() 3rd time:");
console.log(rangeGenerator.next());
// Output:
// Calling next() 3rd time:
// Yielding 3
// { value: 3, done: false }

console.log("Calling next() 4th time:");
console.log(rangeGenerator.next());
// Output:
// Calling next() 4th time:
// Generator finished
// { value: undefined, done: true }
```

**Передача значения в next()**: Значение, переданное в generator.next(value), становится результатом предыдущего выражения yield.

```javascript
function* questionAsker() {
  const name = yield "What is your name?"; // Пауза 1, вернет "What is your name?"
  // Когда next(nameValue) будет вызван, nameValue запишется в 'name'
  console.log(`Received name: ${name}`);
  const age = yield `How old are you, ${name}?`; // Пауза 2
  console.log(`Received age: ${age}`);
  return `${name} is ${age} years old.`;
}

const asker = questionAsker();
console.log(asker.next().value); // What is your name?
console.log(asker.next("Alice").value); // Received name: Alice, How old are you, Alice?
console.log(asker.next(30).value); // Received age: 30, Alice is 30 years old.
console.log(asker.next().done); // true
```

**return и throw в генераторах**: `return value` завершает генератор, устанавливая `done: true` и `value`. `generator.throw(error)` "пробрасывает" ошибку внутрь генератора на место последнего yield, где её можно поймать try...catch.

**yield* (делегирование)**: `yield* anotherIterable` позволяет "встроить" итерацию по другому итерируемому объекту или генератору внутрь текущего.

**Критический взгляд**: Генераторы — это, по сути, "паузабельные" функции. Они невероятно упрощают создание сложных итераторов и управление состоянием итерации. Они идеальны для ленивых вычислений (генерировать значения только по запросу, не храня все в памяти) и бесконечных последовательностей. Возможность передачи данных в next() превращает их в инструмент для корутин (кооперативной многозадачности), хотя сейчас для асинхронности чаще используют async/await. Синтаксис function*/yield может показаться непривычным, но он решает реальные проблемы элегантнее, чем ручная реализация итераторов.

## 3. Асинхронные Итераторы и Генераторы (ES2018)

**Проблема**: Что если получение следующего элемента последовательности — это асинхронная операция (например, чтение файла по частям, получение страниц из API)? Обычные итераторы/генераторы синхронны.

### Решение:
- **Асинхронный итератор**: Объект с методом next(), который возвращает промис, разрешающийся в `{ value: ..., done: ... }`.
- **Асинхронный итерируемый объект**: Имеет метод `[Symbol.asyncIterator]()`, возвращающий асинхронный итератор.
- **for await...of**: Цикл для перебора асинхронных итерируемых объектов. Он await-ит каждый промис, возвращаемый next(), перед тем как извлечь value.
- **Асинхронные генераторы** (`async function*`): Упрощают создание асинхронных итераторов. Внутри можно использовать и await (для ожидания асинхронных операций), и yield (для выдачи значений).

### Пример (концептуальный):

```javascript
async function* fetchPages(baseUrl, startPage = 1) {
  let page = startPage;
  while (true) {
    try {
      const response = await fetch(`${baseUrl}?page=${page}`); // await внутри генератора
      if (!response.ok) break; // Останавливаемся при ошибке

      const data = await response.json();
      if (data.length === 0) break; // Останавливаемся, если данных больше нет

      for(const item of data) {
         yield item; // Выдаем каждый элемент данных
      }
      page++;
    } catch (err) {
      console.error("Failed to fetch page", page, err);
      break; // Останавливаемся при ошибке сети
    }
  }
}

// Использование:
(async () => {
  console.log("Starting async iteration...");
  // for await...of будет ждать разрешения промисов от next()
  for await (const item of fetchPages('/api/items')) {
    console.log("Received item:", item);
    // Можно обрабатывать элементы по мере их поступления
  }
  console.log("Finished async iteration.");
})();
```

**Критический взгляд**: Асинхронные итераторы/генераторы — огромное улучшение для работы с асинхронными последовательностями (стримы данных, пагинация API). Они позволяют писать такой код в гораздо более читаемом, "синхронном" стиле с помощью for await...of.

## Итог по Итераторам и Генераторам:

Протоколы итерации стандартизировали обход коллекций. Генераторы предоставили элегантный способ создания итераторов, особенно для ленивых или бесконечных последовательностей и управления сложным состоянием итерации. Асинхронные версии этих концепций решили проблему работы с асинхронными потоками данных. Понимание этих механизмов открывает двери к написанию более выразительного и эффективного кода в современном JavaScript.
