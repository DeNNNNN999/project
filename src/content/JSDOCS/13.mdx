# Модульная система в JavaScript (ES Modules vs CommonJS)

До появления модулей основной проблемой JavaScript была глобальная область видимости. Любой скрипт, подключенный к странице, мог объявить переменные, которые становились глобальными и могли конфликтовать с другими скриптами или встроенными функциями браузера. Это приводило к хаосу в больших проектах. Модули решают эту проблему, предоставляя каждому файлу (модулю) собственную, изолированную область видимости и механизмы для явного экспорта (чтобы сделать что-то доступным снаружи) и импорта (чтобы использовать что-то из другого модуля).

## 1. ES Modules (ESM / Модули ES6) – Современный Стандарт

Это официальный стандарт модулей в JavaScript, введенный в ES2015. Он используется нативно в браузерах и является основным в современном Node.js и всей экосистеме (React, Vue, Angular, TypeScript).

### Ключевые особенности:

- **Собственная область видимости**: Переменные, объявленные в модуле, локальны для этого модуля.
- **Явный экспорт/импорт**: Используются ключевые слова `export` и `import`.
- **Статическая структура**: Зависимости (`import`) и экспортируемые значения (`export`) определяются статически, то есть на этапе анализа кода (до его выполнения). Это позволяет инструментам (бандлерам, компиляторам TS) проводить оптимизации (tree shaking) и статический анализ. `import`/`export` можно использовать только на верхнем уровне модуля (не внутри функций или if).
- **Строгий режим ('use strict') по умолчанию**: Все ES-модули автоматически выполняются в строгом режиме.

### Синтаксис:

#### Именованные экспорты (Named Exports):
Экспорт нескольких сущностей по их именам.

```javascript
// utils.js
export const PI = 3.14;
export function square(x) { return x * x; }
const SECRET_KEY = '123'; // Не экспортируется, локально для модуля
```

```javascript
// main.js
import { PI, square } from './utils.js';
// Можно импортировать всё в объект-пространство имен:
// import * as utils from './utils.js';
// console.log(utils.PI); utils.square(2);
console.log(PI); // 3.14
console.log(square(4)); // 16
```

#### Экспорт по умолчанию (Default Export):
Экспорт одной "главной" сущности модуля. Может быть только один на модуль.

```javascript
// logger.js
export default function log(message) { // Экспорт функции по умолчанию
  console.log(`LOG: ${message}`);
}
// Можно экспортировать и по умолчанию, и именованные вместе
export const logLevel = 'INFO';
```

```javascript
// app.js
import myLogger, { logLevel } from './logger.js'; // Имя 'myLogger' может быть любым
// Можно импортировать только default: import logger from './logger.js';

myLogger("App started"); // LOG: App started
console.log(`Log level: ${logLevel}`); // Log level: INFO
```

#### Другие варианты:
- **Реэкспорт**: `export { name } from './other.js';` или `export * from './other.js';`
- **Импорт для побочных эффектов**: `import './styles.css';` или `import './setup-polyfill.js';` (Выполняет код модуля, но ничего не импортирует).

### Использование:
- **Браузер**: `<script type="module" src="main.js"></script>`. Модули загружаются с учетом CORS, выполняются отложено (defer по умолчанию).
- **Node.js**: Использовать расширение `.mjs` или добавить `"type": "module"` в package.json.

### Критический взгляд:
- **Статичность**: Плюс для анализа и оптимизации (tree shaking), но минус для гибкости (нельзя импортировать по условию или с динамическим путем — для этого есть `import()`).
- **export default vs Named**: Идет давний спор. default удобен для единственной сущности, но может приводить к разным именам при импорте (`myLogger`, `logger`, `logFunc`), что ухудшает поиск по коду. Named exports более явные и рефакторить их проще. Многие команды предпочитают именованные экспорты для большей строгости.

## 2. CommonJS (CJS) – Наследие Node.js

Это система модулей, которая исторически использовалась в Node.js до полноценной поддержки ESM.

### Ключевые особенности:
- Собственная область видимости.
- **Синхронный импорт**: Функция `require()` загружает и выполняет модуль синхронно.
- **Экспорт через module.exports или exports**:

### Синтаксис:

```javascript
// math.js
const add = (a, b) => a + b;
const PI = 3.14;

// Способ 1 (основной): присвоить объект module.exports
// module.exports = { add, PI };

// Способ 2 (добавление свойств к exports):
exports.add = add;
exports.PI = PI;
// Важно: exports - это просто ссылка на module.exports. Нельзя делать `exports = ...`
```

```javascript
// server.js
const mathUtils = require('./math.js'); // Синхронный вызов

console.log(mathUtils.PI); // 3.14
console.log(mathUtils.add(1, 2)); // 3
```

### Критический взгляд:
- **Синхронность `require()`**: Удобно для серверного кода, где модули обычно лежат локально, но абсолютно неприемлемо для браузеров (заблокировало бы весь интерфейс на время загрузки).
- **Менее статичен**: `require` — это обычная функция, путь можно вычислять динамически, можно вызывать внутри if. Это гибче, но хуже для статического анализа и оптимизаций.
- **Все еще важен**: Огромное количество пакетов в npm написано на CommonJS. Node.js поддерживает оба формата, и инструменты сборки (Webpack, Rollup) умеют с ними работать. Понимание CJS необходимо для работы с Node.js и экосистемой.

## 3. Динамические импорты import() (ES)

**Что это?** Специальный синтаксис (выглядит как функция, но это оператор), который позволяет загружать ES-модули асинхронно по требованию.

**Как работает**: Возвращает промис, который разрешается объектом пространства имен модуля (как при `import * as name`). Можно использовать в любом месте кода (в функциях, if и т.д.).

### Пример (ленивая загрузка компонента):

```javascript
button.addEventListener('click', async () => {
  try {
    // Загрузит 'heavy-component.js' только при клике
    const module = await import('./heavy-component.js');
    const HeavyComponent = module.default; // Если там default export
    // const { specificExport } = await import('./heavy-component.js'); // Именованный

    const instance = new HeavyComponent();
    instance.render();
  } catch (error) {
    console.error("Failed to load component", error);
  }
});
```

**Критический взгляд**: `import()` — мощнейший инструмент для оптимизации загрузки (code splitting). Позволяет не грузить весь код сразу, а подгружать части приложения по мере необходимости (например, при переходе на определенный роут в SPA). Сочетает гибкость динамической загрузки с преимуществами ESM.

## 4. Циклические Зависимости (A импортирует B, B импортирует A)

**Проблема**: Возникает неоднозначность: какой модуль инициализировать первым? Что получит модуль A, когда он импортирует B, если B в этот момент еще сам не завершил инициализацию и пытается импортировать A?

### Как обрабатываются (упрощенно):

- **ESM**: Обычно позволяет циклу случиться. Когда модуль B пытается импортировать A (который еще инициализируется), B получит ссылку на экспорты A, но значения этих экспортов могут быть еще не вычислены (будут undefined, пока A не завершит выполнение своего кода до export). Это часто приводит к ошибкам во время выполнения, если использовать импорты до их инициализации.

- **CommonJS**: Тоже позволяет. Когда B делает `require('./A')`, он получает объект `module.exports` модуля A в том состоянии, в котором он был на момент вызова require. Если A еще не успел присвоить что-то `module.exports`, B получит пустой объект `{}` (или частично заполненный).

**Критический взгляд**: Хотя обе системы пытаются как-то разрешить циклы, это почти всегда признак плохой архитектуры. Циклические зависимости усложняют понимание кода, порядок инициализации и могут приводить к трудноуловимым багам. Лучшее решение — рефакторинг, например, вынесение общей логики в третий, независимый модуль.

## Итог по Модулям:

Модули — это абсолютный must-have для современного JS/TS. ES Modules — это стандарт, на который нужно ориентироваться. Они обеспечивают изоляцию, организацию кода и возможности для оптимизации. Понимание CommonJS остается важным для работы с Node.js. Динамические импорты `import()` — ключ к оптимизации загрузки. Циклические зависимости — зло, которого стоит избегать.
