Вопросы для проверки понимания (40 штук):

Базовые темы (1-25):

Типы данных: Помимо очевидной ошибки typeof null === 'object', какие еще ограничения есть у оператора typeof при определении типов в JavaScript? Приведите примеры.
Типы данных: В каких сценариях семантическая разница между null и undefined действительно важна, а в каких их часто обрабатывают одинаково (и почему)?
Типы данных: Объясните механизм работы объектов-оберток для примитивов (String, Number, Boolean). Зачем он нужен и когда происходит "оборачивание" и "разворачивание"?
Типы данных: Каковы практические последствия использования формата IEEE 754 для типа number, кроме неточности 0.1 + 0.2? В каких задачах это критично? Как проблема решалась до BigInt?
Переменные/Scope: В чем фундаментальное различие между поднятием (hoisting) var и "поднятием" let/const? Что такое TDZ и почему она была введена?
Переменные/Scope: Объясните на примере кода, почему var внутри цикла for с асинхронными операциями (вроде setTimeout) приводит к неожиданному результату, и как let решает эту проблему именно с точки зрения замыканий и области видимости.
Операторы: Почему оператор == считается опасным? Приведите 2-3 примера неинтуитивного поведения == из-за неявного преобразования типов и объясните почему результат именно такой согласно алгоритму сравнения.
Операторы: Как работают логические операторы && и || с точки зрения возвращаемых значений и короткого замыкания? Приведите практический пример использования этого поведения (кроме простого if).
Операторы: Зачем может понадобиться унарный плюс (+value) и оператор void (void 0) в современном JavaScript? Каковы их исторические причины и актуальность сегодня?
Операторы: Какие потенциальные проблемы связаны с использованием оператора delete для свойств объекта? Какие альтернативы часто предпочтительнее и почему?
Control Flow: Почему использование for...in для итерации по массивам считается плохой практикой? Какие проблемы это может вызвать?
Control Flow: Объясните разницу в обработке "дырок" (sparse arrays) между методами forEach/map и циклом for...of / Array.from(). Почему возникла такая неконсистентность?
Control Flow: Какое сравнение (== или ===) используется в конструкции switch? Какие две основные ловушки подстерегают при использовании switch?
Объекты: Что такое дескрипторы свойств (value, writable, enumerable, configurable) и зачем они нужны? Как с помощью Object.defineProperty можно создать свойство-константу в объекте?
Объекты: Почему создание объекта через Object.create(null) считается более безопасным для использования в качестве словаря/хэш-мапы по сравнению с {}?
Объекты: В чем разница между доступом к свойствам через точку (obj.prop) и через квадратные скобки (obj['prop'])? Когда использование скобок необходимо?
Массивы: Почему typeof [] возвращает 'object'? Как свойство length массива связано с его индексами и к чему может привести его прямое изменение?
Массивы: Приведите пример мутирующего и немутирующего метода массива. Почему важно различать их, особенно в контексте React или Redux? Какие немутирующие аналоги появились в последних версиях JS?
Массивы: В чем проблема сортировки чисел с помощью arr.sort() по умолчанию и как ее правильно решить?
Функции: В чем ключевые различия между Function Declaration, Function Expression и Arrow Function с точки зрения hoisting, this и наличия arguments?
Функции: Что такое лексический this у стрелочных функций и какую основную проблему он решает? Приведите пример кода. Когда стрелочные функции использовать нельзя или не рекомендуется?
Функции: Почему псевдо-массив arguments считается устаревшим и чем его заменяют rest-параметры (...args)?
this: Объясните основные правила определения this в JS (глобальный/undefined, метод, new, call/apply/bind). Каков их приоритет?
this: Приведите классический пример "потери контекста" this при передаче метода объекта как колбэка и покажите 2-3 способа решения этой проблемы (bind, стрелочная функция, call/apply).
Замыкания: Объясните своими словами механизм замыкания: как внутренняя функция получает доступ к переменным внешней, даже после завершения внешней функции? Какую роль играет лексическое окружение?
Продвинутые темы (26-40):

Замыкания: Какие потенциальные проблемы с памятью (утечки) могут создавать замыкания и как современные движки пытаются их минимизировать?
Прототипы: Как связана функция-конструктор, ее свойство prototype и внутреннее свойство [[Prototype]] (или __proto__) экземпляра, созданного через new?
Прототипы: Объясните, как синтаксис class в ES6 является "синтаксическим сахаром" над прототипным наследованием. Как extends и super реализуются через прототипы?
Прототипы: Почему модификация Object.prototype или прототипов встроенных объектов (Array.prototype) — это очень плохая идея?
Прототипы: В чем разница между Object.hasOwnProperty() и оператором in при проверке наличия свойства в объекте?
ФП: Что такое "чистая функция" и "иммутабельность"? Почему эти концепции важны для предсказуемости и тестирования кода?
ФП: Приведите пример иммутабельного обновления вложенного объекта или массива в JS.
ФП: В чем разница между каррированием (Currying) и частичным применением (Partial Application)? Как замыкания позволяют их реализовать?
Асинхронность: Опишите основной цикл работы Event Loop, упомянув Call Stack, Web/Node APIs, Microtask Queue и Macrotask Queue. Почему порядок выполнения setTimeout(..., 0) и Promise.resolve().then(...) разный?
Асинхронность: Какие основные проблемы решает Promise по сравнению с колбэками?
Асинхронность: Как async/await связан с промисами? Как обрабатываются ошибки при использовании await?
Асинхронность: Приведите пример ситуации, где использование Promise.all предпочтительнее последовательных await.
Модули: Назовите 2-3 ключевых отличия между ES Modules (ESM) и CommonJS (CJS). Почему ESM не могли просто принять синхронный подход CJS для браузеров?
Модули: В чем плюсы и минусы статической структуры ESM? Как динамический import() решает некоторые ограничения?
Итераторы/Генераторы: Что такое протоколы итератора и итерируемого объекта? Как for...of их использует? Как функция-генератор (function*) упрощает создание итератора?
Практические Задачи (35 штук):

Базовые темы (1-25):

Типы: Напишите функцию isReallyNaN(value), которая корректно проверяет, является ли значение именно NaN (и никаким другим числом или не-числом).
Типы: Какой результат будет у [] + 1, {} + 1, [1] + [2], true + " " + false? Объясните каждый результат с точки зрения преобразования типов.
Типы: Напишите функцию isNullOrUndefined(value), которая возвращает true, если значение null или undefined, используя только одно сравнение.
Scope: Что выведет консоль и почему?
JavaScript

var x = 1;
function testScope() {
  console.log(x);
  var x = 2;
  console.log(x);
}
testScope();
console.log(x);
Scope: Что выведет консоль и почему? Будет ли ошибка?
JavaScript

// console.log(a); // 1. Что будет здесь?
// console.log(b); // 2. Что будет здесь?
let a = 10;
if (true) {
  console.log(a); // 3. Что будет здесь?
  let b = 20;
  var c = 30;
}
// console.log(b); // 4. Что будет здесь?
// console.log(c); // 5. Что будет здесь?
Операторы: Чему равны result1, result2, result3 и почему?
JavaScript

let result1 = "5" - 3;
let result2 = "5" + 3;
let result3 = +"5" + -3;
Операторы: Чему равно value и почему? let value = (null || 1 && "hello" || undefined);
Control Flow: Перепишите следующий код, используя switch вместо if/else if:
JavaScript

let color = "yellow";
if (color === "red") { console.log("Stop"); }
else if (color === "yellow") { console.log("Wait"); }
else if (color === "green") { console.log("Go"); }
else { console.log("Unknown"); }
Control Flow: Что выведет этот код и почему?
JavaScript

let arr = [1, undefined, 3, , 5]; // sparse array
arr.forEach(val => console.log("forEach:", val));
for (let val of arr) { console.log("for...of:", val); }
Объекты: Создайте объект user с помощью Object.create(null). Добавьте ему свойство name и убедитесь, что у него нет метода toString.
Объекты: Используя Object.defineProperty, добавьте объекту {} свойство id со значением 123, которое нельзя будет изменить, удалить или перечислить в цикле for...in.
Объекты: Напишите функцию hasOwnDeepProperty(obj, propPath), которая проверяет, есть ли у объекта obj собственное свойство по заданному пути (например, 'a.b.c').
Массивы: Напишите код, который сортирует массив [5, 100, 15, 2, 25] по числовому убыванию.
Массивы: Как, не используя цикл, создать массив [0, 1, 2, 3, 4]? Приведите 2-3 способа (например, с Array.from, keys, map).
Массивы: Напишите функцию immutableReverse(arr), которая возвращает новый массив с элементами в обратном порядке, не изменяя исходный.
Массивы: Дан массивоподобный объект let arrayLike = { 0: 'a', 1: 'b', length: 2 };. Преобразуйте его в настоящий массив двумя разными способами.
Функции: Что выведет консоль и почему?
JavaScript

let name = "Global";
let obj = {
  name: "Object",
  getNameArrow: () => this.name,
  getNameFunc: function() { return this.name; }
};
console.log(obj.getNameArrow());
console.log(obj.getNameFunc());
let unboundFunc = obj.getNameFunc;
// console.log(unboundFunc()); // Что будет здесь в strict/non-strict?
Функции: Напишите функцию sum(...), которая принимает любое количество числовых аргументов и возвращает их сумму, используя rest-параметры.
this: Что выведет этот код? Объясните значение this в каждом console.log.
JavaScript

function CtxTest(value) {
  this.value = value;
  console.log("Inside constructor:", this.value); // 1
}
CtxTest.prototype.method = function() {
  console.log("Inside method:", this.value); // 2
  const innerArrow = () => console.log("Inside arrow:", this.value); // 3
  function innerFunc() { console.log("Inside inner func:", this?.value); } // 4 (this? опционально)
  innerArrow();
  innerFunc();
  innerFunc.call({ value: 'call' }); // 5
};
const instance = new CtxTest('instance');
instance.method();
const standaloneMethod = instance.method;
// standaloneMethod(); // 6. Что будет здесь (strict/non-strict)?
this: Используя bind, создайте новую функцию logWarning, которая всегда вызывает console.log с первым аргументом "WARNING:".
Замыкания: Напишите функцию makeCaching(func), которая принимает другую функцию func и возвращает новую функцию. Эта новая функция должна кешировать результаты вызова func: если она вызывается с тем же аргументом повторно, она должна вернуть результат из кеша, а не вызывать func снова. (Для простоты считаем, что func принимает один примитивный аргумент).
Замыкания: Что выведет этот код? Исправьте его (не меняя var), чтобы он выводил 0, 1, 2, используя замыкание (например, IIFE).
JavaScript

for (var i = 0; i < 3; i++) {
  setTimeout(function() { console.log(i); }, 10);
}
Прототипы: Создайте объект dog с методом bark. Затем создайте объект buddy с помощью Object.create(dog), у которого есть собственное свойство name. Убедитесь, что buddy может лаять (buddy.bark()), но bark не является его собственным свойством.
Прототипы: Перепишите простой класс Car с конструктором и методом drive на чистых функциях-конструкторах и прототипах (без использования синтаксиса class).
Прототипы: Напишите функцию isPrototypeOf(proto, obj), которая проверяет, присутствует ли proto в цепочке прототипов obj.
Продвинутые темы (26-35):

ФП: Напишите чистую функцию getSortedUnique(arr), которая принимает массив чисел и возвращает новый массив с уникальными элементами, отсортированными по возрастанию.
ФП: Реализуйте иммутабельную функцию updateUser(users, userId, newAge), которая находит пользователя в массиве users по userId и возвращает новый массив, где у этого пользователя изменен возраст newAge, не меняя исходный массив.
ФП: Напишите простую функцию compose(f, g), которая принимает две функции и возвращает их композицию (x) => f(g(x)). Проверьте ее работу.
ФП: Напишите каррированную функцию match(regex) которая возвращает функцию (str) => regex.test(str). Используйте ее для создания hasNumber = match(/[0-9]/).
Асинхронность: Что выведет консоль и в каком порядке?
JavaScript

console.log('A');
setTimeout(() => console.log('B'), 0);
Promise.resolve().then(() => console.log('C')).then(() => console.log('D'));
console.log('E');
Асинхронность: Перепишите функцию, использующую вложенные колбэки (или setTimeout для имитации), на использование Promise и .then()/.catch().
Асинхронность: Перепишите ту же логику из предыдущего задания с использованием async/await и try/catch.
Модули: Создайте два файла math.js (экспортирует add и PI) и app.js (импортирует и использует их), используя синтаксис ES Modules.
Модули: Напишите пример использования динамического import() для загрузки модуля analytics.js только после клика на кнопку.
Итераторы/Генераторы: Напишите функцию-генератор function* count(limit), которая генерирует числа от 1 до limit. Используйте ее в цикле for...of.
