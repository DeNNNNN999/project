Вопросы для Проверки Понимания Node.js + Express (40 штук):

Node Intro: Что такое Node.js и чем он принципиально отличается от JavaScript в браузере (помимо отсутствия DOM/BOM)? Назовите два его ключевых компонента.
Node Intro: Объясните философию неблокирующего ввода/вывода (Non-blocking I/O) в Node.js. Почему она важна для производительности сервера?
Node Intro: Почему Node.js называют событийно-ориентированной (Event-Driven) платформой?
Event Loop: Опишите (упрощенно) основные фазы Event Loop в Node.js (Timers, Poll, Check). Где выполняются колбэки от setTimeout, setImmediate и большинства I/O операций?
Event Loop: Что означает "заблокировать Event Loop"? Приведите пример синхронного кода, который может это сделать, и объясните последствия для веб-сервера.
Event Loop: В чем разница в приоритете и времени выполнения между process.nextTick, колбэками промисов (микрозадачи) и setImmediate?
Modules CJS: Как работает механизм require() в CommonJS? Почему он синхронный? Объясните роли module.exports и exports.
Modules CJS: В чем заключается основная ловушка при использовании exports вместо module.exports для экспорта объекта?
Modules ESM: Как включить режим ES Modules для .js файлов в Node.js проекте? Назовите два способа.
Modules ESM/CJS: Можно ли использовать require() для импорта ES-модуля (.mjs или .js с "type": "module")? Если нет, то как это сделать?
Modules ESM/CJS: Как обычно происходит импорт CommonJS модуля из ES-модуля? Какую роль играет esModuleInterop?
NPM/Pkg: В чем разница между dependencies и devDependencies? Почему важно их правильно разделять?
NPM/Pkg: Какова цель файла package-lock.json (или аналогов)? Почему его необходимо коммитить в систему контроля версий?
NPM/Pkg: Объясните основы семантического версионирования (SemVer) и что означают префиксы ^ и ~ в package.json.
Built-ins path: Зачем использовать path.join() вместо простой конкатенации строк для создания путей?
Built-ins os: Назовите 2-3 полезных свойства/метода модуля os и для чего они могут использоваться. Что такое os.EOL?
Built-ins events: Объясните паттерн EventEmitter. Как подписаться на событие и как его сгенерировать? Какое событие используется для ошибок по конвенции?
Built-ins fs: Почему асинхронные методы fs (например, readFile) предпочтительнее синхронных (readFileSync) в серверном коде?
Built-ins fs: Как современный fs/promises API улучшает работу с асинхронными файловыми операциями по сравнению с колбэками?
Built-ins fs: Почему проверка существования файла перед чтением/записью (fs.access) часто является анти-паттерном? Какой подход безопаснее?
Built-ins http: Какие два основных объекта получает функция-обработчик в http.createServer() и каково их назначение?
Built-ins http: Почему обработка тела POST-запроса с помощью чистого модуля http требует работы со стримами ('data', 'end' события)?
Async Patterns: Сравните читаемость и удобство обработки ошибок при использовании колбэков, промисов (.then/.catch) и async/await (try/catch) для последовательных асинхронных операций в Node.
Async Patterns: Как выполнить несколько асинхронных операций (например, запросов к разным API или БД) параллельно и дождаться их всех, используя async/await?
Streams: В чем главное преимущество использования стримов (Streams) для чтения/записи больших файлов по сравнению с fs.readFile/fs.writeFile?
Streams: Что делает метод .pipe()? Какую важную проблему он решает автоматически (помимо передачи данных)?
Streams: Почему stream.pipeline() часто предпочтительнее ручного чейнинга .pipe().pipe() для соединения нескольких стримов?
Buffers: Что такое Buffer в Node.js и для чего он нужен? Почему нельзя всегда использовать строки?
Buffers: Как преобразовать Buffer в строку с нужной кодировкой (например, UTF-8) и обратно?
Express Intro: Какие основные проблемы модуля http решает Express? Что означает "минималистичный и не имеющий своего мнения" (unopinionated) фреймворк?
Express Intro: Какая концепция является центральной для расширения функциональности Express-приложения?
Routing: Как в Express получить доступ к параметру :id из маршрута /items/:id и к query-параметру sort из URL /items?sort=name? В каких свойствах req они находятся?
Routing: Почему порядок определения маршрутов (app.get(...)) важен? Какие маршруты следует определять первыми?
Routing: Для чего используется express.Router?
Middleware: Опишите сигнатуру обычной middleware-функции. Что означает каждый аргумент? Как передать управление дальше?
Middleware: Почему порядок регистрации middleware с помощью app.use() критически важен? Приведите пример.
Middleware: Чем отличается сигнатура middleware для обработки ошибок? Когда и как она вызывается? Где ее нужно определять?
Req/Res: Какое middleware необходимо использовать, чтобы Express мог распарсить тело JSON-запроса и поместить его в req.body?
Req/Res: В чем разница между res.send() и res.json()? Когда лучше использовать res.json()?
Req/Res: Как установить HTTP статус-код ответа (например, 404) и отправить тело ответа одной цепочкой вызовов в Express?
Практические Задачи по Node.js + Express (35 штук):

Event Loop: Напишите код с setTimeout(..., 0), setImmediate(...), process.nextTick(...) и Promise.resolve().then(...), который демонстрирует вероятный порядок их выполнения.
Modules CJS: Создайте модуль calculator.js, экспортирующий функции sum(a,b) и product(a,b). Импортируйте его в app.js и вызовите функции.
Modules ESM: Переделайте предыдущее задание на ES Modules (calculator.mjs, app.mjs).
Modules Interop: Создайте CJS модуль logger.cjs (module.exports = (msg) => console.log(msg);). Создайте ESM модуль server.mjs, который импортирует logger с помощью import() и использует его.
NPM/Pkg: Инициализируйте проект. Установите lodash как зависимость. Установите jest как зависимость разработки. Напишите скрипт "test": "jest" в package.json.
path: Напишите функцию, которая принимает путь к файлу и возвращает его имя файла без расширения, используя модуль path.
os: Напишите скрипт, который выводит в консоль платформу ОС, архитектуру и общее количество ОЗУ в мегабайтах.
events: Создайте класс Downloader, наследующий EventEmitter. Он должен иметь метод start(url), который имитирует загрузку (через setTimeout) и генерирует события 'progress' (с процентом) и 'done' (с результатом) или 'error'. Создайте экземпляр и подпишитесь на события.
fs/promises: Напишите async функцию, которая читает JSON из файла config.json, парсит его и возвращает свойство apiKey. Обработайте ошибки чтения и парсинга.
fs sync/async: Сравните время выполнения чтения большого текстового файла (>100 МБ) с помощью readFileSync и readFile (с промисами или async/await). Замерьте время (используя console.time/timeEnd). Предупреждение: readFileSync может заблокировать процесс надолго!
http: Создайте HTTP сервер на порту 3000 с помощью модуля http, который на все запросы отвечает текстом "Raw Node Server Running!".
Streams/pipe: Напишите скрипт Node.js, который читает файл input.log и записывает его содержимое в output.log с помощью createReadStream, createWriteStream и .pipe().
Streams/pipeline: Перепишите предыдущее задание, используя stream.pipeline() для обработки ошибок.
Buffers: Создайте буфер из строки "Node.js" в кодировке UTF-8. Выведите его содержимое в консоль как строку в кодировке Base64.
Express Intro: Создайте простое Express-приложение, которое на GET запрос / отвечает "Welcome to Express!".
Routing: Добавьте в Express-приложение маршрут GET /api/posts/:postId, который извлекает postId из req.params и отвечает JSON { "postId": postId }.
Routing: Добавьте маршрут GET /api/items, который принимает опциональный query-параметр limit и отвечает "Fetching items" (если limit не указан) или Workspaceing [limit] items (если указан).
Routing/Router: Создайте routes/products.js, экспортирующий express.Router. Определите на нем роуты GET / и GET /:productId. Смонтируйте этот роутер в основном файле приложения по пути /api/products.
Middleware: Напишите middleware, которое добавляет заголовок X-Request-Time с текущим временем (new Date().toISOString()) ко всем ответам сервера.
Middleware: Напишите middleware requireApiKey, которое проверяет наличие заголовка X-API-Key со значением SECRET123. Если его нет или он неверный, middleware отправляет ответ 401 Unauthorized. Если есть — вызывает next(). Примените его к одному из маршрутов.
Middleware Order: Создайте два middleware: mw1 логирует "MW1" и вызывает next(), mw2 отправляет ответ res.send("MW2"). Зарегистрируйте их через app.use() сначала mw1, потом mw2. Что получит клиент? Что будет, если поменять их порядок?
Error Middleware: Создайте маршрут, который намеренно вызывает ошибку (throw new Error('Oops!')). Создайте error-handling middleware, которое ловит ошибку, логирует ее и отправляет JSON { "error": "Server Error" } со статусом 500.
Req/Res: Создайте маршрут POST /login, который (после express.json()) ожидает username и password в req.body и отвечает JSON { "authenticated": true, "user": username }.
Req/Res: Создайте маршрут GET /info, который отвечает JSON, содержащим метод запроса (req.method) и запрошенный путь (req.originalUrl).
Async Handler: Напишите async обработчик для GET /slow-data, который имитирует долгий запрос к БД (await new Promise(res => setTimeout(res, 1000))) и затем отправляет JSON { "data": "finally arrived" }. Не забудьте про try/catch и next(err).
FS/Streams/Express: Создайте маршрут GET /log-stream, который читает большой лог-файл server.log с помощью fs.createReadStream и стримит его содержимое клиенту (readableStream.pipe(res)).
Modules CJS/ESM: Создайте config.mjs (export const port = 3000;). Создайте server.cjs (require('./config.mjs') - как это сделать правильно?).
EventEmitter: Модифицируйте класс Downloader из задачи #8, чтобы он также генерировал событие 'error', если имитация загрузки "не удалась". Добавьте обработчик этого события.
path/fs: Напишите скрипт, который рекурсивно обходит все файлы в указанной директории и ее поддиректориях и выводит их полные пути с помощью path.resolve. (Используйте асинхронные readdir и stat).
Express Middleware Chain: Предскажите финальный ответ для GET /data:
JavaScript

app.use('/data', (req, res, next) => { req.val = 1; next(); });
app.get('/data', (req, res, next) => { req.val += 2; next(); });
app.use((req, res, next) => { req.val += 4; next(); }); // Сработает ли для /data?
app.get('/data', (req, res) => { res.json({ value: req.val }); });
Express Error Handling: Что получит клиент при запросе GET /error:
JavaScript

app.get('/error', (req, res, next) => {
  // Имитация асинхронной ошибки без await и try/catch
  fs.readFile('/non/existent/file', (err, data) => {
     if(err) { next(err); } else { res.send(data); }
  });
});
app.use((err, req, res, next) => { res.status(500).send('Caught Error!'); });
Express Router/Params: Создайте роутер для API постов (/api/posts) с маршрутами: GET / (все посты), POST / (создать пост), GET /:postId (получить пост), DELETE /:postId (удалить пост).
Buffers/Strings: Прочитайте текстовый файл с помощью fsPromises.readFile без указания кодировки. Получите Buffer. Преобразуйте его в строку UTF-8.
Streams/Error: Исправьте пример с .pipe() из задачи #11 так, чтобы ошибка в reader приводила к закрытию writer.
Async/Promise.all: Напишите async функцию, которая принимает массив URL, делает Workspace запросы ко всем URL параллельно, и возвращает массив текстовых ответов. Используйте Promise.all и обработайте ошибки.
