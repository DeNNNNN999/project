Тема #6 (React): Побочные Эффекты (useEffect) и Массив Зависимостей

Функциональные компоненты в идеале должны быть чистыми функциями рендеринга: для одних и тех же props и state возвращать один и тот же JSX. Но приложениям нужно взаимодействовать с "внешним миром" — делать запросы к API, подписываться на события, работать с таймерами, напрямую манипулировать DOM (иногда). Это и есть побочные эффекты (side effects). `useEffect` — это основной хук для их выполнения.

1. Назначение и Синтаксис useEffect

Цель: Выполнять императивный код с побочными эффектами после того, как React отрисовал изменения в DOM. Он позволяет синхронизировать ваш компонент с внешними системами.
Синтаксис: `useEffect(setupFunction, dependencies?)`
`setupFunction`: Функция, содержащая логику эффекта. Выполняется после рендера.
`dependencies`: Необязательный массив значений (пропсы, стейт, функции), от которых зависит эффект. Именно он определяет, когда эффект будет перезапущен.
2. Когда Выполняется Эффект? Зависит от Зависимостей!

`useEffect(setup)` (Без массива зависимостей): Эффект будет выполняться после каждого рендера компонента. Критический взгляд: Это нужно очень редко! Обычно приводит к лишним операциям или даже бесконечным циклам, если эффект сам вызывает обновление состояния.
`useEffect(setup, [])` (Пустой массив): Эффект выполнится только один раз, после первого монтирования компонента в DOM. Аналог `componentDidMount` в классах.
Применение: Загрузка начальных данных, установка глобальных слушателей событий (которые нужно будет убрать при размонтировании!), инициализация библиотек.
`useEffect(setup, [dep1, dep2])` (Массив с зависимостями): Эффект выполнится после первого монтирования И после каждого последующего рендера, если хотя бы одно значение в массиве `[dep1, dep2]` изменилось по сравнению с предыдущим рендером. React сравнивает зависимости с помощью `Object.is` (похоже на `===`, но `Object.is(NaN, NaN)` вернет `true`). Аналог `componentDidUpdate` (но срабатывает и при монтировании).
Применение: Реакция на изменение пропсов или стейта (например, перезапросить данные при смене `userId`).
3. Функция Очистки (Cleanup Function)

Функция `setup` может вернуть другую функцию. Эта возвращенная функция (`cleanup`) будет вызвана React:
Перед размонтированием компонента (аналог `componentWillUnmount`).
Перед каждым последующим запуском эффекта (если зависимости изменились).
Зачем? Чтобы убрать за собой: отменить подписки, очистить таймеры, удалить слушатели событий, прервать сетевые запросы. Это критически важно для предотвращения утечек памяти и выполнения кода после того, как компонент уже не нужен.

```typescript
useEffect(() => {
  const timerId = setInterval(() => console.log('Tick'), 1000);
  console.log("Timer started");

  // Функция очистки
  return () => {
    clearInterval(timerId); // Очищаем таймер при размонтировании или перезапуске эффекта
    console.log("Timer stopped");
  };
}, []); // Пустой массив - сработает 1 раз при монтировании, очистка при размонтировании
```

4. Массив Зависимостей – "Кошмар Сопровождения"? (Противоречие #6)

Это самая сложная и самая важная часть `useEffect`, источник большинства проблем.

Золотое Правило: В массив зависимостей нужно включать ВСЕ значения из области видимости компонента (пропсы, стейт, функции, объявленные в компоненте), которые используются ВНУТРИ функции `setup` и могут измениться между рендерами.
ПОЧЕМУ это так важно? Функция `setup` (и ее `cleanup`) является замыканием. Она "захватывает" значения переменных из того рендера, в котором она была создана. Если эффект зависит от `userId`, но `userId` не указан в зависимостях, то при изменении `userId` эффект не перезапустится и будет продолжать работать со "старым", неактуальным значением `userId` из предыдущего замыкания. Это приводит к трудноуловимым багам.
Проблемы и "Кошмар":
Устаревшие Замыкания (Stale Closures): Пропуск зависимости — самая частая ошибка.
Равенство Ссылок: Объекты, массивы и функции, объявленные внутри тела компонента, создаются заново при каждом рендере, получая новую ссылку. Если включить их в зависимости "как есть", эффект будет перезапускаться при каждом рендере, даже если данные не изменились!
Решение для функций: Обернуть их в `useCallback` с их собственными зависимостями, чтобы стабилизировать ссылку.
Решение для объектов/массивов: Обернуть их создание в `useMemo` или вынести за пределы компонента, если они не зависят от рендера. Либо убедиться, что сравнение по значению (если возможно) или использование примитивов достаточно.
ESLint Плагин (`eslint-plugin-react-hooks`): Правило `exhaustive-deps` жизненно необходимо. Оно анализирует код эффекта и предупреждает о пропущенных или лишних зависимостях, часто предлагая автоисправление. Критический взгляд: Хотя этот линтер — лучший друг при работе с `useEffect`, он не идеален. Иногда он может давать ложные срабатывания или предлагать включить зависимости, которые точно не нужны (например, `setState` функции, которые React гарантирует как стабильные). В таких редких случаях можно использовать комментарий `// eslint-disable-next-line react-hooks/exhaustive-deps`, но только с полным пониманием, почему вы это делаете.
Вывод по Зависимостям: Массив зависимостей — это не опция, а контракт с React. Он требует дисциплины и понимания замыканий и сравнения ссылок в JS. Это цена за декларативное управление эффектами.
5. Асинхронные Операции в useEffect

Сама функция `setup` не может быть `async`, так как `useEffect` ожидает от нее возврата либо ничего, либо функции очистки (а не Promise).
Паттерн: Объявить `async` функцию внутри `useEffect` и вызвать ее.
Важность Очистки при Асинхронности: Если компонент размонтируется до завершения async операции (например, Workspace), попытка обновить состояние вызовет ошибку. Нужно предусмотреть отмену операции или проверку монтирования перед `setState`.

```typescript
useEffect(() => {
  let isMounted = true; // Флаг для отслеживания монтирования

  const fetchData = async () => {
    try {
      const result = await myApiCall(itemId); // itemId должен быть в зависимостях!
      if (isMounted) { // Проверяем, смонтирован ли компонент
        setData(result);
      }
    } catch(err) { if (isMounted) setError(err); }
  };

  fetchData();

  return () => { // Функция очистки
    isMounted = false; // Ставим флаг при размонтировании
    // Здесь можно добавить логику отмены запроса (AbortController)
  };
}, [itemId]); // Перезапускаем при смене itemId
```

6. useEffect – для Синхронизации, не для Событий

`useEffect` предназначен для синхронизации состояния компонента с внешним миром в ответ на рендер или изменение данных.
Для эффектов, которые должны произойти в ответ на конкретное событие пользователя (клик, отправка формы), логику обычно помещают прямо в обработчик события, а не в `useEffect`.
Итог по Теме #6:

`useEffect` — это мощный и необходимый хук для управления побочными эффектами в React. Его парадигма — синхронизация, а не просто имитация методов жизненного цикла. Массив зависимостей — его самая сложная, но и самая важная часть, требующая понимания замыканий и сравнения ссылок в JS. Правильная работа с зависимостями, асинхронностью и функцией очистки — ключ к написанию надежных и предсказуемых React-компонентов.