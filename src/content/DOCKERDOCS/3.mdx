Тема 3: Образы vs Контейнеры: Статичный Шаблон vs Эфемерный Экземпляр
Представь себе это как разницу между рецептом торта и самим испеченным тортом. Одно — это инструкция, другое — результат ее выполнения в конкретный момент времени.

Как это проявляется:
Образ (Image):

Суть: Это неизменяемый (immutable) шаблон или "слепок" файловой системы и параметров запуска. Как .iso для ОС или скомпилированный бинарник программы.
Создание: Собирается командой docker build на основе Dockerfile. Dockerfile — это и есть тот самый "рецепт".
Структура: Состоит из набора слоев (layers), доступных только для чтения (read-only). Каждый слой обычно соответствует одной инструкции в Dockerfile (FROM, RUN, COPY и т.д.). Слои кешируются и переиспользуются между образами, экономя место и время сборки. Каждый слой идентифицируется по хешу своего содержимого.
Содержимое: Включает всё необходимое для запуска приложения: код, библиотеки, зависимости, системные утилиты, переменные окружения, метаданные (например, ENTRYPOINT, CMD, EXPOSE).
Хранение: Образы хранятся в реестрах (registries), таких как Docker Hub, Google Container Registry (GCR), AWS Elastic Container Registry (ECR), или в локальном кеше Docker (/var/lib/docker/image/... или аналог).
Контейнер (Container):

Суть: Это запущенный экземпляр образа. Это живой, работающий процесс (или группа процессов), изолированный от хоста и других контейнеров.
Создание: Запускается командами docker run (или docker create + docker start) из конкретного образа.
Структура: При запуске Docker берет read-only слои образа и добавляет поверх них тонкий записываемый слой (writable container layer). Все изменения файловой системы, происходящие во время работы контейнера (создание логов, временных файлов, изменение конфигов внутри контейнера), происходят именно в этом верхнем слое. Также контейнер включает в себя сам процесс приложения, его состояние в памяти, выделенные ему ресурсы (cgroups) и изолированное окружение (namespaces).
Жизненный цикл: Контейнер существует, пока выполняется его основной процесс. Когда процесс завершается, контейнер останавливается.
Состояние: Динамическое, изменяемое (в пределах writable layer), но по умолчанию эфемерное.
Связь: Один образ может служить основой для запуска множества независимых контейнеров. Каждый контейнер стартует с идентичным состоянием (определенным образом), но дальше их жизненные пути расходятся, и изменения в одном контейнере никак не влияют на другие или на сам образ.

В чем особенность / проблематика?:
Именно в различии статики/динамики и в природе записываемого слоя кроется большинство ловушек и ключевых концепций.

Ловушка Записываемого Слоя: Это классика ошибок новичков. Ты запускаешь контейнер, заходишь в него через docker exec, меняешь конфиг (vi /app/config.conf), устанавливаешь пакет (apt install nano), перезапускаешь контейнер... и все изменения исчезают! Почему? Потому что они были сделаны в эфемерном записываемом слое, который уничтожается вместе с контейнером. Образ при этом остается нетронутым.
Принцип Неизменяемой Инфраструктуры (Immutable Infrastructure): Разделение на образ и контейнер — это техническая основа этого принципа. Идея в том, что работающие системы (контейнеры) никогда не изменяются "на месте". Любое обновление — это сборка нового образа с изменениями и запуск новых контейнеров из него, с последующим удалением старых. Образы версионируются, как код. Это делает развертывания предсказуемыми и воспроизводимыми. Пытаться менять что-то в работающем контейнере — значит идти против этой парадигмы.
Управление Состоянием (State Management): Эфемерность контейнеров заставляет явно думать о персистентности данных. Если твое приложение пишет логи, загружает файлы, работает с базой данных — всё это состояние (state) должно храниться вне контейнера. Для этого используются тома (volumes) или bind mounts. Данные в томах существуют независимо от жизненного цикла контейнера. Непонимание этого = гарантированная потеря данных.
Производительность Записи: Механизм copy-on-write, используемый для записываемого слоя (например, в overlay2), означает, что при первой модификации файла из нижележащего read-only слоя он копируется в верхний записываемый слой. Это может вносить небольшие накладные расходы на операции записи, особенно для приложений с интенсивным I/O. Запись напрямую в том (volume) часто бывает производительнее.
Отладка и "Заморозка" Состояния:
Команда `docker diff <container_id>` показывает, какие файлы были добавлены, изменены или удалены в записываемом слое контейнера по сравнению с исходным образом. Полезно для понимания, что "намусорил" работающий процесс.
Команда `docker commit <container_id> <new_image_name>` создает новый образ, "замораживая" текущее состояние контейнера (объединяя read-only слои исходного образа и содержимое записываемого слоя). Это антипаттерн для создания основных образов приложений (т.к. нарушает воспроизводимость через Dockerfile), но может быть полезен для отладки — сохранить "упавшее" состояние для последующего анализа.
Критический взгляд :
Различие "образ vs контейнер" — это альфа и омега Docker. Кажется простым, но его полное осознание меняет подход к разработке и эксплуатации.

Фундамент, а не Деталь: Это не просто техническая деталь реализации, это основа философии контейнеризации. Игнорирование этого различия — все равно что пытаться писать ООП-код, не понимая разницы между классом и объектом.
Сдвиг Парадигмы: Осознание эфемерности контейнера и необходимости выносить состояние вовне — это переход от модели "сервер = питомец" (pet), которого мы холим и лелеем, к модели "сервер = скот" (cattle), где отдельные экземпляры легко заменяемы. Контейнеры — это "скот". Данные в томах — это то ценное, что мы сохраняем.
Почему Спотыкаются: Привычка работать с ВМ или физическими серверами, где все изменения по умолчанию персистентны. Эфемерность записываемого слоя Docker интуитивно непонятна поначалу. Нужна сознательная перестройка мышления.
Ключ к DevOps: Без четкого разделения образа (build artifact) и контейнера (runtime instance) невозможны:
Надежные Пайплайны: Сборка неизменяемого образа -> Тестирование -> Развертывание идентичных контейнеров в разных средах.
Быстрые и Безопасные Откаты: Просто запускаем контейнеры из предыдущей версии образа.
Горизонтальное Масштабирование: Легко добавить больше идентичных контейнеров из одного образа.
Итог: "Критическое различие, которое упускают многие новички" — это абсолютная правда. Путаница между статичным, неизменяемым образом (рецептом) и динамичным, эфемерным по умолчанию контейнером (конкретным тортом) — источник бесконечных проблем. Понимание этой дуальности, принятие эфемерности контейнеров и осознанное управление состоянием через тома — это необходимое условие для эффективного и безопасного использования Docker. Это база, без которой все остальное рассыпается.
