Тема 9: Безопасность: Изоляция Процессов, а Не Непробиваемая Крепость
Docker использует умные механизмы ядра Linux (namespaces, cgroups) для создания иллюзии отдельной машины, но это именно иллюзия. Изоляция есть, но она не абсолютна, как у ВМ, и это имеет прямые последствия для безопасности.

Как это проявляется (Глубокий взгляд):
Атака через Общее Ядро (Shared Kernel Attack Surface):
Суть: Все контейнеры на одном хосте работают под управлением одного и того же ядра операционной системы хоста. Если в этом ядре есть уязвимость (например, в сетевом стеке, файловой системе, планировщике процессов), то злоумышленник, получивший контроль над одним контейнером, потенциально может проэксплуатировать эту уязвимость для атаки на ядро хоста, а значит — и на сам хост, и на все остальные контейнеры.
Примеры: Баг в реализации системного вызова (syscall), позволяющий повысить привилегии; уязвимость в драйвере, позволяющая выйти за пределы своего mount namespace; DoS-атака на сетевой стек ядра через специально сформированные пакеты из контейнера.
Уязвимости "Побега из Контейнера" (Container Escape):
Суть: Это конкретные CVE (Common Vulnerabilities and Exposures), найденные либо в компонентах самого Docker (Docker Engine, containerd, runc — низкоуровневая утилита запуска), либо, что чаще, в ядре Linux. Эти уязвимости позволяют процессу внутри контейнера обойти механизмы изоляции (namespaces, cgroups) и получить несанкционированный доступ к ресурсам хоста или других контейнеров.
Исторические примеры: CVE-2019-5736 (позволял перезаписать runc на хосте), "Dirty COW" (CVE-2016-5195, уязвимость ядра для повышения привилегий, применимая из контейнера), различные баги, позволяющие обойти ограничения namespaces.
Реальность: Такие уязвимости редки, но критически опасны. Они показывают, что граница изоляции не является непроницаемой.
Проблема root Внутри Контейнера:
Поведение по Умолчанию: Очень часто основной процесс в контейнере запускается с UID 0, то есть как пользователь root внутри user namespace контейнера.
Риски:
Linux Capabilities: root внутри контейнера по умолчанию обладает набором привилегий (capabilities), которые могут быть опасны (например, CAP_NET_RAW для создания произвольных пакетов). Если контейнеру явно добавлены capabilities (--cap-add) или он запущен с флагом --privileged, его root становится почти всемогущим.
Взаимодействие с Ядром: root имеет больше прав на выполнение системных вызовов, что увеличивает поверхность атаки на ядро.
Доступ к Томам/Bind Mounts: Если том или bind mount подключен без правильной настройки прав, root в контейнере может получить root-доступ к этим данным на хосте.
Плацдарм для Атаки: Скомпрометировав процесс, работающий от root в контейнере, атакующий получает полный контроль внутри этого контейнера, откуда ему легче проводить дальнейшие атаки или эксплуатировать другие уязвимости.
Флаг --privileged: Фактически отключает большую часть механизмов изоляции Docker. Контейнер получает доступ к устройствам хоста (/dev), может загружать модули ядра и т.д. Использовать в продакшене категорически не рекомендуется, только в исключительных случаях с полным пониманием рисков.
В чем особенность / проблематика? (Глубокий взгляд):
Проблема в том, что удобство Docker создает ложное чувство безопасности, а реальное её обеспечение требует активных действий и глубоких знаний.

Иллюзия Надежной Изоляции: Легкость запуска (docker run) может привести к мысли, что контейнер так же безопасен, как ВМ. Это не так. Уровень изоляции ниже, граница "мягче". Запускать недоверенный код в обычном Docker-контейнере — крайне рискованно.
Зависимость от Хоста: Безопасность контейнеров напрямую зависит от безопасности и актуальности ядра хостовой ОС. Старое ядро с известными CVE = все контейнеры на этом хосте уязвимы. Требуется строгая дисциплина обновления хостов.
Сложность Укрепления (Hardening): Защита Docker — это многослойный пирог:
Запуск от Не-root Пользователя: Ключевая практика! Использовать инструкцию USER в Dockerfile для запуска процесса от имени непривилегированного пользователя. Требует правильной настройки прав доступа к файлам и портам (< 1024).
Отбрасывание Привилегий (Capabilities): Запускать контейнеры с --cap-drop=ALL и добавлять только строго необходимые (--cap-add=`<NEEDED_CAP>`). Принцип наименьших привилегий.
Seccomp Профили: Фильтрация разрешенных системных вызовов (--security-opt seccomp=...). Docker использует дефолтный профиль, но кастомные/более строгие профили (например, блокирующие неиспользуемые syscalls) значительно повышают безопасность.
AppArmor / SELinux: Использование MAC (Mandatory Access Control) систем хоста для дополнительного ограничения действий контейнера (--security-opt apparmor=..., --security-opt label=...).
User Namespaces (userns-remap): Маппинг UID/GID внутри контейнера на непривилегированные UID/GID на хосте. root (UID 0) в контейнере становится обычным пользователем на хосте. Значительно повышает безопасность, но усложняет настройку, особенно с томами. Rootless Docker пытается решить эту проблему.
Read-only Root Filesystem (--read-only): Запуск контейнера с корневой ФС только для чтения. Затрудняет атакующему изменение окружения контейнера. Требует явного монтирования томов для всех путей, куда приложению нужна запись.
Дилемма root: Многие официальные и сторонние образы до сих пор по умолчанию запускают процессы от root. Это заставляет пользователей либо принимать риск, либо пересобирать образы с USER non-root, что требует дополнительных усилий.
Критический взгляд:
Безопасность — это процесс, а не состояние. Docker дает инструменты, но не гарантии.

Безопасность не Встроена, а Выстраивается: Docker предоставляет механизмы изоляции. Но чтобы построить безопасную систему, нужно активно конфигурировать и укреплять эти механизмы и всё окружение. Дефолтные настройки — это компромисс в сторону простоты использования, а не максимальной безопасности.
Shared Kernel: Первородный Грех Безопасности: С точки зрения безопасности, общее ядро — это и есть главный компромисс Docker по сравнению с ВМ. Это источник эффективности, но и основной вектор угроз. Этот факт нужно осознавать и управлять связанными рисками.
Менталитет "Исходим из Худшего" (Assume Breach): Для критичных систем нужно исходить из того, что изоляция контейнера может быть нарушена. Поэтому нужна эшелонированная оборона (defense-in-depth): сетевая сегментация (Network Policies в K8s), принцип наименьших привилегий (non-root, drop caps), мониторинг событий безопасности во время выполнения (runtime security, Falco), регулярное сканирование уязвимостей (образы, ядро хоста).
Реальность FAANG: Безопасность — абсолютный приоритет. Дефолты не используются. Практики non-root, кастомные Seccomp/AppArmor профили, Network Policies, runtime security — стандарт. Запуск от root или с --privileged требует серьезнейшего обоснования. Обновление ядер хостов — непрерывный и строгий процесс. К уязвимостям container escape относятся максимально серьезно.
Порог Входа: Множество опций безопасности и техник hardening может быть ошеломляющим для новичков или небольших команд. Построение действительно защищенного Docker-окружения требует экспертизы. Здесь помогают управляемые платформы (GKE, EKS, AKS с настроенными политиками безопасности).
Итог: "Противоречие" здесь очевидно: Docker дает изоляцию, но не истинное разделение. Эта разница критична для безопасности. Полагаться на дефолтные настройки — наивно. Безопасность требует активного, многослойного подхода: минимизация поверхности атаки, ограничение привилегий, строгий контроль ядра хоста и готовность к худшему сценарию. Понимание рисков shared kernel и root в контейнере — обязательно для всех, кто использует Docker в проде. Безопасность в Docker — это работа, а не данность.
