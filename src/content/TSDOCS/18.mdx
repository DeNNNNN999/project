Тема #18: Файлы Деклараций (.d.ts) / @types

## 1. Проблема: JavaScript Не Знает о Типах

Когда ты используешь популярную JS-библиотеку (например, lodash, express, jquery или даже встроенные API Node.js вроде fs) в своем TypeScript-проекте, компилятор TS по умолчанию не имеет ни малейшего понятия, какие функции там есть, какие аргументы они принимают и что возвращают. Для него это "черный ящик". Без дополнительной информации он не сможет ни проверить правильность твоего кода, ни предоставить автодополнение.

## 2. Решение: Файлы Деклараций (.d.ts)

**Что это?** Специальные файлы с расширением .d.ts. Они содержат только описания типов для существующего JavaScript кода. В них нет реализации (тел функций, логики), только сигнатуры:

- Интерфейсы (interface)
- Псевдонимы типов (type)
- Сигнатуры функций (`function func(arg: Type): ReturnType;`)
- Типы переменных (`declare const myVar: SomeType;`)
- Описания классов (`declare class MyClass { constructor(opt: Opts); method(): void; }`)
- Описания модулей (`declare module 'module-name' { ... }`)

**Зачем?** Они предоставляют компилятору TypeScript "контракт" или "карту типов" для JavaScript кода. tsc читает эти файлы и использует их для статической проверки твоего кода, который взаимодействует с соответствующей JS-библиотекой, и для работы IntelliSense (автодополнения, подсказок).

**Пример (очень упрощенный lodash.d.ts):**

```typescript
// lodash.d.ts (концептуальный пример)
declare module 'lodash' { // Описываем модуль 'lodash'
  // Описываем сигнатуру функции 'chunk'
  export function chunk<T>(array: T[] | null | undefined, size?: number): T[][];

  // Описываем сигнатуру функции 'map'
  export function map<T, U>(collection: T[], iteratee: (value: T) => U): U[];
  // ... и так далее для всех функций lodash ...

  // Можно описать и типы, используемые внутри
  interface LodashStatic {
     // ...
  }

  const _: LodashStatic; // Описываем глобальную переменную _ (если она есть)
  export default _;
}
```

## 3. Откуда Берутся .d.ts Файлы?

Есть три основных источника:

### В комплекте с библиотекой (Bundled Types): 
(Предпочтительный вариант). Современные библиотеки, особенно написанные на TypeScript или активно поддерживающие его, часто включают .d.ts файлы прямо в свой npm-пакет. TypeScript обычно находит их автоматически при установке пакета.

### Проект DefinitelyTyped (@types): 
(Самый частый вариант для JS-библиотек). Это огромный общественный репозиторий на GitHub, где сообщество создает и поддерживает файлы деклараций для тысяч популярных JavaScript библиотек, у которых нет своих встроенных типов. Эти декларации публикуются в npm под специальным скоупом @types.

**Как использовать:** Если библиотека some-lib не имеет своих типов, вы просто устанавливаете их отдельно:

```bash
npm install --save-dev @types/some-lib
# или yarn add --dev @types/some-lib
```

Компилятор TypeScript автоматически ищет типы в node_modules/@types и подхватывает их.

**Критический взгляд:** DefinitelyTyped — это невероятный ресурс, но качество типов может варьироваться. Так как их пишут волонтеры, они могут быть неполными, содержать ошибки или отставать от последней версии библиотеки. Всегда полезно проверять репозиторий DT на наличие issues или PR, если возникают проблемы с типами. Предпочтение всегда стоит отдавать библиотекам со встроенными типами.

### Собственные файлы деклараций:
Вы можете написать свои .d.ts файлы:
- Для небольшой JS-библиотеки без типов.
- Для описания глобальных переменных/функций, которые появляются из подключенных `<script>` тегов.
- Для расширения (augmentation) существующих типов из других .d.ts файлов (например, добавление кастомных свойств к глобальному window).

## 4. "Окружающие" Декларации (declare)

Внутри .d.ts файлов (а иногда и в .ts, хотя реже) используется ключевое слово declare. Оно говорит TypeScript: "Сущность с этим именем и типом уже существует где-то во время выполнения (в JS коде, в среде); тебе не нужно проверять ее реализацию, просто знай о ее типе".

```typescript
// В файле my-globals.d.ts
declare const MY_GLOBAL_API_KEY: string;
declare function legacyAnalytics(eventName: string): void;

declare module 'untyped-module' { // Говорим, что модуль есть, но без типов
  const anything: any;
  export default anything;
}

declare module 'existing-module' { // Расширяем существующий модуль
    export function newUtilFunction(): boolean;
    interface ExistingInterface {
        addedProperty?: string;
    }
}
```

**Критический взгляд:** declare — это мост между миром типов TS и миром рантайма JS. Используется для описания того, что TS сам "не видит", но что будет доступно при запуске кода.

## 5. Написание Собственных .d.ts

**Критический взгляд:** Это может быть сложной задачей для нетривиальных библиотек. Требует хорошего понимания как самой JS-библиотеки, так и системы типов TypeScript. Часто проще начать с генерации базовых типов (есть инструменты вроде dts-gen) и затем дорабатывать вручную. Это важный навык, если вы работаете в смешанной TS/JS среде или публикуете свои JS библиотеки с поддержкой TS.

## Итог по Теме #18:

Файлы деклараций .d.ts — это жизненно важный клей, позволяющий TypeScript эффективно работать с экосистемой JavaScript. Благодаря им мы получаем статическую проверку и автодополнение для тысяч JS-библиотек. Основной источник — проект DefinitelyTyped (@types), но в идеале библиотеки должны поставлять типы сами. Понимание того, как TS находит и использует эти файлы, и как читать (а иногда и писать) декларации — необходимый навык для TypeScript разработчика.