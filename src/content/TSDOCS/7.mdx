Тема #7: Типы Объединения (|) и Пересечения (&) – Алгебра Типов

Эти два оператора позволяют создавать новые типы путем комбинирования существующих, но делают это по-разному, что часто приводит к неинтуитивным результатам, если не понимать их логику.

1. Типы Объединения (| – Union Types) – "ИЛИ"

Что это? Тип A | B означает, что значение может быть либо типа A, либо типа B.
```typescript
let id: string | number;
id = 101; // OK
id = "abc-101"; // OK
// id = false; // Ошибка! boolean не входит в string | number
```
Поведение: "Наименьший Общий Знаменатель" Свойств: Когда у вас есть значение типа A | B, TypeScript для обеспечения безопасности позволит вам обращаться только к тем свойствам и методам, которые существуют и в A, и в B.
```typescript
interface Bird {
  fly(): void;
  layEggs(): void;
}
interface Fish {
  swim(): void;
  layEggs(): void; // Общий метод
}

function processCreature(creature: Bird | Fish) {
  creature.layEggs(); // OK - есть у обоих

  // creature.fly();  // ОШИБКА TS! Property 'fly' does not exist on type 'Bird | Fish'.
                     // (TS не знает, Bird это или Fish, а у Fish нет fly)
  // creature.swim(); // ОШИБКА TS! Property 'swim' does not exist on type 'Bird | Fish'.
                     // (У Bird нет swim)

  // Чтобы использовать специфичные методы, нужно Сужение Типов (Тема #8)
  if ('fly' in creature) { // Проверяем наличие метода (один из способов сужения)
      creature.fly(); // OK - TS теперь знает, что это Bird
  } else {
      creature.swim(); // OK - TS знает, что это Fish
  }
}
```
Критический взгляд: Это часто контринтуитивно. Кажется, что A | B должно давать доступ ко всем методам из A и B. Но нет! С точки зрения статической безопасности, TS не знает, какой именно тип (A или B) находится в переменной в данный момент, поэтому разрешает только то, что гарантированно есть у обоих. Объединение расширяет множество возможных значений, но сужает множество безопасно доступных операций (до сужения типа).
Частый случай: string | null | undefined. Операторы ?. (опциональная цепочка) и ?? (nullish coalescing) очень удобны для работы с такими типами.
2. Типы Пересечения (& – Intersection Types) – "И"

Что это? Тип A & B означает, что значение должно удовлетворять одновременно и типу A, и типу B. Для объектов это означает, что объект должен иметь все свойства и методы из A плюс все свойства и методы из B.
```typescript
interface Serializable {
  serialize(): string;
}
interface Loggable {
  log(message: string): void;
}

// Тип для объекта, который можно и сериализовать, и логировать
type PersistentLogger = Serializable & Loggable;

let logger: PersistentLogger = {
  serialize: () => JSON.stringify({ data: "some state" }),
  log: (msg) => console.log(`LOG: ${msg}`),
  // Можно добавить и другие свойства
  id: 123
};

logger.serialize(); // OK
logger.log("System started"); // OK
```
Пересечение Примитивов = never: Что будет, если пересечь несовместимые типы, например, примитивы?
```typescript
type Impossible = string & number;
// let x: Impossible = ???; // Невозможно создать значение, которое одновременно и строка, и число.
// Поэтому тип Impossible фактически становится 'never'.
```
Тип never означает значение, которое никогда не может существовать.
Комбинирование Объединений: Алгебра может быть сложной, например: (A | B) & (A | C) эквивалентно A | (B & C).
Критический взгляд: Пересечения очень полезны для комбинирования функциональности или требований к объектам (как "миксины" на уровне типов). Но важно помнить, что пересечение несовместимых типов приводит к never, что логично, но иногда может быть неожиданным при сложных типах.
3. Дискриминирующие Объединения (Discriminated / Tagged Unions) – Мощный Паттерн

Это очень распространенный и полезный способ использования объединений (|) для моделирования сущностей, которые могут быть одного из нескольких четко определенных видов.

Как работает:
Все типы в объединении имеют одно общее свойство (обычно kind, type или похожее).
Это свойство имеет разные, но конкретные литеральные типы для каждого варианта в объединении. Это и есть дискриминант (дискриминирующее свойство).
TypeScript может использовать проверку этого свойства (через if или switch) для точного сужения типа всего объекта внутри блока проверки.
Пример:
```typescript
interface SuccessResponse {
  status: "success"; // Литеральный тип - дискриминант
  data: { id: number; value: string };
}
interface ErrorResponse {
  status: "error"; // Другой литеральный тип - дискриминант
  errorCode: number;
  errorMessage: string;
}
interface LoadingResponse {
  status: "loading"; // Третий литеральный тип
}

type ApiResponse = SuccessResponse | ErrorResponse | LoadingResponse; // Дискриминирующее объединение

function handleResponse(response: ApiResponse) {
  switch (response.status) {
    case "success":
      // TS точно знает, что response здесь - это SuccessResponse
      console.log("Data received:", response.data.id, response.data.value);
      break;
    case "error":
      // TS точно знает, что response здесь - это ErrorResponse
      console.error(`Error ${response.errorCode}: ${response.errorMessage}`);
      break;
    case "loading":
      // TS точно знает, что response здесь - это LoadingResponse
      console.log("Still loading...");
      break;
    default:
      // Исчерпывающая проверка (если включены строгие флаги)
      const _exhaustiveCheck: never = response;
      return _exhaustiveCheck;
  }
}

handleResponse({ status: "success", data: { id: 1, value: "Test" } });
handleResponse({ status: "error", errorCode: 404, errorMessage: "Not Found" });
```
Критический взгляд: Дискриминирующие объединения — чрезвычайно мощный и безопасный способ моделирования состояний, событий, ответов API и т.п. Они сочетают гибкость объединений с надежностью проверок благодаря дискриминанту. Возможность исчерпывающей проверки (exhaustive check с помощью never) гарантирует, что вы обработали все возможные варианты, что очень полезно при рефакторинге или добавлении новых состояний.
Итог по Теме #7:

Объединения (|) и Пересечения (&) — это основные инструменты "алгебры типов" в TypeScript. Объединения расширяют набор возможных значений, но сужают набор доступных операций (до сужения типа). Пересечения комбинируют требования типов, но могут привести к never для несовместимых типов. Дискриминирующие объединения — ключевой паттерн для безопасного моделирования вариантов с помощью общего свойства-дискриминанта.
