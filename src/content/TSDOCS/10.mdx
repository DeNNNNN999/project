Тема #10: Вывод Типов (Inference) и Расширение (Widening)

## 1. Вывод Типов (Type Inference) – Умный Компилятор

**Что это?** Одна из самых удобных фич TypeScript — его способность автоматически выводить (угадывать) типы переменных, возвращаемых значений функций и т.д., даже если вы не указали тип явно через аннотацию (`: Type`).

**Зачем?** Чтобы уменьшить многословие. Вам не нужно писать `: number`, `: string` на каждом шагу.

**Как работает?** TS смотрит на:

### Значение инициализации:

```typescript
let name = "Alice"; // TS выводит 'name: string'
let age = 30;      // TS выводит 'age: number'
let isAdmin = true; // TS выводит 'isAdmin: boolean'
let user = { id: 1, name: "Bob" }; // TS выводит 'user: { id: number, name: string }'
```

### Возвращаемые значения функций:

```typescript
function add(a: number, b: number) { // Типы параметров указаны
  return a + b; // TS выводит, что функция возвращает 'number'
}
let sumResult = add(5, 3); // TS знает, что 'sumResult: number'
```

### Контекст использования (Contextual Typing):

```typescript
const numbers = [1, 2, 3];
// TS знает, что forEach ожидает (value: number, index: number, array: number[]) => void
numbers.forEach(n => { // TS выводит, что 'n' здесь - это 'number'
  console.log(n.toFixed()); // OK
});
```

**Критический взгляд:** Вывод типов — это прекрасно, он делает код на TS чище, чем если бы аннотации были нужны везде. Доверяйте выводу типов для простых случаев. Однако, для сигнатур функций (параметры и возврат), границ API и сложных типов всегда лучше указывать типы явно. Это служит документацией, улучшает читаемость и помогает поймать ошибки на более раннем этапе (если вы ошиблись в реализации функции, TS сравнит фактический возврат с ожидаемым).

## 2. Расширение Типов (Type Widening) – От Конкретного к Общему

**Что это?** Особый случай вывода типов. Когда переменная инициализируется литеральным значением (например, 10, "hello", true), TypeScript иногда "расширяет" (widens) этот конкретный литеральный тип до его базового примитивного типа (например, 10 до number, "hello" до string).

**Почему?** Основная причина — переменные, объявленные через `let` (или `var`) могут изменять свое значение. Если бы TS вывел для `let x = "hello"` тип `"hello"` (литеральный тип), то последующее присваивание `x = "world"` вызвало бы ошибку типа. Расширяя тип до `string`, TS позволяет присваивать переменной x любую другую строку.

### let vs const – Ключевое Различие:

**let (и var) - РАСШИРЯЕТСЯ:**

```typescript
let greeting = "Hello"; // greeting выводится как 'string'
greeting = "Hi"; // OK

let count = 10; // count выводится как 'number'
count = 20; // OK
```

**const - НЕ РАСШИРЯЕТСЯ (или расширяется меньше):** Так как const переменные не могут быть переприсвоены, TypeScript выводит максимально узкий, конкретный тип — обычно сам литеральный тип.

```typescript
const greetingConst = "Hello"; // greetingConst выводится как '"Hello"' (литеральный тип)
// greetingConst = "Hi"; // ОШИБКА! Cannot assign to 'greetingConst' because it is a constant.

const countConst = 10; // countConst выводится как '10' (литеральный тип)
// countConst = 20; // ОШИБКА!
```

**Объекты и Массивы с const:**
- Для `const obj = { a: 1 }`, сам obj константа, но его свойство `a` по умолчанию все еще выводится как `number` (не 1).
- Для `const arr = [1, "a"]`, тип выводится как `(string | number)[]`.

**Критический взгляд:** Точность литеральных типов у const очень полезна для работы с дискриминирующими объединениями (где kind должен быть конкретной строкой), для типизации API, ожидающих конкретные значения, и для более точного сужения типов.

## 3. as const – Берем Контроль над Расширением

**Что это?** Специальное утверждение типа (const assertion), которое говорит TypeScript: "Выведи для этого выражения самый узкий возможный неизменяемый (readonly) тип".

**Как работает:**
- Для примитивов — выводит литеральный тип (даже для let).
- Для объектных литералов — делает все свойства readonly и выводит их типы как литеральные.
- Для массивов — делает массив readonly и выводит его как кортеж (tuple) с литеральными типами элементов.

**Пример:**

```typescript
let modeLet = "dark"; // Тип: string
let modeConstAssertion = "dark" as const; // Тип: "dark" (литеральный)

const config = { url: "/api", method: "GET" };
// Тип: { url: string; method: string; } (свойства расширены до string)

const configConst = { url: "/api", method: "GET" } as const;
// Тип: { readonly url: "/api"; readonly method: "GET"; } (все readonly и литеральное)

const tupleArr = [10, "hello"] as const;
// Тип: readonly [10, "hello"] (неизменяемый кортеж)

// Практическая польза:
function setMethod(method: "GET" | "POST") { /* ... */ }
// setMethod(config.method); // ОШИБКА! 'string' не подходит для '"GET" | "POST"'
setMethod(configConst.method); // OK! Тип '"GET"' подходит.
```

**Критический взгляд:** `as const` — невероятно полезный инструмент, когда вам нужно сохранить максимальную точность типов литеральных значений. Он незаменим при работе с API, ожидающими конкретные строковые/числовые литералы, для создания неизменяемых конфигураций, для улучшения работы с дискриминирующими объединениями. Он также обеспечивает иммутабельность на уровне типов.

## 4. Границы Вывода Типов:

**Неоднозначность:** TS не всегда может вывести тип, особенно из null, undefined или пустых массивов (`let items = []` — выведется `any[]` без флага `noImplicitAny`, или `never[]` в некоторых контекстах).

**Решение:** В таких случаях нужны явные аннотации типов: `let items: string[] = [];`.

## Итог по Теме #10:

Вывод типов (Inference) — делает TS удобнее, уменьшая количество аннотаций. Расширение типов (Widening) — специфическое поведение вывода для let, делающее тип более общим. const сохраняет литеральные типы, давая больше точности. `as const` — мощный инструмент для получения максимально узких, неизменяемых литеральных типов там, где это необходимо. Понимание этих механизмов позволяет писать более точный и безопасный код.