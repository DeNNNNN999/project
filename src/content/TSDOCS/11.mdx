Тема #11: Пространства Типов vs Значений (Type Space vs Value Space)

Представь, что когда TypeScript компилирует твой код, он как бы работает с двумя параллельными "мирами" или "пространствами":

Пространство Значений (Value Space):

Это мир JavaScript, который существует во время выполнения (runtime).
Здесь живут: переменные (let, const, var), функции (как объекты), классы (как функции-конструкторы), объекты, массивы, примитивные значения (42, "hello") — всё, что реально существует и выполняется в скомпилированном .js файле.
Пространство Типов (Type Space):

Это мир TypeScript, который существует только во время компиляции (compile-time).
Здесь живут: псевдонимы типов (type), интерфейсы (interface), аннотации типов (: string), параметры дженериков (<T>), условные типы, mapped types, результаты keyof, typeof (в контексте типа) и т.д.
Важно: Всё из этого мира полностью стирается при компиляции в JavaScript (как мы обсуждали в Теме #1).
Ключевой Нюанс: Одно Имя – Два Мира

Самое важное (и иногда запутанное) — это то, что одно и то же имя может одновременно существовать и в пространстве типов, и в пространстве значений, обозначая при этом совершенно разные вещи! TypeScript достаточно умен, чтобы по контексту использования понимать, о каком "мире" идет речь.

Пример:

TypeScript

```typescript
// 1. Объявляем ТИП с именем 'User' в Пространстве Типов
interface User {
  id: number;
  name: string;
  isActive: boolean;
}
```

// 2. Объявляем КОНСТАНТУ (ЗНАЧЕНИЕ) с именем 'User' в Пространстве Значений
const User = {
  defaultName: "Anonymous",
  create(id: number, name: string): User { // Используем ТИП 'User' в аннотации возврата
    // Возвращаем объект, соответствующий ТИПУ 'User'
    return { id, name, isActive: true };
  },
  isLongName(user: User): boolean { // Используем ТИП 'User' в аннотации параметра
    return user.name.length > 10;
  }
};

// --- Использование ---

// Здесь 'User' используется как ТИП для аннотации переменной
let user1: User = { id: 1, name: "Alice", isActive: false };

// Здесь 'User' используется как ЗНАЧЕНИЕ (объект) для доступа к его свойству
let defaultUserName: string = User.defaultName;

// Здесь 'User' используется и как ЗНАЧЕНИЕ (вызов метода),
// и внутри метода используются аннотации ТИПА 'User'
let user2 = User.create(2, "Bob");
let isLong = User.isLongName(user1);

console.log(defaultUserName); // Anonymous
console.log(user2); // { id: 2, name: 'Bob', isActive: true }
console.log(isLong); // false
Особый Случай: Классы и Enum

Классы (class) и Перечисления (enum) уникальны тем, что они создают сущности сразу в обоих пространствах под одним именем:

class Person {} создает:
Тип Person в пространстве типов (описывает форму экземпляра класса).
Значение Person в пространстве значений (функцию-конструктор).
enum Status { Active, Inactive } создает:
Тип Status в пространстве типов (обычно объединение литеральных типов Status.Active | Status.Inactive).
Значение Status в пространстве значений (объект для доступа к членам Status.Active, Status[0] и т.д.).
Зачем это Понимать? (Критический взгляд)

Разрешение Неоднозначности: Когда ты читаешь код, особенно с импортами (import { Thing } from './module'), важно понимать: Thing используется как тип (например, let x: Thing) или как значение (например, new Thing(), Thing.someMethod())? Это помогает правильно интерпретировать код.

Конфликты Имен: Хотя TS позволяет одно имя в двух пространствах, это может сбивать с толку. Также важно не называть свои типы так же, как встроенные глобальные значения JavaScript (например, type String = number; или type Date = {}; — это приведет к хаосу).

Инструменты Связи Между Мирами: TypeScript предоставляет операторы, чтобы "переносить" информацию из мира значений в мир типов (но не наоборот, так как типы стираются):

typeof (в контексте типа): Позволяет получить тип существующего значения.
TypeScript

const userSettings = { theme: "dark", notifications: true };

// Получаем ТИП объекта userSettings
type SettingsType = typeof userSettings;
// SettingsType эквивалентен { theme: string; notifications: boolean; }

let currentSettings: SettingsType = { theme: "light", notifications: false };
keyof: Возвращает объединение строковых литеральных типов всех публичных ключей заданного типа.
TypeScript

interface Product { id: number; name: string; price: number; }
type ProductKeys = keyof Product; // Тип: "id" | "name" | "price"
let sortKey: ProductKeys = "price"; // OK
Индексированные Типы Доступа (T[K]): Позволяют получить тип свойства K у типа T. type ProductName = Product['name']; // string
import type: Иногда нужно импортировать только тип, без соответствующего ему значения (например, если значение — это класс, который не нужен в рантайме в данном файле, или чтобы избежать потенциальных побочных эффектов при импорте модуля). Для этого используется import type:

TypeScript

// Импортирует ТОЛЬКО ТИП User. Гарантированно будет стерто при компиляции.
import type { User } from './user-types';

// Импортирует и ТИП User, и ЗНАЧЕНИЕ User (если они оба экспортированы)
// import { User } from './user-class';

function logUser(user: User) { console.log(user); }
Критический взгляд: import type делает намерения явными и помогает инструментам сборки лучше оптимизировать код, удаляя импорты, не имеющие рантайм-эффекта.

Итог по Теме #11:

Разделение на Пространство Типов (compile-time, стирается) и Пространство Значений (runtime, JS) — фундаментальная концепция TypeScript. Понимание того, что одно и то же имя может существовать в обоих мирах, и использование операторов вроде typeof (в типах), keyof, а также import type, помогает правильно читать, писать и понимать TypeScript код, избегая путаницы.
