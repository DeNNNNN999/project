Вопросы для Проверки Понимания TypeScript (40 штук):

TS/Стирание типов: Объясните концепцию "стирания типов". Какие именно конструкции TypeScript исчезают при компиляции в JavaScript?
TS/Стирание типов: Если типы стираются, как TypeScript помогает предотвращать ошибки? Каковы ограничения этого подхода, особенно для ошибок во время выполнения (runtime)?
any vs unknown: В чем ключевое различие в безопасности между any и unknown? Приведите пример кода, где использование any скрыло бы ошибку, а unknown заставило бы ее исправить.
any vs unknown: Объясните концепцию "вирусного" или "заразного" any. Как флаг noImplicitAny помогает бороться с этим?
Структурная типизация: Что такое структурная типизация ("утиная типизация")? Приведите пример, где два разных класса/интерфейса считаются совместимыми в TypeScript.
Структурная типизация: Какие потенциальные проблемы или неочевидные моменты могут возникнуть из-за структурной типизации, особенно для разработчиков с опытом в номинативно типизированных языках?
interface vs type: Что такое "слияние деклараций" (declaration merging) и почему оно работает только для interface, но не для type? Приведите пример.
interface vs type: В каких ситуациях вы обязаны использовать type (псевдоним типа), а не interface?
Утверждения Типов: Почему утверждения типа (as Type или <Type>value) считаются потенциально небезопасными? Какую гарантию они не дают?
Утверждения Типов: Что такое двойное утверждение (as unknown as Type) и почему его следует использовать с особой осторожностью?
Дженерики: Какую основную проблему решают дженерики? Сравните дженерик-функцию с аналогичной функцией, использующей any.
Дженерики: Зачем нужны ограничения дженериков (<T extends Constraint>)? Приведите пример, где без ограничения возникла бы ошибка компиляции.
Объединения/Пересечения: Почему при доступе к свойствам значения типа объединения (A | B) доступны только общие свойства A и B (до сужения типа)?
Объединения/Пересечения: К какому типу приводит пересечение несовместимых примитивных типов, например string & number, и почему?
Объединения/Пересечения: Что такое дискриминирующее объединение (discriminated union) и как оно упрощает безопасную работу с вариантами типов?
Сужение Типов: Перечислите 3-4 способа сужения типов в TypeScript и укажите ограничения для typeof и instanceof.
Сужение Типов: Почему сужение типа переменной может "теряться" внутри вложенных функций, колбэков или после await? Как это можно обойти?
Проверка Лишних Свойств: В каких именно ситуациях TypeScript проверяет объектные литералы на наличие "лишних" свойств, и почему эта проверка была добавлена (какую проблему она решает)?
Проверка Лишних Свойств: Как можно "обойти" проверку лишних свойств, и какой способ считается наиболее приемлемым (если обход действительно нужен)?
Вывод/Расширение Типов: Объясните разницу в выводе типов для let x = "literal" и const x = "literal". Что такое "расширение типа" (widening)?
Вывод/Расширение Типов: Для чего используется as const? Как он влияет на вывод типов для объектов и массивов? Приведите пример пользы.
Пространства Типов/Значений: Объясните разницу между пространством типов и пространством значений в TypeScript. Приведите пример идентификатора, существующего в обоих пространствах.
Пространства Типов/Значений: Как операторы typeof (в контексте типа) и keyof позволяют передавать информацию из мира значений в мир типов?
Conditional/Mapped Types: В чем основная идея Mapped Types? Как они помогают избежать повторения кода при создании вариаций типов объектов?
Conditional/Mapped Types: В чем основная идея Conditional Types (extends ? :)? Объясните, что делает ключевое слово infer.
Модули/Namespaces: Почему ES Модули считаются предпочтительнее namespace в современном TypeScript? Каково было историческое назначение namespace?
Модули/Namespaces: Что такое import type и в каких случаях его использование оправдано?
Строгость Компилятора: Что делает флаг "noImplicitAny": true и почему он важен?
Строгость Компилятора: Что делает флаг "strictNullChecks": true и как он повышает безопасность кода?
Тип never: Что означает тип never? Чем он отличается от void?
Тип never: Как never используется для проверки полноты (exhaustiveness checking) в switch по дискриминирующему объединению?
Utility Types: Каково назначение встроенных утилитарных типов? Приведите 3 примера (например, Partial, Readonly, Pick) и объясните, что они делают.
Utility Types: Как создать тип объекта, где все ключи — строки, а все значения — boolean, используя Record?
tsconfig.json: Какие опции в tsconfig.json отвечают за версию генерируемого JavaScript (target) и используемую модульную систему (module)? Почему их правильный выбор важен?
tsconfig.json: Что делает опция "esModuleInterop": true и почему она часто необходима при работе с JavaScript-библиотеками?
.d.ts/@types: Каково назначение файлов деклараций (.d.ts)? Где TypeScript их ищет?
.d.ts/@types: Что такое проект DefinitelyTyped и как использовать пакеты из @types? Какие у этого подхода есть потенциальные недостатки?
Декораторы: Каков текущий статус декораторов в ECMAScript и TypeScript? Почему часто требуется флаг experimentalDecorators?
Декораторы: Для каких задач чаще всего применяются декораторы во фреймворках (приведите 2-3 примера)? В чем их "магия" и потенциальные сложности?
Номинативная Эмуляция: Зачем может понадобиться эмулировать номинативную типизацию в TypeScript? Объясните суть паттерна "Branded Types".
Практические Задачи по TypeScript (35 штук):

Erasure: Напишите функцию, принимающую value: unknown. Внутри проверьте, является ли value строкой, используя typeof. Существует ли эта проверка typeof в скомпилированном JS? Почему?
any/unknown: Исправьте код, используя сужение типов (type narrowing), чтобы избежать ошибок компиляции, не используя any или утверждения as:
TypeScript

function processData(data: unknown) {
  if (/* ??? */) {
    console.log((data as string).length); // Заменить 'as string' на безопасную проверку
  }
  if (/* ??? */) {
    console.log((data as { message: string }).message.toUpperCase()); // Заменить 'as'
  }
}
Structural Typing: Определите interface Dog { name: string; bark(): void } и interface Cat { name: string; meow(): void; age: number }. Напишите функцию printName(obj: { name: string }). Покажите, что экземпляры Dog и Cat можно передать в printName.
interface/type: Определите тип Point ({ x: number; y: number }) с помощью interface. Затем определите тип Point3D с помощью type, который расширяет Point (используя пересечение &), добавляя свойство z: number.
Assertions: Найдите и объясните ошибку времени выполнения. Перепишите код безопасно, используя type guard isUser.
TypeScript

interface User { name: string; }
function getName(val: unknown): string {
  // Предполагаем, что val всегда User
  return (val as User).name;
}
// const name = getName({ name: "Alice" }); // OK
const name = getName(null); // Runtime Error! Как исправить getName?
Generics: Напишите дженерик-функцию makePair<F, S>(first: F, second: S): [F, S], которая создает кортеж из двух переданных значений.
Generics: Напишите дженерик-класс Cache<T> с методами set(key: string, value: T) и get(key: string): T | undefined.
Generics/Constraints: Напишите дженерик-функцию getById<T extends { id: string | number }>(items: T[], id: T['id']): T | undefined, которая ищет элемент в массиве по id.
Unions/Intersections: Определите тип Result = { status: 'ok', data: string } | { status: 'error', code: number }. Напишите функцию handleResult(result: Result), которая использует switch по result.status для безопасного доступа к data или code.
Unions/Intersections: Каким будет тип type Combined = ({ a: 1 } | { b: 2 }) & { c: 3 }? Создайте значение этого типа.
Narrowing: Напишите type guard isPerson(obj: any): obj is { name: string, age: number }, который проверяет наличие и тип свойств name и age.
Narrowing: Дан value: unknown. Напишите код, который выводит "Array" если это массив, "Date" если это дата, "Object" если это простой объект (не массив, не дата, не null), и "Other" в остальных случаях. Используйте Array.isArray, instanceof Date, typeof, проверку на null.
Excess Props: Почему этот код вызывает ошибку? Как ее исправить, не меняя тип Options и не используя as?
TypeScript

interface Options { timeout?: number; }
const config = { timeout: 5000, retries: 3 };
// const options: Options = config; // Ошибка при прямом присвоении?
// Если ошибки нет, объясните почему. Если есть, как исправить?
// (Примечание: Этот вопрос хитрее, чем кажется из предыдущих объяснений - проверьте внимательно!)
(Пояснение к задаче 13: Ошибка возникнет только при прямом присвоении литерала { timeout: 5000, retries: 3 } к options. Присвоение через переменную config, как написано, ошибки не вызовет из-за структурной типизации. Задача - проверить понимание этого нюанса).
Inference/Widening: Определите переменную status с помощью const и as const так, чтобы ее тип был точно "loading", а не string.
TypeScript

// const status = ... ; // тип должен быть "loading"
Type/Value Spaces: Напишите код, чтобы получить тип параметра data функции function send(id: number, data: { payload: string }) {} используя typeof и Parameters (или Indexed Access).
Conditional/Mapped: Используя Mapped Type, создайте тип Optional<T>, который делает все свойства T необязательными (аналог Partial).
Conditional/Mapped: Напишите Conditional Type IsArray<T>, который возвращает true, если T является массивом (any[] или unknown[]), и false в противном случае.
Modules: Создайте файл constants.ts с export const MAX_USERS = 100; и файл users.ts, который импортирует MAX_USERS и использует его.
Strictness: Включите "strictNullChecks": true. Напишите функцию, которая принимает string | undefined и возвращает длину строки или 0, если строка undefined.
never: Напишите функцию processShape(shape: Shape) (используя Shape из задачи 9), которая использует switch и проверку на never в default для гарантии обработки всех видов фигур.
Utility Types: Из interface Config { readonly host: string; port: number; ssl?: boolean; retry: number; } создайте тип EditableConfig, содержащий только port и retry (и они должны быть изменяемыми). Используйте Pick/Omit/Readonly/Required/Partial.
Utility Types: Определите тип UserRoles как Record<'admin' | 'editor' | 'viewer', { permissions: string[] }> и создайте пример объекта этого типа.
tsconfig.json: Какие две ключевые опции compilerOptions нужно установить, чтобы компилировать TS в современный JS (ES2020) с использованием ES модулей?
.d.ts/@types: Вы хотите использовать библиотеку uuid (которая написана на JS). Что нужно установить с помощью npm/yarn, чтобы получить для нее типы?
.d.ts/@types: Создайте файл dom-augmentation.d.ts, который добавляет кастомный метод myCustomMethod(): void; к глобальному интерфейсу Element.
Decorators: Напишите (концептуально) декоратор метода @Debounce(delayMs), который бы откладывал выполнение декорируемого метода, если он вызывается слишком часто. (Реализация debounce не требуется, только структура декоратора).
Nominal Emulation: Создайте брендированный тип Email на основе string и функцию isEmail(value: string): value is Email (можно использовать простую проверку на @).
Generics/Conditional: Напишите дженерик тип MaybePromise<T>, который равен T | Promise<T>. Затем напишите условный тип Unwrap<T>, который извлекает U из MaybePromise<U>.
Narrowing/Guards: Дано type Vehicle = { type: 'car', drive(): void } | { type: 'bike', ride(): void }. Напишите функцию travel(v: Vehicle), которая вызывает drive или ride в зависимости от типа, используя проверку дискриминанта.
Utility Types: Используя Parameters, получите тип аргументов функции Workspace(input: RequestInfo | URL, init?: RequestInit | undefined): Promise<Response>;.
Erasure/Runtime: Представьте, что функция получает data: unknown из внешнего API. Напишите код для безопасного доступа к data.user.name (если все эти уровни существуют и name - строка), используя явные рантайм-проверки.
interface/type: Можно ли расширить type Status = "ok" | "error" новым статусом "pending" с помощью слияния деклараций? Почему? Как это сделать правильно?
Structural Typing: Будет ли объект { run: () => console.log('Run'), stop: () => {} } совместим с типом interface Runnable { run(): void; }? Почему?
Strictness: Если "strictFunctionTypes": true, почему следующий код вызовет ошибку?
TypeScript

type Listener<T> = (arg: T) => void;
function processEvents(callback: Listener<string | number>) { /* ... */ }

const stringListener: Listener<string> = (s) => console.log(s.toUpperCase());

// processEvents(stringListener); // Почему здесь может быть ошибка?
never: Каков тип X и Y? type X = 'a' | ('b' & 'c'); type Y = 'a' & never;
