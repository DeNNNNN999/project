# Тема 4: Server vs Client Components в Next.js: Новая Архитектура, Новые Правила

## Введение: Разделяй и Властвуй?

С появлением App Router в Next.js центральной концепцией стали **React Server Components (RSC)**. В отличие от Pages Router, где все компоненты по умолчанию были клиентскими, в App Router все компоненты по умолчанию — серверные. Чтобы добавить интерактивность и использовать хуки вроде `useState` или `useEffect`, компонент нужно явно пометить как клиентский директивой `"use client";`.

Это разделение — не просто синтаксическая деталь. Это основа новой архитектуры рендеринга и получения данных, которая фундаментально меняет то, как мы строим интерфейсы на Next.js. В чем суть каждого типа компонента, каковы их возможности, ограничения и как они взаимодействуют?

## Server Components (RSC) – Мозг на Сервере

### Где Выполняются:
Рендерятся исключительно на сервере. Это может происходить во время сборки (для статических путей) или по запросу пользователя (для динамических).

### Код на Клиенте:
**Важно**: JavaScript код серверных компонентов **никогда** не отправляется и не выполняется в браузере клиента. Это их ключевое преимущество для производительности.

### Возможности:

- **Прямой Доступ к Бэкенду**: Могут напрямую использовать `async`/`await` для доступа к источникам данных (базы данных, файловая система, внешние API) без необходимости создавать промежуточные API эндпоинты.

- **Серверное Окружение**: Могут безопасно использовать переменные окружения сервера, секретные ключи, работать с серверными библиотеками.

- **Нулевой Вклад в Бандл**: Так как их код не идет на клиент, они не увеличивают размер загружаемого JavaScript.

### Ограничения:

- **Нет Интерактивности**: Не могут использовать хуки, которые зависят от состояния или жизненного цикла на клиенте (`useState`, `useEffect`, `useReducer` и т.д.).

- **Нет Обработчиков Событий**: Не могут использовать обработчики событий вроде `onClick`, `onChange`.

- **Нет Доступа к API Браузера**: Не могут работать с `window`, `document`, `localStorage` и другими браузерными API.

### Результат Рендеринга:
Не HTML, а специальный, оптимизированный JSON-подобный формат (RSC Payload), описывающий отрендеренный UI. Этот Payload отправляется на клиент, где React использует его для эффективного обновления DOM.

## Client Components – Интерактивность в Браузере

### Маркер:
Чтобы компонент стал клиентским, необходимо добавить директиву `"use client";` в самом начале файла. Эта директива действует как "граница" — все компоненты, импортируемые внутрь этого файла, также будут считаться частью клиентского бандла.

### Где Выполняются:
Изначально рендерятся на сервере (для генерации первоначального HTML – это важно для SEO и FCP), но затем их код отправляется в браузер, где они проходят процесс гидратации (hydration) — "оживления" статичного HTML путем привязки обработчиков событий и восстановления состояния. После гидратации они полностью выполняются на клиенте.

### Возможности:

- **Полный React**: Могут использовать все возможности React, включая `useState`, `useEffect`, `useContext` и другие хуки.

- **Интерактивность**: Могут обрабатывать события пользователя (`onClick`, `onChange` и т.д.).

- **Доступ к API Браузера**: Могут работать с `window`, `document`, `localStorage`.

### Ограничения:

- **Нет Прямого Доступа к Бэкенду**: Не могут напрямую обращаться к БД или файловой системе. Для получения данных им нужно либо использовать `useEffect` для вызова API Routes / Server Actions, либо получать данные через props от родительских Server Components.

- **Влияние на Бандл**: Их код включается в клиентский JavaScript бандл, увеличивая его размер.

## Граница Клиент-Сервер и Взаимодействие

Понимание того, как эти два типа компонентов взаимодействуют — ключ к успеху с App Router:

### Правило Импорта:

- **Server Component НЕ может импортировать Client Component напрямую**. Почему? Потому что код Client Component должен быть известен на клиенте, а код Server Component — нет. Решение: Server Component может передать Client Component как children или через props.

- **Client Component МОЖЕТ импортировать Server Component**. React и Next.js обрабатывают это "под капотом", запрашивая RSC Payload для импортированного серверного компонента при необходимости.

### Передача Данных (Props):
Данные из Server Components в Client Components передаются только через props. **Важно**: Эти props должны быть сериализуемыми (строки, числа, булевы, простые объекты/массивы, содержащие сериализуемые значения). Нельзя передавать функции, даты, Map, Set или экземпляры классов без специальной обработки.

### Граница `"use client";`:
Эта директива определяет границу между серверным и клиентским "мирами" на уровне модулей.

## Критический Взгляд: Революция или Усложнение?

Разделение на Server/Client компоненты — это самая обсуждаемая и потенциально революционная часть App Router.

### Потенциальные Выгоды:

- **Производительность**: Значительное уменьшение размера клиентского JS -> более быстрая загрузка и интерактивность (TTI).

- **Упрощение Data Fetching**: Прямой доступ к данным из серверных компонентов может сделать код проще и убрать необходимость в слоях API.

- **Безопасность**: Чувствительные данные и логика остаются на сервере.

### Новые Сложности:

- **Ментальная Модель**: Требуется совершенно новый образ мышления. Нужно постоянно держать в голове, где выполняется компонент и что ему доступно. Это сложнее, чем модель SPA, где "всё на клиенте".

- **Ограничения**: Невозможность использовать хуки в RSC или прямой доступ к бэкенду в Client Components заставляет перестраивать архитектуру.

- **Сериализация Props**: Ограничение на передаваемые props требует внимания.

- **Отладка**: Диагностика проблем на границе сервер-клиент может быть нетривиальной.

- **Риск Злоупотребления "use client"**: Есть соблазн помечать всё как клиентское, чтобы избежать сложностей, но это сводит на нет преимущества RSC. Нужно осознанно минимизировать клиентский код.

## Итог

Server Components и Client Components в Next.js App Router — это фундаментально новая архитектура для React-приложений. RSC обещают значительный выигрыш в производительности и упрощение доступа к данным, перенося часть работы с клиента на сервер. Client Components остаются необходимыми для любой интерактивности.

Однако эта модель вносит существенную сложность, требует нового мышления от разработчиков и имеет свои ограничения (особенно по передаче данных и использованию хуков). Понимание этого разделения, правил взаимодействия и ограничений — абсолютно необходимо для работы с современным Next.js.
