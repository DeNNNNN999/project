# Тема 10: Стилизация в Next.js: CSS Modules, Tailwind, CSS-in-JS – Война Подходов?

## Введение: Как Красить Компоненты?

Стилизация React-приложений — это область, где всегда было много подходов и жарких споров. Next.js не навязывает один-единственный способ, а предлагает встроенную поддержку нескольких популярных методологий и позволяет интегрировать другие. Глобальный CSS, изолированные CSS Modules, утилитарный Tailwind CSS, динамический CSS-in-JS (как Styled Components или Emotion) — все они имеют место быть в экосистеме Next.js.

Но какой подход выбрать? В чем их фундаментальные различия, плюсы, минусы, и, что особенно важно для Next.js, как они взаимодействуют с серверным рендерингом (SSR), статической генерацией (SSG) и новыми React Server Components (RSC)?

## Встроенные Подходы Next.js

Next.js "из коробки" отлично поддерживает несколько CSS-стратегий:

### Глобальные Стили (styles/globals.css)

- **Механизм**: Обычный CSS-файл, импортируемый в корневой компонент (`_app.js` в Pages Router, `layout.js` в App Router). Стили применяются ко всему приложению.
- **Применение**: Базовые стили, сбросы (reset.css), стилизация body, глобальные CSS-переменные.
- **Критический взгляд**: Необходимы для основ, но их глобальная природа — прямой путь к конфликтам имен классов и сложностям поддержки в больших проектах. Не подходят для стилизации отдельных компонентов.

### CSS Modules (*.module.css)

- **Механизм**: CSS-файлы с суффиксом `.module.css`. Next.js во время сборки автоматически генерирует уникальные имена классов (например, `Button_button__1a2b3c`), обеспечивая локальную область видимости стилей. Импортируются в компонент как объект.

```javascript
// Button.module.css
.button { background-color: blue; }

// Button.jsx
import styles from './Button.module.css';
<button className={styles.button}>Click me</button>
```

- **Плюсы**: Изоляция стилей (нет конфликтов), стандартный синтаксис CSS, генерируется статический CSS (отлично для производительности), хорошо работает с SSR/SSG/RSC.
- **Минусы**: Чуть больше кода для подключения (import, styles.), менее удобно для динамических стилей, зависящих от множества props.
- **Критический взгляд**: Считается одним из лучших подходов для большинства Next.js приложений. Обеспечивает баланс между стандартным CSS и компонентной изоляцией, отлично работает с серверными парадигмами Next.js.

### Sass/SCSS (*.scss, *.module.scss)

- **Механизм**: Встроенная поддержка после установки пакета `sass`. Можно использовать как глобально, так и с CSS Modules.
- **Плюсы**: Вся мощь препроцессора (переменные, миксины, вложенность).
- **Критический взгляд**: Отличное дополнение к CSS Modules для тех, кто привык к SCSS.

### PostCSS / Tailwind CSS

- **Механизм**: Next.js поддерживает PostCSS "из коробки". Популярнейший фреймворк Tailwind CSS легко настраивается поверх PostCSS.
- **Философия Tailwind**: Утилитарный подход — стилизация через набор готовых мелких классов прямо в HTML (`<div class="mt-4 font-bold text-blue-500">`).
- **Плюсы Tailwind**: Очень быстрая разработка UI, консистентность дизайна, отличная оптимизация (удаление неиспользуемых стилей через Purge), хорошо работает с SSR/SSG/RSC.
- **Минусы Tailwind**: Может приводить к "замусориванию" HTML классами. Требует привыкания к утилитарной парадигме. Кастомизация под сложный дизайн может потребовать усилий.
- **Критический взгляд**: Tailwind завоевал огромную популярность. Это другая философия стилизации, но очень продуктивная. Отлично подходит для Next.js благодаря генерации статического CSS.

## CSS-in-JS (Styled Components, Emotion и др.)

- **Механизм**: Стили определяются как строки или объекты внутри JavaScript/TypeScript кода, часто с использованием теговых шаблонных литералов. Библиотека динамически генерирует и применяет стили во время выполнения.

```javascript
// Styled Components Пример
import styled from 'styled-components';
const Button = styled.button`
  background: palevioletred;
  color: white;
  padding: ${props => props.primary ? '1em' : '0.5em'}; // Динамические стили!
`;
<Button primary>Click</Button>
```

### Плюсы
- Стили привязаны к компоненту.
- Легкость создания динамических стилей, зависящих от props или состояния.
- Использование всей мощи JS (переменные, функции) для стилей.

### Минусы
- **Runtime Производительность**: Главный недостаток. Генерация и вставка стилей во время выполнения добавляет оверхед на клиенте, может замедлять Time To Interactive (TTI).
- **Размер Бандла**: Сама библиотека CSS-in-JS добавляет вес.
- **Сложности с SSR**: Требуют специальной конфигурации для серверного рендеринга (извлечение стилей и передача их в `<head>`), что может быть нетривиально.
- **ПРОБЛЕМЫ С REACT SERVER COMPONENTS (RSC)**: Ключевое противоречие! Поскольку RSC выполняются только на сервере и их JS не идет на клиент, они не могут использовать runtime CSS-in-JS. Библиотека просто не будет работать на клиенте для применения стилей к RSC. Это стало серьезным препятствием для использования классических CSS-in-JS в App Router.

## Критический Взгляд: Война Парадигм и Влияние RSC

### Build-time (CSS Modules, Tailwind)
Генерируют статический CSS во время сборки. Минимум или ноль runtime-оверхеда. Идеально совместимы с SSR, SSG и React Server Components. Считаются более производительным и "родным" подходом для современного Next.js.

### Runtime CSS-in-JS (Styled Components, Emotion)
Предлагают великолепный Developer Experience (DX) для динамических стилей, но ценой runtime-производительности и увеличения размера бандла. Их использование с Server Components стало основной проблемой, требующей либо отказа от них в RSC, либо использования библиотек CSS-in-JS, работающих на этапе компиляции (compile-time, например, Linaria, vanilla-extract), либо сложных настроек.

### Тренд
С появлением RSC и акцентом React/Next.js на уменьшение клиентского JS и улучшение производительности, явный тренд сместился в сторону build-time CSS решений. Runtime CSS-in-JS библиотеки активно ищут пути адаптации к новой реальности RSC, но их использование в App Router значительно усложнилось.

## Итог

Next.js предлагает гибкость в выборе стилизации, но не все подходы одинаково хорошо сочетаются с его современной архитектурой. CSS Modules и Tailwind CSS являются наиболее рекомендуемыми вариантами благодаря генерации статического CSS, отличной производительности и полной совместимости с Server Components.

Классические runtime CSS-in-JS библиотеки, несмотря на отличный DX для динамических стилей, несут издержки производительности и столкнулись с фундаментальными проблемами совместимости с Server Components, что делает их выбор для новых проектов на App Router менее предпочтительным или требующим компромиссов (использование только в Client Components).
